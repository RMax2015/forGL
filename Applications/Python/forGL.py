# Generated by Haxe 4.0.0-rc.2+c4b042533
# coding: utf-8

from datetime import datetime as python_lib_datetime_Datetime
import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sys as python_lib_Sys
import re as python_lib_Re
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
try:
    import tty as python_lib_Tty
except:
    pass
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None


class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_methods = ["toString"]
    _hx_statics = ["now"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    def toString(self):
        m = ((self.date.month - 1) + 1)
        d = self.date.day
        h = self.date.hour
        mi = self.date.minute
        s = self.date.second
        return ((((((((((Std.string(self.date.year) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(m)) if ((m < 10)) else ("" + Std.string(m)))))) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(d)) if ((d < 10)) else ("" + Std.string(d)))))) + " ") + HxOverrides.stringOrNull(((("0" + Std.string(h)) if ((h < 10)) else ("" + Std.string(h)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(mi)) if ((mi < 10)) else ("" + Std.string(mi)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(s)) if ((s < 10)) else ("" + Std.string(s))))))

    @staticmethod
    def now():
        d = Date(1970,0,1,0,0,0)
        d.date = python_lib_datetime_Datetime.now()
        return d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "split", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = -1):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x3 = HxString.substr(s,lastEnd,None)
            ret.append(x3)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]

    def replace(self,s,by):
        _this = by.split("$$")
        by1 = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by1
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this1 = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this1])
            _this2 = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this2])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None


class Main:
    _hx_class_name = "Main"
    __slots__ = ()
    _hx_statics = ["forGLRun", "text_line", "main", "initRunForGL"]
    forGLRun = None

    @staticmethod
    def main():
        start_dir = ""
        forGL_ForGL_ui.system_name = "Unknown_system_name"
        forGL_ForGL_ui.system_name = Sys.systemName()
        start_dir = Sys.getCwd()
        stdout = Sys.stdout()
        this1 = hx_strings_ansi__AnsiWriter_OutputStringWriter(stdout)
        writer = hx_strings_ansi_AnsiWriter(this1)
        try:
            tmp = ("Windows" == forGL_ForGL_ui.system_name)
            writer._out.write(((("\x1B[" + "3") + Std.string(7)) + "m"))
            _this = writer
            _this._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
            _this1 = _this
            _this1._out.write((("\x1B[" + Std.string(1)) + "m"))
            _this2 = _this1
            _this2._out.write(("\x1B[" + "2J"))
            _this3 = _this2
            _this3._out.flush()
            forGL_ForGL_ui.msg("forGL: ")
            forGL_ForGL_ui.msg("Python\n")
            Main.text_line = 2
            Main.initRunForGL()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nException in main(): " + Std.string(e)) + " \n"))
        #                                                                                    ")
        #  Restore any changed values before exit                                            ")
        #                                                                                    ")
        Sys.setCwd(start_dir)
        writer._out.write(((("\x1B[" + "3") + Std.string(6)) + "m"))
        _this4 = writer
        _this4._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
        _this5 = _this4
        _this5._out.write((("\x1B[" + Std.string(1)) + "m"))
        _this6 = _this5
        _this6._out.flush()
        return

    @staticmethod
    def initRunForGL():
        ret_val = 0
        init_lines = 0
        Main.forGLRun = forGL_ForGL_Run()
        init_result = 0
        err_str = ""
        actual_path_file = "forGL_Dictionary_Prototype.toml"
        args = Sys.args()
        if (0 < len(args)):
            actual_path_file = (args[0] if 0 < len(args) else None)
        does_exist = sys_FileSystem.exists(actual_path_file)
        if (False == does_exist):
            does_exist = sys_FileSystem.exists(("../" + ("null" if actual_path_file is None else actual_path_file)))
            if (True == does_exist):
                actual_path_file = ("../" + ("null" if actual_path_file is None else actual_path_file))
            else:
                found_file = ""
                file_list = sys_FileSystem.readDirectory(".")
                i = 0
                while (i < len(file_list)):
                    if (False == sys_FileSystem.isDirectory((file_list[i] if i >= 0 and i < len(file_list) else None))):
                        temp = (file_list[i] if i >= 0 and i < len(file_list) else None).lower()
                        if (6 <= len(temp)):
                            extension = HxString.substr(temp,-5,None)
                            if (".toml" == extension):
                                found_file = (file_list[i] if i >= 0 and i < len(file_list) else None)
                                break
                    i = (i + 1)
                forGL_ForGL_ui.msg((((("null" if actual_path_file is None else actual_path_file) + " not found. Use ") + ("null" if found_file is None else found_file)) + " instead (y/n) ?"))
                is_yes = forGL_ForGL_ui.enterYes()
                if is_yes:
                    actual_path_file = found_file
                    does_exist = True
        if (True == does_exist):
            init_result = Main.forGLRun.init(actual_path_file,init_lines)
        else:
            err_str = (" " + ("null" if actual_path_file is None else actual_path_file))
            init_result = -9
        def _hx_local_0():
            _hx_local_1 = init_result
            if (Std._hx_is(_hx_local_1,Int) or ((_hx_local_1 is None))):
                _hx_local_1
            else:
                raise _HxException("Class cast error")
            return _hx_local_1
        _hx_local_2 = Main
        _hx_local_3 = _hx_local_2.text_line
        _hx_local_2.text_line = (_hx_local_3 + Math.floor(Reflect.field(Math,"fabs")(_hx_local_0())))
        _hx_local_2.text_line
        _hx_local_4 = Main
        _hx_local_5 = _hx_local_4.text_line
        _hx_local_4.text_line = (_hx_local_5 + 1)
        _hx_local_5
        def _hx_local_0():
            _hx_local_6 = init_result
            if (Std._hx_is(_hx_local_6,Int) or ((_hx_local_6 is None))):
                _hx_local_6
            else:
                raise _HxException("Class cast error")
            return _hx_local_6
        if (_hx_local_0() < 0):
            forGL_ForGL_ui.error(((("\n    SEVERE ERROR  " + Std.string(forGL_MeansWhat.returnMeanAsStr(init_result))) + ("null" if err_str is None else err_str)) + " trying to Initialize the Runtime service.  Stopping."))
            return init_result
        _hx_local_7 = Main
        _hx_local_8 = _hx_local_7.text_line
        _hx_local_7.text_line = (_hx_local_8 + 1)
        _hx_local_8
        _hx_local_9 = Main
        _hx_local_10 = _hx_local_9.text_line
        _hx_local_9.text_line = (_hx_local_10 + 1)
        _hx_local_10
        Main.forGLRun.run_text_line = Main.text_line
        Main.forGLRun.run()
        Main.forGLRun.cleanUp()
        return ret_val


class TestUI:
    _hx_class_name = "TestUI"
    __slots__ = ()
    _hx_statics = ["simple"]

    @staticmethod
    def simple():
        haxe_Log.trace("Hello ",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 692, 'className': "TestUI", 'methodName': "simple"}))
        forGL_ForGL_ui.msg("forGL ?\n")
        f = 0.0
        txt = "\n"
        while (f < 2.0):
            txt = (Std.string(f) + "\n")
            forGL_ForGL_ui.msg(txt)
            f = (f + 1)
        _hx_str = "Veränderung"
        forGL_ForGL_ui.msg((Std.string(_hx_str) + "\n"))
        str_len = (0 if ((_hx_str is None)) else len(_hx_str))
        haxe_Log.trace(str_len,None)
        if (str_len != 11):
            forGL_ForGL_ui.msg(" WRONG string length")
        forGL_ForGL_ui.msg("\n")
        str2 = "はいはい"
        forGL_ForGL_ui.msg((("\n" + Std.string(str2)) + "\n"))
        str2_len = (0 if ((str2 is None)) else len(str2))
        haxe_Log.trace(str2_len,None)
        if (str2_len != 4):
            forGL_ForGL_ui.msg(" WRONG string length")
        forGL_ForGL_ui.msg("\n")
        stdout = Sys.stdout()
        stdout.writeString(((("\x1B[" + "3") + Std.string(1)) + "m"))
        stdout.writeString(((("\x1B[" + "4") + Std.string(7)) + "m"))
        stdout.writeString((("\x1B[" + Std.string(1)) + "m"))
        stdout.writeString((("\x1B[" + Std.string(0)) + "m"))
        stdout.writeString(hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.MoveUp(2)))
        this1 = hx_strings_ansi__AnsiWriter_OutputStringWriter(stdout)
        writer = hx_strings_ansi_AnsiWriter(this1)
        str1 = hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.GoToPos(20,10))
        writer._out.write(str1)
        _this = writer
        _this._out.write(((("\x1B[" + "3") + Std.string(2)) + "m"))
        _this1 = _this
        _this1._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
        _this2 = _this1
        _this2._out.write((("\x1B[" + Std.string(3)) + "m"))
        _this3 = _this2
        _this3._out.write("How are you?")
        _this4 = _this3
        _this4._out.write((("\x1B[" + Std.string(0)) + "m"))
        _this5 = _this4
        str3 = hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.MoveDown(2))
        _this5._out.write(str3)
        _this6 = _this5
        _this6._out.write(((("\x1B[" + "3") + Std.string(1)) + "m"))
        _this7 = _this6
        _this7._out.write(((("\x1B[" + "4") + Std.string(7)) + "m"))
        _this8 = _this7
        _this8._out.write((("\x1B[" + Std.string(4)) + "m"))
        _this9 = _this8
        _this9._out.write("Hello World! (in color?)")
        _this10 = _this9
        _this10._out.write((("\x1B[" + Std.string(24)) + "m"))
        _this11 = _this10
        _this11._out.flush()


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp2 = None
            try:
                tmp2 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp2 = None
            tmp = (v == tmp2)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp3 = None
        try:
            tmp3 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = False
        if tmp3:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            while (currentClass is not None):
                if loop(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                prefix = HxString.substr(x,0,2).lower()
                if (prefix == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim", "replace", "hex"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "rename", "isDirectory", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def rename(path,newPath):
        python_lib_Os.rename(path,newPath)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["args", "sleep", "getCwd", "setCwd", "systemName", "getChar", "stdin", "stdout"]

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def getCwd():
        return python_lib_Os.getcwd()

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getwch(),0)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            x1 = _g
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        if echo:
            python_Lib.printString(Std.string("".join(map(chr,[ch]))))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getSuperClass", "createEmptyInstance"]

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl1):
            sc = Type.getSuperClass(cl1)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl1,"_hx_empty_init"):
                cl1._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i


class forGL_Comments:
    _hx_class_name = "forGL.Comments"
    __slots__ = ()
    _hx_statics = ["extract"]

    @staticmethod
    def extract(e):
        _g = e.expr
        if (_g.index == 0):
            _g1 = _g.params[0]
            if (_g1.index == 2):
                v = _g1.params[0]
                temp = v
                if (len(temp) < 80):
                    str80 = "                                                                                "
                    temp = (("null" if temp is None else temp) + HxOverrides.stringOrNull(HxString.substr(str80,0,(len(str80) - len(temp)))))
                return temp
            else:
                return "not a proper comment"
        else:
            return "not a proper comment"


class forGL_DictWord:
    _hx_class_name = "forGL.DictWord"
    __slots__ = ("internal_token", "visible_token", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means")
    _hx_fields = ["internal_token", "visible_token", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means"]

    def __init__(self,internal_word,visible_word,data_str,data_float,word_type,noun_data,data_int,op_means):
        self.internal_token = internal_word
        self.visible_token = visible_word
        self.token_str = data_str
        self.token_float = data_float
        self.token_type = word_type
        self.token_noun_data = noun_data
        self.token_int = data_int
        self.token_op_means = op_means

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.internal_token = None
        _hx_o.visible_token = None
        _hx_o.token_str = None
        _hx_o.token_float = None
        _hx_o.token_type = None
        _hx_o.token_noun_data = None
        _hx_o.token_int = None
        _hx_o.token_op_means = None


class forGL_NLDictionary:
    _hx_class_name = "forGL.NLDictionary"
    __slots__ = ("path_dictionary_file", "use_Built_In_Dictionary", "unique_Dictionary_Words", "words_added_by_init", "addWord_msg")
    _hx_fields = ["path_dictionary_file", "use_Built_In_Dictionary", "unique_Dictionary_Words", "words_added_by_init", "addWord_msg"]
    _hx_methods = ["init", "showDictionaryWords", "findWord", "levenshteinDistance", "findCommonPrefix", "findCommonSuffix", "findSimilar", "addWord", "sortDictionary", "getCustomWords", "cleanUp"]

    def __init__(self):
        self.addWord_msg = ""
        self.words_added_by_init = 0
        self.unique_Dictionary_Words = list()
        self.use_Built_In_Dictionary = False
        self.path_dictionary_file = ""

    def init(self,path_dict_file):
        #  Initialize everything needed for a given Dictionary                               ")
        result = 0
        self.path_dictionary_file = path_dict_file
        self.use_Built_In_Dictionary = False
        i = 1
        def _hx_local_0():
            _hx_local_0 = 65
            if (Std._hx_is(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise _HxException("Class cast error")
            return _hx_local_0
        limit = _hx_local_0()
        name_internal = ""
        op_means = 0
        add_result = 0
        while (i <= limit):
            def _hx_local_0():
                _hx_local_1 = i
                if (Std._hx_is(_hx_local_1,Int) or ((_hx_local_1 is None))):
                    _hx_local_1
                else:
                    raise _HxException("Class cast error")
                return _hx_local_1
            op_means = _hx_local_0()
            name_internal = forGL_MeansWhat.opMeanAsStr(op_means,True)
            if (0 < ((0 if ((name_internal is None)) else len(name_internal)))):
                add_result = self.addWord(name_internal,2,name_internal,op_means)
            i = (i + 1)
        self.addWord("into",2,"=:",33)
        self.addWord("from",2,":=",34)
        add_result = self.addWord("if",12,"if")
        add_result = self.addWord("else",12,"else")
        add_result = self.addWord("while",12,"while")
        add_result = self.addWord("for",12,"for")
        add_result = self.addWord("switch",12,"switch")
        add_result = self.addWord("case",12,"case")
        add_result = self.addWord("default",12,"default")
        add_result = self.addWord("break",12,"break")
        add_result = self.addWord("continue",12,"continue")
        add_result = self.addWord("return",12,"return")
        add_result = self.addWord("repeat",3,"repeat")
        add_result = self.addWord("show",3,"show")
        add_result = self.addWord("view",3,"view")
        self.words_added_by_init = self.sortDictionary()
        return result

    def showDictionaryWords(self,skip_operators = True,wait = True):
        if (skip_operators is None):
            skip_operators = True
        if (wait is None):
            wait = True
        lines_added = 1
        if (0 == len(self.unique_Dictionary_Words)):
            return 0
        forGL_ForGL_ui.msg("    Show Dictionary (y/n) ? ",2,False)
        char_code = Sys.getChar(True)
        forGL_ForGL_ui.msg("\n")
        forGL_ForGL_ui.eraseToLineEnd(0)
        if ((89 != char_code) and ((121 != char_code))):
            return 1
        message = ((" has " + Std.string(len(self.unique_Dictionary_Words))) + " Words")
        if (self.words_added_by_init == len(self.unique_Dictionary_Words)):
            message = ("Dictionary (built in)" + ("null" if message is None else message))
        else:
            message = (HxOverrides.stringOrNull(self.path_dictionary_file) + ("null" if message is None else message))
        if skip_operators:
            message = (("null" if message is None else message) + ", skipping Operators")
        message = (("null" if message is None else message) + "\n")
        forGL_ForGL_ui.msg(message,2)
        lines_added = (lines_added + 1)
        color = 7
        word_type = 0
        visible_word = ""
        internal_word = ""
        string_data = ""
        j = 0
        while (j < len(self.unique_Dictionary_Words)):
            if (skip_operators and ((2 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_type))):
                j = (j + 1)
                continue
            word_type = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_type
            visible_word = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).visible_token
            internal_word = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).internal_token
            color = forGL_ForGL_ui.getTypeColor(word_type)
            if (7 < ((0 if ((visible_word is None)) else len(visible_word)))):
                forGL_ForGL_ui.msg((Std.string(visible_word) + "\t"),color)
            else:
                forGL_ForGL_ui.msg((Std.string(visible_word) + "\t\t"),color)
            if (7 < ((0 if ((internal_word is None)) else len(internal_word)))):
                forGL_ForGL_ui.msg((Std.string(internal_word) + "\t"))
            else:
                forGL_ForGL_ui.msg((Std.string(internal_word) + "\t\t"))
            if (2 == word_type):
                forGL_ForGL_ui.msg((Std.string(forGL_MeansWhat.opMeanAsStr((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_op_means)) + "\n"),color)
            else:
                forGL_ForGL_ui.msg((HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type)) + "\t"),color)
                string_data = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_str
                if (6 == word_type):
                    if (8 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string(string_data) + "\n"))
                    elif (10 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        if (1 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_int):
                            forGL_ForGL_ui.msg("true\n")
                        else:
                            forGL_ForGL_ui.msg("false\n")
                    elif (9 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_int) + "\n"))
                    elif (11 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_float) + "\n"))
                elif (4 == word_type):
                    forGL_ForGL_ui.msg((Std.string(string_data) + "\n"))
                elif (3 == word_type):
                    forGL_ForGL_ui.msg("\n")
                elif (12 == word_type):
                    forGL_ForGL_ui.msg("\n")
            lines_added = (lines_added + 1)
            j = (j + 1)
        if wait:
            forGL_ForGL_ui.msg("    Hit a key when ready.\r",2,False)
            char_code1 = Sys.getChar(False)
            forGL_ForGL_ui.eraseToLineEnd(0)
        return lines_added

    def findWord(self,word_name):
        #  Find a Word in this Dictionary                                                    ")
        if (0 == ((0 if ((word_name is None)) else len(word_name)))):
            return -2
        search_name = hx_strings_Strings.toLowerCase8(word_name)
        i = 0
        while (i < len(self.unique_Dictionary_Words)):
            if (search_name == hx_strings_Strings.toLowerCase8((self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token)):
                return i
            i = (i + 1)
        return -1

    def levenshteinDistance(self,s1,s2):
        #  Find the difference between 2 strings using Levenshtein Distance algorithm.       ")
        m = (0 if ((s1 is None)) else len(s1))
        n = (0 if ((s2 is None)) else len(s2))
        costs = list()
        k = 0
        while (k <= n):
            costs.append(k)
            k = (k + 1)
        corner = 0
        upper = 0
        t = 0
        j = 0
        i = 0
        s1_it1 = None
        it2 = 0
        it1 = 0
        while (it1 != m):
            python_internal_ArrayImpl._set(costs, 0, (i + 1))
            corner = i
            j = 0
            s1_it1 = hx_strings_Strings.charAt8(s1,it1)
            it2 = 0
            while (it2 != n):
                upper = python_internal_ArrayImpl._get(costs, (j + 1))
                if (s1_it1 == hx_strings_Strings.charAt8(s2,it2)):
                    python_internal_ArrayImpl._set(costs, (j + 1), corner)
                else:
                    t = (upper if ((upper < corner)) else corner)
                    python_internal_ArrayImpl._set(costs, (j + 1), ((((costs[j] if j >= 0 and j < len(costs) else None) if (((costs[j] if j >= 0 and j < len(costs) else None) < t)) else t)) + 1))
                corner = upper
                it2 = (it2 + 1)
                j = (j + 1)
            it1 = (it1 + 1)
            i = (i + 1)
        result = (costs[n] if n >= 0 and n < len(costs) else None)
        return result

    def findCommonPrefix(self,_hx_str,str2):
        #  Finds the common Prefix of 2 strings                                              ")
        prefixNew = ""
        count = (0 if ((_hx_str is None)) else len(_hx_str))
        if (count > ((0 if ((str2 is None)) else len(str2)))):
            count = (0 if ((str2 is None)) else len(str2))
        i = 0
        while (i < count):
            if (hx_strings_Strings.charAt8(_hx_str,i) == hx_strings_Strings.charAt8(str2,i)):
                prefixNew = (Std.string(prefixNew) + HxOverrides.stringOrNull(hx_strings_Strings.charAt8(_hx_str,i)))
            else:
                break
            i = (i + 1)
        return prefixNew

    def findCommonSuffix(self,_hx_str,str2):
        #  Finds the common Suffix of 2 strings                                              ")
        suffixNew = ""
        size = (0 if ((_hx_str is None)) else len(_hx_str))
        size2 = (0 if ((str2 is None)) else len(str2))
        count = size
        if (count > size2):
            count = size2
        if (0 == count):
            return suffixNew
        index = (size - 1)
        index2 = (size2 - 1)
        i = 0
        while (i < count):
            if (hx_strings_Strings.charAt8(_hx_str,index) == hx_strings_Strings.charAt8(str2,index2)):
                suffixNew = (HxOverrides.stringOrNull(hx_strings_Strings.charAt8(_hx_str,index)) + Std.string(suffixNew))
                index = (index - 1)
                index2 = (index2 - 1)
            else:
                break
            i = (i + 1)
        return suffixNew

    def findSimilar(self,word_internal_name):
        #  Find Word(s) in this Dictionary that are Similar to given word                    ")
        if (((0 if ((word_internal_name is None)) else len(word_internal_name))) <= 1):
            return ""
        apply_cost = False
        cost = 999999999
        prev_cost = -1
        prev_similar = ""
        _hx_str = ""
        str2 = ""
        preFix = ""
        i = 0
        while (i < len(self.unique_Dictionary_Words)):
            str1 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            if (((0 if ((str1 is None)) else len(str1))) <= 1):
                i = (i + 1)
                continue
            if (word_internal_name == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token):
                return word_internal_name
            _hx_str = word_internal_name
            str2 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            if (hx_strings_Strings.charAt8(_hx_str,0) == hx_strings_Strings.charAt8(str2,0)):
                prefix = self.findCommonPrefix(_hx_str,str2)
                _hx_str = hx_strings_Strings.removeLeading(_hx_str,preFix)
                str2 = hx_strings_Strings.removeLeading(str2,preFix)
            if (((0 if ((_hx_str is None)) else len(_hx_str))) == 0):
                cost = (0 if ((str2 is None)) else len(str2))
            elif (((0 if ((str2 is None)) else len(str2))) == 0):
                cost = (0 if ((_hx_str is None)) else len(_hx_str))
            else:
                if (hx_strings_Strings.charAt8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - 1)) == hx_strings_Strings.charAt8(str2,(((0 if ((str2 is None)) else len(str2))) - 1))):
                    suffix = self.findCommonSuffix(_hx_str,str2)
                    _hx_str = hx_strings_Strings.removeTrailing(_hx_str,suffix)
                    str2 = hx_strings_Strings.removeTrailing(str2,suffix)
                if (((0 if ((_hx_str is None)) else len(_hx_str))) == 0):
                    cost = (0 if ((str2 is None)) else len(str2))
                elif (((0 if ((str2 is None)) else len(str2))) == 0):
                    cost = (0 if ((_hx_str is None)) else len(_hx_str))
                else:
                    cost = self.levenshteinDistance(_hx_str,str2)
            apply_cost = False
            if (0 <= prev_cost):
                if (cost < prev_cost):
                    apply_cost = True
            else:
                apply_cost = True
            if apply_cost:
                prev_cost = cost
                prev_similar = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            i = (i + 1)
        return prev_similar

    def addWord(self,word_name,word_type = 0,name_internal = "",op_means = 0,data_str = "",data_float = 0.0,data_int = 0,noun_data = 0,replaceIdx = -1):
        if (word_type is None):
            word_type = 0
        if (name_internal is None):
            name_internal = ""
        if (op_means is None):
            op_means = 0
        if (data_str is None):
            data_str = ""
        if (data_float is None):
            data_float = 0.0
        if (data_int is None):
            data_int = 0
        if (noun_data is None):
            noun_data = 0
        if (replaceIdx is None):
            replaceIdx = -1
        #  Add or Replace a Word in this Dictionary                                          ")
        ret_val = 0
        self.addWord_msg = ""
        if ((((((0 == ((0 if ((word_name is None)) else len(word_name)))) or ((0 == ((0 if ((name_internal is None)) else len(name_internal)))))) or ((0 == word_type))) or (((2 == word_type) and ((0 == op_means))))) or (((6 == word_type) and ((0 == noun_data))))) or (((4 == word_type) and (("" == data_str))))):
            forGL_ForGL_ui.status("")
            self.addWord_msg = (((((("ERROR: Invalid: " + Std.string(word_name)) + " ") + Std.string(name_internal)) + " ") + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type))) + " ")
            if (2 == word_type):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.addWord_msg
                _hx_local_0.addWord_msg = (("null" if _hx_local_1 is None else _hx_local_1) + Std.string(forGL_MeansWhat.opMeanAsStr(op_means)))
                _hx_local_0.addWord_msg
            elif (6 == word_type):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.addWord_msg
                _hx_local_2.addWord_msg = (("null" if _hx_local_3 is None else _hx_local_3) + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type)))
                _hx_local_2.addWord_msg
            elif (4 == word_type):
                if (0 == ((0 if ((data_str is None)) else len(data_str)))):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.addWord_msg
                    _hx_local_4.addWord_msg = (("null" if _hx_local_5 is None else _hx_local_5) + "without any Value")
                    _hx_local_4.addWord_msg
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.addWord_msg
            _hx_local_6.addWord_msg = (("null" if _hx_local_7 is None else _hx_local_7) + "\n")
            _hx_local_6.addWord_msg
            forGL_ForGL_ui.error(self.addWord_msg,1)
        name_internal = hx_strings_Strings.toLowerCase8(name_internal)
        if (0 <= replaceIdx):
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).internal_token = name_internal
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).visible_token = word_name
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_str = data_str
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_float = data_float
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_type = word_type
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_noun_data = noun_data
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_int = data_int
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_op_means = op_means
        else:
            find_idx = self.findWord(word_name)
            if (0 <= find_idx):
                self.addWord_msg = (("ERROR: Word " + Std.string(word_name)) + " already in Dictionary")
                return -3
            _this = self.unique_Dictionary_Words
            x = forGL_DictWord(name_internal,word_name,data_str,data_float,word_type,noun_data,data_int,op_means)
            _this.append(x)
        return ret_val

    def sortDictionary(self):
        if (1 < len(self.unique_Dictionary_Words)):
            def _hx_local_0(a,b):
                return hx_strings_Strings.compareIgnoreCase(a.visible_token,b.visible_token)
            self.unique_Dictionary_Words.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        return len(self.unique_Dictionary_Words)

    def getCustomWords(self):
        #  Get a list of all Dictionary words not automatically generated                    ")
        custom_words = list()
        i = 0
        while (i < len(self.unique_Dictionary_Words)):
            if ((6 == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).token_type) or ((4 == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).token_type))):
                x = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token
                custom_words.append(x)
            elif ((self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token != (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token):
                x1 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token
                custom_words.append(x1)
            i = (i + 1)
        return custom_words

    def cleanUp(self):
        ret_val = 0
        self.unique_Dictionary_Words = [forGL_DictWord(".",".","",0.0,0,0,0,0)]
        _this = self.unique_Dictionary_Words
        if (len(_this) != 0):
            _this.pop()
        return ret_val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path_dictionary_file = None
        _hx_o.use_Built_In_Dictionary = None
        _hx_o.unique_Dictionary_Words = None
        _hx_o.words_added_by_init = None
        _hx_o.addWord_msg = None


class forGL_NLExport:
    _hx_class_name = "forGL.NLExport"
    __slots__ = ("exportWords_msgs", "exportWords_replaced", "exportWords_added")
    _hx_fields = ["exportWords_msgs", "exportWords_replaced", "exportWords_added"]
    _hx_methods = ["init", "cleanUp", "exportWords"]

    def __init__(self):
        self.exportWords_added = 0
        self.exportWords_replaced = 0
        self.exportWords_msgs = ""

    def init(self):
        pass

    def cleanUp(self):
        pass

    def exportWords(self,_hx_dict,dict_path_file,data,export_type = 1):
        if (export_type is None):
            export_type = 1
        #                                                                                    ")
        #  Export the in memory Dictionary to a file.                                        ")
        #                                                                                    ")
        result = 0
        self.exportWords_msgs = ""
        self.exportWords_replaced = 0
        self.exportWords_added = 0
        words_replaced = list()
        words_added = list()
        #                                                                                    ")
        #  These are words that were Imported earlier.                                       ")
        #                                                                                    ")
        imported_words = data.getListOfWords(False)
        #  These are all the words a User has added/changed in the Dictionary                ")
        out_words = _hx_dict.getCustomWords()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.exportWords_msgs
        _hx_local_0.exportWords_msgs = (Std.string(_hx_local_1) + ((("Information: " + Std.string(len(out_words))) + " words to Export.\n")))
        _hx_local_0.exportWords_msgs
        if (0 == len(out_words)):
            return 0
        if (0 == len(imported_words)):
            return -10
        _hx_str = _hx_dict.path_dictionary_file
        if (0 == ((0 if ((_hx_str is None)) else len(_hx_str)))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.exportWords_msgs
            _hx_local_2.exportWords_msgs = (Std.string(_hx_local_3) + "INTERNAL ERROR: Export: No physical Dictionary file available to rename.\n")
            _hx_local_2.exportWords_msgs
            return -11
        str1 = (("Words to Export are: " + Std.string(out_words)) + "\n")
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.exportWords_msgs
        _hx_local_4.exportWords_msgs = (Std.string(_hx_local_5) + ("null" if str1 is None else str1))
        _hx_local_4.exportWords_msgs
        new_file_name = _hx_dict.path_dictionary_file
        extension = HxString.substr(new_file_name,(len(new_file_name) - 5),5)
        backup_name = HxString.substr(new_file_name,0,(len(new_file_name) - ((0 if ((extension is None)) else len(extension)))))
        #  Date and Time as part of name                                                     ")
        now_date = Date.now()
        date_raw = now_date.toString()
        date_str = ""
        i = 0
        while (i < len(date_raw)):
            char = ("" if (((i < 0) or ((i >= len(date_raw))))) else date_raw[i])
            if (("-" == char) or ((":" == char))):
                date_str = (("null" if date_str is None else date_str) + "_")
            elif (" " == char):
                date_str = (("null" if date_str is None else date_str) + "__")
            else:
                date_str = (("null" if date_str is None else date_str) + ("null" if char is None else char))
            i = (i + 1)
        backup_name = (("null" if backup_name is None else backup_name) + HxOverrides.stringOrNull(((("_Backup_" + ("null" if date_str is None else date_str)) + ("null" if extension is None else extension)))))
        data.renameFile(_hx_dict.path_dictionary_file,backup_name)
        rInfo = forGL_ResolveInfo()
        dict_idx = -1
        i = 0
        while (i < len(out_words)):
            dict_idx = _hx_dict.findWord((out_words[i] if i >= 0 and i < len(out_words) else None))
            if (dict_idx < 0):
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.exportWords_msgs
                _hx_local_11.exportWords_msgs = (Std.string(_hx_local_12) + HxOverrides.stringOrNull(((("INTERNAL ERROR: findWord of " + Std.string((out_words[i] if i >= 0 and i < len(out_words) else None))) + " was not found. Skipping to next word.\n"))))
                _hx_local_11.exportWords_msgs
                i = (i + 1)
                continue
            dict_word = (_hx_dict.unique_Dictionary_Words[dict_idx] if dict_idx >= 0 and dict_idx < len(_hx_dict.unique_Dictionary_Words) else None)
            rInfo.resolve_str = dict_word.token_str
            rInfo.resolve_float = dict_word.token_float
            rInfo.resolve_int = dict_word.token_int
            rInfo.resolve_op_meaning = dict_word.token_op_means
            rInfo.resolve_token_noun_data = dict_word.token_noun_data
            rInfo.resolve_out_token = dict_word.internal_token
            replaceOrAdd_result = data.replaceOrAddWord(dict_word.visible_token,dict_word.token_type,rInfo)
            def _hx_local_0():
                _hx_local_14 = replaceOrAdd_result
                if (Std._hx_is(_hx_local_14,Int) or ((_hx_local_14 is None))):
                    _hx_local_14
                else:
                    raise _HxException("Class cast error")
                return _hx_local_14
            if (0 == _hx_local_0()):
                if data.replaceOrAddWord_replaced:
                    _hx_local_15 = self
                    _hx_local_16 = _hx_local_15.exportWords_replaced
                    _hx_local_15.exportWords_replaced = (_hx_local_16 + 1)
                    _hx_local_16
                    words_added.append(0)
                    words_replaced.append(1)
                else:
                    _hx_local_17 = self
                    _hx_local_18 = _hx_local_17.exportWords_added
                    _hx_local_17.exportWords_added = (_hx_local_18 + 1)
                    _hx_local_18
                    words_added.append(1)
                    words_replaced.append(0)
            else:
                result = replaceOrAdd_result
                words_added.append(0)
                words_replaced.append(0)
            i = (i + 1)
        save_result = data.saveToFile(_hx_dict.path_dictionary_file)
        def _hx_local_0():
            _hx_local_20 = save_result
            if (Std._hx_is(_hx_local_20,Int) or ((_hx_local_20 is None))):
                _hx_local_20
            else:
                raise _HxException("Class cast error")
            return _hx_local_20
        if (0 != _hx_local_0()):
            if (0 == result):
                result = save_result
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.exportWords_msgs = None
        _hx_o.exportWords_replaced = None
        _hx_o.exportWords_added = None


class forGL_NLExportAs:
    _hx_class_name = "forGL.NLExportAs"
    __slots__ = ("exportAsCode_msgs", "verbCount")
    _hx_fields = ["exportAsCode_msgs", "verbCount"]
    _hx_methods = ["init", "cleanUp"]

    def __init__(self):
        self.verbCount = 0
        self.exportAsCode_msgs = ""

    def init(self):
        pass

    def cleanUp(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.exportAsCode_msgs = None
        _hx_o.verbCount = None


class forGL_MeansWhat:
    _hx_class_name = "forGL.MeansWhat"
    __slots__ = ()
    _hx_statics = ["opMeanAsStr", "returnMeanAsStr"]

    @staticmethod
    def opMeanAsStr(op_meaning,ret_internal = False):
        if (ret_internal is None):
            ret_internal = False
        #  Helper to give a readable string for an Operator or an internal string            ")
        ret_str = ""
        op_meaning1 = op_meaning
        if (op_meaning1 == 0):
            if ret_internal:
                ret_str = ""
            else:
                ret_str = "Unknown"
        elif (op_meaning1 == 1):
            if ret_internal:
                ret_str = "+"
            else:
                ret_str = "Plus"
        elif (op_meaning1 == 2):
            if ret_internal:
                ret_str = "-"
            else:
                ret_str = "Minus"
        elif (op_meaning1 == 3):
            if ret_internal:
                ret_str = "*"
            else:
                ret_str = "Multiply by"
        elif (op_meaning1 == 4):
            if ret_internal:
                ret_str = "/"
            else:
                ret_str = "Divide by"
        elif (op_meaning1 == 5):
            if ret_internal:
                ret_str = "%"
            else:
                ret_str = "Modulo"
        elif (op_meaning1 == 6):
            if ret_internal:
                ret_str = "min"
            else:
                ret_str = "Minimum"
        elif (op_meaning1 == 7):
            if ret_internal:
                ret_str = "max"
            else:
                ret_str = "Maximum"
        elif (op_meaning1 == 8):
            if ret_internal:
                ret_str = "atan2"
            else:
                ret_str = "ArcTan2"
        elif (op_meaning1 == 9):
            if ret_internal:
                ret_str = "pow"
            else:
                ret_str = "to Power of"
        elif (op_meaning1 == 10):
            if ret_internal:
                ret_str = "=="
            else:
                ret_str = "Is Equal?"
        elif (op_meaning1 == 11):
            if ret_internal:
                ret_str = "!="
            else:
                ret_str = "Is Not Equal?"
        elif (op_meaning1 == 12):
            if ret_internal:
                ret_str = "<"
            else:
                ret_str = "Is Less Than?"
        elif (op_meaning1 == 13):
            if ret_internal:
                ret_str = "<="
            else:
                ret_str = "Is Less or Equal?"
        elif (op_meaning1 == 14):
            if ret_internal:
                ret_str = ">"
            else:
                ret_str = "Is Greater Than?"
        elif (op_meaning1 == 15):
            if ret_internal:
                ret_str = ">="
            else:
                ret_str = "Is Greater or Equal?"
        elif (op_meaning1 == 16):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "Left Paren"
        elif (op_meaning1 == 17):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "Right Paren"
        elif (op_meaning1 == 18):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "Expression start"
        elif (op_meaning1 == 19):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "Expression end"
        elif (op_meaning1 == 20):
            if ret_internal:
                ret_str = "["
            else:
                ret_str = "Left Square Bracket"
        elif (op_meaning1 == 21):
            if ret_internal:
                ret_str = "]"
            else:
                ret_str = "Right Square Bracket"
        elif (op_meaning1 == 22):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "List start"
        elif (op_meaning1 == 23):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "List end"
        elif (op_meaning1 == 24):
            if ret_internal:
                ret_str = "{"
            else:
                ret_str = "Left Curly Brace"
        elif (op_meaning1 == 25):
            if ret_internal:
                ret_str = "}"
            else:
                ret_str = "Right Curly Brace"
        elif (op_meaning1 == 26):
            if ret_internal:
                ret_str = "{"
            else:
                ret_str = "Block start"
        elif (op_meaning1 == 27):
            if ret_internal:
                ret_str = "}"
            else:
                ret_str = "BLock end"
        elif (op_meaning1 == 28):
            if ret_internal:
                ret_str = "concat"
            else:
                ret_str = "Concatenate"
        elif (op_meaning1 == 29):
            if ret_internal:
                ret_str = "unconcat"
            else:
                ret_str = "Un Concatenate"
        elif (op_meaning1 == 30):
            if ret_internal:
                ret_str = "pi"
            else:
                ret_str = "Pi"
        elif (op_meaning1 == 31):
            if ret_internal:
                ret_str = "random"
            else:
                ret_str = "Random"
        elif (op_meaning1 == 32):
            if ret_internal:
                ret_str = "="
            else:
                ret_str = "Assignment"
        elif (op_meaning1 == 33):
            if ret_internal:
                ret_str = "=:"
            else:
                ret_str = "Assign into"
        elif (op_meaning1 == 34):
            if ret_internal:
                ret_str = ":="
            else:
                ret_str = "Assign from"
        elif (op_meaning1 == 35):
            if ret_internal:
                ret_str = "--"
            else:
                ret_str = "Decrease by 1"
        elif (op_meaning1 == 36):
            if ret_internal:
                ret_str = "++"
            else:
                ret_str = "Increase by 1"
        elif (op_meaning1 == 45):
            if ret_internal:
                ret_str = "."
            else:
                ret_str = "Period"
        elif (op_meaning1 == 46):
            if ret_internal:
                ret_str = ","
            else:
                ret_str = "Comma"
        elif (op_meaning1 == 47):
            if ret_internal:
                ret_str = ":"
            else:
                ret_str = "Colon"
        elif (op_meaning1 == 48):
            if ret_internal:
                ret_str = ";"
            else:
                ret_str = "Semicolon"
        elif (op_meaning1 == 49):
            if ret_internal:
                ret_str = "."
            else:
                ret_str = "Punctuation"
        elif (op_meaning1 == 50):
            if ret_internal:
                ret_str = "abs"
            else:
                ret_str = "Absolute value"
        elif (op_meaning1 == 51):
            if ret_internal:
                ret_str = "degrees"
            else:
                ret_str = "to Degrees"
        elif (op_meaning1 == 52):
            if ret_internal:
                ret_str = "radians"
            else:
                ret_str = "to Radians"
        elif (op_meaning1 == 53):
            if ret_internal:
                ret_str = "sin"
            else:
                ret_str = "Sine"
        elif (op_meaning1 == 54):
            if ret_internal:
                ret_str = "cos"
            else:
                ret_str = "Cosine"
        elif (op_meaning1 == 55):
            if ret_internal:
                ret_str = "tan"
            else:
                ret_str = "Tangent"
        elif (op_meaning1 == 56):
            if ret_internal:
                ret_str = "asin"
            else:
                ret_str = "ArcSine"
        elif (op_meaning1 == 57):
            if ret_internal:
                ret_str = "acos"
            else:
                ret_str = "ArcCosine"
        elif (op_meaning1 == 58):
            if ret_internal:
                ret_str = "atan"
            else:
                ret_str = "ArcTangent"
        elif (op_meaning1 == 59):
            if ret_internal:
                ret_str = "exp"
            else:
                ret_str = "e to the power of"
        elif (op_meaning1 == 60):
            if ret_internal:
                ret_str = "ln"
            else:
                ret_str = "natural Logarithm"
        elif (op_meaning1 == 61):
            if ret_internal:
                ret_str = "log"
            else:
                ret_str = "base 10 Logarithm"
        elif (op_meaning1 == 62):
            if ret_internal:
                ret_str = "sqrt"
            else:
                ret_str = "SquareRoot"
        elif (op_meaning1 == 63):
            if ret_internal:
                ret_str = "round"
            else:
                ret_str = "Round"
        elif (op_meaning1 == 64):
            if ret_internal:
                ret_str = "floor"
            else:
                ret_str = "Floor"
        elif (op_meaning1 == 65):
            if ret_internal:
                ret_str = "ceil"
            else:
                ret_str = "Ceiling"
        else:
            pass
        return ret_str

    @staticmethod
    def returnMeanAsStr(ret_meaning):
        #  Helper to give a readable string for a Return value number                        ")
        ret_str = ""
        ret_meaning1 = ret_meaning
        if (ret_meaning1 == -11):
            ret_str = "INTERNAL ERROR found"
        elif (ret_meaning1 == -10):
            ret_str = "INTERNAL ERROR: is NOT IMPLEMENTED"
        elif (ret_meaning1 == -9):
            ret_str = "ERROR: File not found"
        elif (ret_meaning1 == -8):
            ret_str = "ERROR: File path not found"
        elif (ret_meaning1 == -5):
            ret_str = "User code has a Logical error"
        elif (ret_meaning1 == -4):
            ret_str = "User code has a Syntax error"
        elif (ret_meaning1 == -3):
            ret_str = "Data type or value given is not appropriate"
        elif (ret_meaning1 == -2):
            ret_str = "User code has an error"
        elif (ret_meaning1 == -1):
            ret_str = "User wanted to Stop"
        elif (ret_meaning1 == 0):
            ret_str = "OK, normal result"
        elif (ret_meaning1 == 1):
            ret_str = "Not enough Data now, trying next words"
        elif (ret_meaning1 == 2):
            ret_str = "Not enough Nouns now, trying next words"
        elif (ret_meaning1 == 3):
            ret_str = "No punctuation yet, trying next words"
        else:
            pass
        return ret_str


class forGL_NLImport:
    _hx_class_name = "forGL.NLImport"
    __slots__ = ("importWords_msgs",)
    _hx_fields = ["importWords_msgs"]
    _hx_methods = ["init", "cleanUp", "importWords"]

    def __init__(self):
        self.importWords_msgs = ""

    def init(self):
        pass

    def cleanUp(self):
        pass

    def importWords(self,data,_hx_dict,dict_path_file):
        #                                                                                    ")
        #  Support adding somewhat validated words from the Data layer to a Dictionary in memory.  ")
        #                                                                                    ")
        result = 0
        self.importWords_msgs = ""
        words = data.getListOfWords()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.importWords_msgs
        _hx_local_0.importWords_msgs = (Std.string(_hx_local_1) + ((("Information: " + Std.string(len(words))) + " words to import.\n")))
        _hx_local_0.importWords_msgs
        if (0 == len(words)):
            return 0
        next_word = ""
        words_str = (words[0] if 0 < len(words) else None)
        i = 1
        while (i < len(words)):
            next_word = (words[i] if i >= 0 and i < len(words) else None)
            words_str = (Std.string(words_str) + HxOverrides.stringOrNull(((", " + Std.string(next_word)))))
            i = (i + 1)
        _hx_str = (("Words to Import are: " + Std.string(words_str)) + "\n")
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.importWords_msgs
        _hx_local_4.importWords_msgs = (Std.string(_hx_local_5) + ("null" if _hx_str is None else _hx_str))
        _hx_local_4.importWords_msgs
        rInfo = forGL_ResolveInfo()
        rOtherInfo = forGL_ResolveInfo()
        find_result = 0
        i = 0
        while (i < len(words)):
            find_result = data.findWordDef((words[i] if i >= 0 and i < len(words) else None),rInfo)
            if (0 != find_result):
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.importWords_msgs
                _hx_local_6.importWords_msgs = (Std.string(_hx_local_7) + HxOverrides.stringOrNull(((((("INTERNAL ERROR: findWordDef of " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " has unexpected result of ") + Std.string(forGL_MeansWhat.returnMeanAsStr(find_result))) + ". Skipping to next word.\n"))))
                _hx_local_6.importWords_msgs
                i = (i + 1)
                continue
            str1 = rInfo.resolve_out_token
            if (0 == ((0 if ((str1 is None)) else len(str1)))):
                rInfo.resolve_out_token = hx_strings_Strings.toLowerCase8((words[i] if i >= 0 and i < len(words) else None))
            rInfo.resolve_use_out = True
            dictIdx = _hx_dict.findWord((words[i] if i >= 0 and i < len(words) else None))
            if ((2 == data.findWordDef_type) and ((0 == rInfo.resolve_op_meaning))):
                resolve_result = forGL_NLTypeAs.resolveType(rInfo.resolve_out_token,rOtherInfo,False,False)
                if (2 == resolve_result):
                    rInfo.resolve_op_meaning = rOtherInfo.resolve_op_meaning
                    rInfo.resolve_out_token = rOtherInfo.resolve_out_token
                else:
                    #                                                                                    ")
                    #  Dictionary may have a reference to a Built In Verb rather than an Operator        ")
                    #  Example: 'zeigen' is German for 'show' (changed '' to ' for easy reading here)    ")
                    #  [_zeigen_]                                                                        ")
                    #  word_type = 'operator'                                                            ")
                    #  name = 'zeigen'                                                                   ")
                    #  built_in_name = 'show'                                                            ")
                    #                                                                                    ")
                    #  The above call to resolveType should have set resolve_result to NL_VERB_BI        ")
                    #                                                                                    ")
                    if (3 == resolve_result):
                        rInfo.resolve_op_meaning = rOtherInfo.resolve_op_meaning
                        rInfo.resolve_out_token = rOtherInfo.resolve_out_token
                        #  We know this really is a Built In Verb                                            ")
                        data.findWordDef_type = 3
                    else:
                        err_msg = (("INTERNAL ERROR: Word " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " unable to resolve details of Operator type. Skipping to next word.\n")
                        _hx_local_9 = self
                        _hx_local_10 = _hx_local_9.importWords_msgs
                        _hx_local_9.importWords_msgs = (Std.string(_hx_local_10) + ("null" if err_msg is None else err_msg))
                        _hx_local_9.importWords_msgs
                        forGL_ForGL_ui.error(err_msg)
                        i = (i + 1)
                        continue
            if (2 == data.findWordDef_type):
                built_in_op_str = forGL_MeansWhat.opMeanAsStr(rInfo.resolve_op_meaning,True)
                rInfo.resolve_out_token = built_in_op_str
            if (6 == data.findWordDef_type):
                rInfo.resolve_op_meaning = 0
                if (8 == rInfo.resolve_token_noun_data):
                    rInfo.resolve_float = 0.0
                    rInfo.resolve_int = 0
                    resolve_result1 = forGL_NLTypeAs.resolveType(rInfo.resolve_str,rOtherInfo,False,True)
                    if ((0 != resolve_result1) and ((8 != resolve_result1))):
                        rInfo.resolve_token_noun_data = resolve_result1
                        rInfo.resolve_str = ""
                        resolve_result2 = resolve_result1
                        if (resolve_result2 == 9):
                            rInfo.resolve_int = rOtherInfo.resolve_int
                        elif (resolve_result2 == 10):
                            rInfo.resolve_int = rOtherInfo.resolve_int
                        elif (resolve_result2 == 11):
                            rInfo.resolve_float = rOtherInfo.resolve_float
                        else:
                            err_msg1 = (("INTERNAL ERROR: importWords " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " Unexpected resolve result. Skipping to next Word.\n")
                            _hx_local_12 = self
                            _hx_local_13 = _hx_local_12.importWords_msgs
                            _hx_local_12.importWords_msgs = (Std.string(_hx_local_13) + ("null" if err_msg1 is None else err_msg1))
                            _hx_local_12.importWords_msgs
                            forGL_ForGL_ui.error(err_msg1,1)
                            i = (i + 1)
                            continue
            if (4 == data.findWordDef_type):
                rInfo.resolve_token_noun_data = 0
                rInfo.resolve_op_meaning = 0
                rInfo.resolve_float = 0.0
                rInfo.resolve_int = 0
            if (0 <= dictIdx):
                replace_result = _hx_dict.addWord((words[i] if i >= 0 and i < len(words) else None),data.findWordDef_type,rInfo.resolve_out_token,rInfo.resolve_op_meaning,rInfo.resolve_str,rInfo.resolve_float,rInfo.resolve_int,rInfo.resolve_token_noun_data,dictIdx)
                def _hx_local_0():
                    _hx_local_15 = replace_result
                    if (Std._hx_is(_hx_local_15,Int) or ((_hx_local_15 is None))):
                        _hx_local_15
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_15
                if ((0 != _hx_local_0()) or ((0 < len(_hx_dict.addWord_msg)))):
                    forGL_ForGL_ui.status(Std.string(rInfo))
                    forGL_ForGL_ui.status(_hx_dict.addWord_msg)
                result = replace_result
            else:
                add_result = _hx_dict.addWord((words[i] if i >= 0 and i < len(words) else None),data.findWordDef_type,rInfo.resolve_out_token,rInfo.resolve_op_meaning,rInfo.resolve_str,rInfo.resolve_float,rInfo.resolve_int,rInfo.resolve_token_noun_data)
                def _hx_local_0():
                    _hx_local_16 = add_result
                    if (Std._hx_is(_hx_local_16,Int) or ((_hx_local_16 is None))):
                        _hx_local_16
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_16
                if ((0 != _hx_local_0()) or ((0 < len(_hx_dict.addWord_msg)))):
                    forGL_ForGL_ui.status(Std.string(rInfo))
                    forGL_ForGL_ui.status(_hx_dict.addWord_msg)
                result = add_result
            i = (i + 1)
        if (0 < len(words)):
            _hx_dict.sortDictionary()
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.importWords_msgs = None


class forGL_ResolveInfo:
    _hx_class_name = "forGL.ResolveInfo"
    __slots__ = ("resolve_token_noun_data", "resolve_int", "resolve_float", "resolve_str", "resolve_out_token", "resolve_use_out", "resolve_op_meaning")
    _hx_fields = ["resolve_token_noun_data", "resolve_int", "resolve_float", "resolve_str", "resolve_out_token", "resolve_use_out", "resolve_op_meaning"]

    def __init__(self):
        self.resolve_token_noun_data = 0
        self.resolve_int = 0
        self.resolve_float = 0.0
        self.resolve_str = ""
        self.resolve_out_token = ""
        self.resolve_use_out = False
        self.resolve_op_meaning = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resolve_token_noun_data = None
        _hx_o.resolve_int = None
        _hx_o.resolve_float = None
        _hx_o.resolve_str = None
        _hx_o.resolve_out_token = None
        _hx_o.resolve_use_out = None
        _hx_o.resolve_op_meaning = None


class forGL_NLTypeAs:
    _hx_class_name = "forGL.NLTypeAs"
    __slots__ = ()
    _hx_statics = ["nlTypeAsStr", "resolveType"]

    @staticmethod
    def nlTypeAsStr(nl_type):
        ret_str = ""
        nl_type1 = nl_type
        if (nl_type1 == 0):
            ret_str = "Unknown"
        elif (nl_type1 == 1):
            ret_str = "Comment"
        elif (nl_type1 == 2):
            ret_str = "Operator"
        elif (nl_type1 == 3):
            ret_str = "Verb, Built In"
        elif (nl_type1 == 4):
            ret_str = "Verb"
        elif (nl_type1 == 5):
            ret_str = "Return from Verb"
        elif (nl_type1 == 6):
            ret_str = "Noun"
        elif (nl_type1 == 7):
            ret_str = "Noun, Local"
        elif (nl_type1 == 8):
            ret_str = "String"
        elif (nl_type1 == 9):
            ret_str = "Integer"
        elif (nl_type1 == 10):
            ret_str = "Bool"
        elif (nl_type1 == 11):
            ret_str = "Float"
        elif (nl_type1 == 12):
            ret_str = "Choice"
        else:
            pass
        return ret_str

    @staticmethod
    def resolveType(in_token,rInfo,run_verbose = False,trim_quotes = False):
        if (run_verbose is None):
            run_verbose = False
        if (trim_quotes is None):
            trim_quotes = False
        #  See if given token matches a Natural Language type                                ")
        #  Returns the Type of the Natural Language token                                    ")
        type_found = 0
        verbose = run_verbose
        rInfo.resolve_use_out = False
        if (("true" == in_token) or (("false" == in_token))):
            if ("true" == in_token):
                rInfo.resolve_int = 1
            else:
                rInfo.resolve_int = 0
            return 10
        if ((("\"" == hx_strings_Strings.charAt8(in_token,0)) and ((1 < ((0 if ((in_token is None)) else len(in_token)))))) and (("\"" == hx_strings_Strings.charAt8(in_token,(((0 if ((in_token is None)) else len(in_token))) - 1))))):
            rInfo.resolve_str = in_token
            type_found = 8
            if (not trim_quotes):
                return type_found
            elif (3 <= ((0 if ((in_token is None)) else len(in_token)))):
                this1 = hx_strings_internal__Either2__Either2.a("\"")
                in_token = hx_strings_Strings.trim(in_token,this1)
            else:
                return type_found
        rInfo.resolve_str = ""
        rInfo.resolve_float = Std.parseFloat(in_token)
        if (not python_lib_Math.isnan(rInfo.resolve_float)):
            if (((0.0 == rInfo.resolve_float) and ((2 < ((0 if ((in_token is None)) else len(in_token)))))) and (("0" == hx_strings_Strings.charAt8(in_token,0)))):
                if (("x" == hx_strings_Strings.charAt8(in_token,1)) or (("X" == hx_strings_Strings.charAt8(in_token,1)))):
                    rInfo.resolve_int = Std.parseInt(in_token)
                    if verbose:
                        forGL_ForGL_ui.msg((((("\nHex number " + Std.string(in_token)) + " is now ") + Std.string(rInfo.resolve_int)) + "\n"))
                    return 9
            type_found = 11
            decimal_idx = hx_strings_Strings.indexOf8(in_token,".")
            test_tokens = [""]
            if (len(test_tokens) != 0):
                test_tokens.pop()
            if (-1 != decimal_idx):
                x = hx_strings_Strings.substringBefore(in_token,".")
                test_tokens.append(x)
                x1 = hx_strings_Strings.substringAfter(in_token,".")
                test_tokens.append(x1)
            else:
                test_tokens.append(in_token)
            test_tokens_len = len(test_tokens)
            if verbose:
                forGL_ForGL_ui.msg((("test_tokens.length = " + Std.string(test_tokens_len)) + "\n"))
                forGL_ForGL_ui.msg((("test_tokens[0] = " + Std.string((test_tokens[0] if 0 < len(test_tokens) else None))) + "\n"))
            if (2 == test_tokens_len):
                if (0 == Std.parseInt((test_tokens[1] if 1 < len(test_tokens) else None))):
                    test_tokens_len = 1
            if (1 == test_tokens_len):
                rInfo.resolve_int = Std.parseInt((test_tokens[0] if 0 < len(test_tokens) else None))
                cast_float = rInfo.resolve_int
                diff_float = (rInfo.resolve_float - cast_float)
                if verbose:
                    forGL_ForGL_ui.msg((("resolve_float = " + Std.string(rInfo.resolve_float)) + "\n"))
                    forGL_ForGL_ui.msg((("  cast_float  = " + Std.string(cast_float)) + "\n"))
                    forGL_ForGL_ui.msg((("  diff_float  = " + Std.string(diff_float)) + "\n"))
                if (0.0 == diff_float):
                    type_found = 9
            elif verbose:
                forGL_ForGL_ui.msg((("test_tokens.length = " + Std.string(len(test_tokens))) + "\n"))
        else:
            type_found = 2
            in_token1 = in_token
            if (in_token1 == "!="):
                rInfo.resolve_op_meaning = 11
            elif (in_token1 == "%"):
                rInfo.resolve_op_meaning = 5
            elif (in_token1 == "("):
                rInfo.resolve_op_meaning = 18
            elif (in_token1 == ")"):
                rInfo.resolve_op_meaning = 19
            elif (in_token1 == "*"):
                rInfo.resolve_op_meaning = 3
            elif (in_token1 == "**"):
                rInfo.resolve_out_token = "**"
                rInfo.resolve_op_meaning = 9
            elif (in_token1 == "+"):
                rInfo.resolve_op_meaning = 1
            elif (in_token1 == "++"):
                rInfo.resolve_op_meaning = 36
            elif (in_token1 == ","):
                rInfo.resolve_op_meaning = 46
            elif (in_token1 == "-"):
                rInfo.resolve_op_meaning = 2
            elif (in_token1 == "--"):
                rInfo.resolve_op_meaning = 35
            elif (in_token1 == "."):
                rInfo.resolve_op_meaning = 45
            elif (in_token1 == "/"):
                rInfo.resolve_op_meaning = 4
            elif (in_token1 == ":"):
                rInfo.resolve_op_meaning = 47
            elif (in_token1 == ":="):
                rInfo.resolve_op_meaning = 34
            elif (in_token1 == ";"):
                rInfo.resolve_op_meaning = 48
            elif (in_token1 == "<"):
                rInfo.resolve_op_meaning = 12
            elif (in_token1 == "<="):
                rInfo.resolve_op_meaning = 13
            elif (in_token1 == "="):
                rInfo.resolve_op_meaning = 32
            elif (in_token1 == "=:"):
                rInfo.resolve_op_meaning = 33
            elif (in_token1 == "=="):
                rInfo.resolve_op_meaning = 10
            elif (in_token1 == ">"):
                rInfo.resolve_op_meaning = 14
            elif (in_token1 == ">="):
                rInfo.resolve_op_meaning = 15
            elif (in_token1 == "["):
                rInfo.resolve_op_meaning = 22
            elif (in_token1 == "]"):
                rInfo.resolve_op_meaning = 23
            elif (in_token1 == "^"):
                rInfo.resolve_out_token = "^"
                rInfo.resolve_op_meaning = 9
            elif (in_token1 == "{"):
                rInfo.resolve_op_meaning = 26
            elif (in_token1 == "}"):
                rInfo.resolve_op_meaning = 27
            else:
                type_found = 0
            if (2 == type_found):
                return 2
            type_found = 2
            in_token_lower = hx_strings_Strings.toLowerCase8(in_token)
            in_token_lower1 = in_token_lower
            if (in_token_lower1 == "abs"):
                rInfo.resolve_out_token = "abs"
                rInfo.resolve_op_meaning = 50
            elif (in_token_lower1 == "acos"):
                rInfo.resolve_out_token = "acos"
                rInfo.resolve_op_meaning = 57
            elif (in_token_lower1 == "add"):
                rInfo.resolve_out_token = "+"
                rInfo.resolve_op_meaning = 1
            elif (in_token_lower1 == "asin"):
                rInfo.resolve_out_token = "asin"
                rInfo.resolve_op_meaning = 56
            elif (in_token_lower1 == "atan"):
                rInfo.resolve_out_token = "atan"
                rInfo.resolve_op_meaning = 58
            elif (in_token_lower1 == "atan2"):
                rInfo.resolve_out_token = "atan2"
                rInfo.resolve_op_meaning = 8
            elif (in_token_lower1 == "ceil"):
                rInfo.resolve_out_token = "ceil"
                rInfo.resolve_op_meaning = 65
            elif (in_token_lower1 == "concat"):
                rInfo.resolve_out_token = "concat"
                rInfo.resolve_op_meaning = 28
            elif (in_token_lower1 == "concatenate"):
                rInfo.resolve_out_token = "concat"
                rInfo.resolve_op_meaning = 28
            elif (in_token_lower1 == "cos"):
                rInfo.resolve_out_token = "cos"
                rInfo.resolve_op_meaning = 54
            elif (in_token_lower1 == "decrement"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 35
            elif (in_token_lower1 == "degree"):
                rInfo.resolve_out_token = "degrees"
                rInfo.resolve_op_meaning = 51
            elif (in_token_lower1 == "degrees"):
                rInfo.resolve_out_token = "degrees"
                rInfo.resolve_op_meaning = 51
            elif (in_token_lower1 == "divide"):
                rInfo.resolve_out_token = "/"
                rInfo.resolve_op_meaning = 4
            elif (in_token_lower1 == "divided"):
                rInfo.resolve_out_token = "/"
                rInfo.resolve_op_meaning = 4
            elif (in_token_lower1 == "equal"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 32
            elif (in_token_lower1 == "equals"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 32
            elif (in_token_lower1 == "exp"):
                rInfo.resolve_out_token = "exp"
                rInfo.resolve_op_meaning = 59
            elif (in_token_lower1 == "floor"):
                rInfo.resolve_out_token = "floor"
                rInfo.resolve_op_meaning = 64
            elif (in_token_lower1 == "from"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 34
            elif (in_token_lower1 == "increment"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 36
            elif (in_token_lower1 == "into"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 33
            elif (in_token_lower1 == "ln"):
                rInfo.resolve_out_token = "ln"
                rInfo.resolve_op_meaning = 60
            elif (in_token_lower1 == "log"):
                rInfo.resolve_out_token = "log"
                rInfo.resolve_op_meaning = 61
            elif (in_token_lower1 == "max"):
                rInfo.resolve_out_token = "max"
                rInfo.resolve_op_meaning = 7
            elif (in_token_lower1 == "min"):
                rInfo.resolve_out_token = "min"
                rInfo.resolve_op_meaning = 6
            elif (in_token_lower1 == "minus"):
                rInfo.resolve_out_token = "-"
                rInfo.resolve_op_meaning = 2
            elif (in_token_lower1 == "mod"):
                rInfo.resolve_out_token = "%"
                rInfo.resolve_op_meaning = 5
            elif (in_token_lower1 == "modulo"):
                rInfo.resolve_out_token = "%"
                rInfo.resolve_op_meaning = 5
            elif (in_token_lower1 == "multiplied"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "multiply"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "pi"):
                rInfo.resolve_out_token = "pi"
                rInfo.resolve_op_meaning = 30
            elif (in_token_lower1 == "plus"):
                rInfo.resolve_out_token = "+"
                rInfo.resolve_op_meaning = 1
            elif (in_token_lower1 == "pow"):
                rInfo.resolve_out_token = "pow"
                rInfo.resolve_op_meaning = 9
            elif (in_token_lower1 == "radian"):
                rInfo.resolve_out_token = "radians"
                rInfo.resolve_op_meaning = 52
            elif (in_token_lower1 == "radians"):
                rInfo.resolve_out_token = "radians"
                rInfo.resolve_op_meaning = 52
            elif (in_token_lower1 == "random"):
                rInfo.resolve_out_token = "random"
                rInfo.resolve_op_meaning = 31
            elif (in_token_lower1 == "round"):
                rInfo.resolve_out_token = "round"
                rInfo.resolve_op_meaning = 63
            elif (in_token_lower1 == "sin"):
                rInfo.resolve_out_token = "sin"
                rInfo.resolve_op_meaning = 53
            elif (in_token_lower1 == "sqrt"):
                rInfo.resolve_out_token = "sqrt"
                rInfo.resolve_op_meaning = 62
            elif (in_token_lower1 == "subtract"):
                rInfo.resolve_out_token = "-"
                rInfo.resolve_op_meaning = 2
            elif (in_token_lower1 == "tan"):
                rInfo.resolve_out_token = "tan"
                rInfo.resolve_op_meaning = 55
            elif (in_token_lower1 == "times"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "unconcat"):
                rInfo.resolve_out_token = "unconcat"
                rInfo.resolve_op_meaning = 29
            elif (in_token_lower1 == "unconcatenate"):
                rInfo.resolve_out_token = "unconcat"
                rInfo.resolve_op_meaning = 29
            else:
                type_found = 0
            if (2 == type_found):
                rInfo.resolve_use_out = True
                return 2
            type_found = 3
            in_token_lower2 = in_token_lower
            if (in_token_lower2 == "repeat"):
                pass
            elif (in_token_lower2 == "show"):
                pass
            elif (in_token_lower2 == "view"):
                pass
            else:
                type_found = 0
            if (3 == type_found):
                rInfo.resolve_out_token = in_token_lower
                rInfo.resolve_use_out = True
                return 3
        return type_found

class forGL_ParseStyle(Enum):
    __slots__ = ()
    _hx_class_name = "forGL.ParseStyle"
    _hx_constructs = ["PARSE_EURO", "PARSE_RIGHT_TO_LEFT"]
forGL_ParseStyle.PARSE_EURO = forGL_ParseStyle("PARSE_EURO", 0, list())
forGL_ParseStyle.PARSE_RIGHT_TO_LEFT = forGL_ParseStyle("PARSE_RIGHT_TO_LEFT", 1, list())


class forGL_NLToken:
    _hx_class_name = "forGL.NLToken"
    __slots__ = ("visible_token", "internal_token", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means")
    _hx_fields = ["visible_token", "internal_token", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means"]

    def __init__(self):
        self.token_op_means = None
        self.token_int = None
        self.token_noun_data = None
        self.token_type = None
        self.token_float = None
        self.token_str = None
        self.internal_token = None
        self.visible_token = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.visible_token = None
        _hx_o.internal_token = None
        _hx_o.token_str = None
        _hx_o.token_float = None
        _hx_o.token_type = None
        _hx_o.token_noun_data = None
        _hx_o.token_int = None
        _hx_o.token_op_means = None


class forGL_Parse:
    _hx_class_name = "forGL.Parse"
    __slots__ = ("parse_text_lines_added", "left_groups", "right_groups", "repeat_verb_found", "resolveChoice_msgs", "saveNounValues_errors", "updateNounValues_errors", "words_table_text")
    _hx_fields = ["parse_text_lines_added", "left_groups", "right_groups", "repeat_verb_found", "resolveChoice_msgs", "saveNounValues_errors", "updateNounValues_errors", "words_table_text"]
    _hx_methods = ["init", "strChunk", "parse", "resolveTokens", "resolveAssigns", "refactorForExport", "resolveChoice", "saveNounValues", "updateNounValues", "showWordsTable", "cleanUp"]

    def __init__(self):
        self.words_table_text = ""
        self.updateNounValues_errors = ""
        self.saveNounValues_errors = ""
        self.resolveChoice_msgs = ""
        self.repeat_verb_found = False
        self.right_groups = 0
        self.left_groups = 0
        self.parse_text_lines_added = 0

    def init(self):
        pass

    def strChunk(self,chunk,prev,style,verbose = False):
        if (verbose is None):
            verbose = False
        #                                                                                    ")
        #      Helper to do a possibly large amount of a definition                          ")
        #                                                                                    ")
        #  Pre Conditions                                                                    ")
        #      No Quoted strings to worry about                                              ")
        #                                                                                    ")
        #  Post Conditions                                                                   ")
        #      returned array with added strings that represent tokens to resolve later      ")
        #                                                                                    ")
        unChunks = list()
        i = 0
        code = 0
        char = ""
        while (i < len(prev)):
            unChunks.append((prev[i] if i >= 0 and i < len(prev) else None))
            i = (i + 1)
        prev_char = ""
        is_prev_num = False
        next = ""
        length = (0 if ((chunk is None)) else len(chunk))
        i = 0
        while (i < length):
            strLen = (0 if ((chunk is None)) else len(chunk))
            code = (-1 if ((((strLen == 0) or ((i < 0))) or ((i >= strLen)))) else HxString.charCodeAt(chunk,i))
            char = hx_strings_Strings.charAt8(chunk,i)
            if (32 <= code):
                if is_prev_num:
                    if (("0" <= char) and ((char <= "9"))):
                        next = (("null" if next is None else next) + ("null" if char is None else char))
                        prev_char = char
                        i = (i + 1)
                        continue
                    elif ((((((("." != char) and (("x" != char))) and (("X" != char))) and (("+" != char))) and (("-" != char))) and (("e" != char))) and (("E" != char))):
                        if ((" " == char) and (("." == prev_char))):
                            #  Remove trailing . and put in Blank and a .                                        ")
                            next = HxString.substr(next,0,(len(next) - 1))
                            next = (("null" if next is None else next) + " ")
                            next = (("null" if next is None else next) + ".")
                        is_prev_num = False
                        next = (("null" if next is None else next) + " ")
                    else:
                        next = (("null" if next is None else next) + ("null" if char is None else char))
                        prev_char = char
                        i = (i + 1)
                        continue
                elif (("0" <= char) and ((char <= "9"))):
                    is_prev_num = True
                    if (" " != prev_char):
                        next = (("null" if next is None else next) + " ")
                    next = (("null" if next is None else next) + ("null" if char is None else char))
                    prev_char = char
                    i = (i + 1)
                    continue
                insert_blanks = True
                insert_str = char
                char1 = char
                if (char1 == "!"):
                    if (i < ((length - 1))):
                        char2 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char2):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "%"):
                    pass
                elif (char1 == "&"):
                    if (i < ((length - 1))):
                        char21 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("&" == char21):
                            insert_str = (("null" if insert_str is None else insert_str) + "&")
                            i = (i + 1)
                        elif ("=" == char21):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "'"):
                    pass
                elif (char1 == "("):
                    pass
                elif (char1 == ")"):
                    pass
                elif (char1 == "*"):
                    if (i < ((length - 1))):
                        char22 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("*" == char22):
                            insert_str = (("null" if insert_str is None else insert_str) + "*")
                            i = (i + 1)
                elif (char1 == "+"):
                    if (i < ((length - 1))):
                        char23 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("+" == char23):
                            insert_str = (("null" if insert_str is None else insert_str) + "+")
                            i = (i + 1)
                elif (char1 == ","):
                    pass
                elif (char1 == "-"):
                    if (i < ((length - 1))):
                        char24 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("-" == char24):
                            insert_str = (("null" if insert_str is None else insert_str) + "-")
                            i = (i + 1)
                    elif (i < ((length - 1))):
                        char25 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ((("0" <= char25) and ((char25 <= "9"))) or (("." == char25))):
                            insert_blanks = False
                elif (char1 == "."):
                    if (i < ((length - 1))):
                        char26 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if (("0" <= char26) and ((char26 <= "9"))):
                            insert_blanks = False
                elif (char1 == "/"):
                    pass
                elif (char1 == ":"):
                    if (i < ((length - 1))):
                        char27 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char27):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == ";"):
                    pass
                elif (char1 == "<"):
                    if (i < ((length - 1))):
                        char28 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char28):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "="):
                    if (i < ((length - 1))):
                        char29 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char29):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                        elif (":" == char29):
                            insert_str = (("null" if insert_str is None else insert_str) + ":")
                            i = (i + 1)
                elif (char1 == ">"):
                    if (i < ((length - 1))):
                        char210 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char210):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "?"):
                    pass
                elif (char1 == "@"):
                    pass
                elif (char1 == "["):
                    pass
                elif (char1 == "\\"):
                    pass
                elif (char1 == "]"):
                    pass
                elif (char1 == "^"):
                    pass
                elif (char1 == "{"):
                    pass
                elif (char1 == "|"):
                    if (i < ((length - 1))):
                        char211 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("|" == char211):
                            insert_str = (("null" if insert_str is None else insert_str) + "|")
                            i = (i + 1)
                        elif ("=" == char211):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "}"):
                    pass
                else:
                    insert_blanks = False
                if insert_blanks:
                    next = (("null" if next is None else next) + HxOverrides.stringOrNull((((" " + ("null" if insert_str is None else insert_str)) + " "))))
                    prev_char = " "
                else:
                    next = (("null" if next is None else next) + ("null" if char is None else char))
                    prev_char = char
            else:
                tmp = (13 == code)
                next = (("null" if next is None else next) + " ")
                prev_char = " "
            i = (i + 1)
        io_tokens = next.split(" ")
        #                                                                                    ")
        #  NOTE: split WILL return an EMPTY STRING if 2 or more Blank spaces are together.   ")
        #  Go through and remove any EMPTY strings                                           ")
        #                                                                                    ")
        i = 0
        while (i < len(io_tokens)):
            if (0 < len((io_tokens[i] if i >= 0 and i < len(io_tokens) else None))):
                unChunks.append((io_tokens[i] if i >= 0 and i < len(io_tokens) else None))
            i = (i + 1)
        return unChunks

    def parse(self,in_lang_str,style,verbose = False):
        if (verbose is None):
            verbose = False
        #                                                                                    ")
        #  Return an array of text tokens that are in correct Natural Language reading order.  ")
        #  Also set number of text lines added for any messages shown.                       ")
        #                                                                                    ")
        ret_val = 0
        self.parse_text_lines_added = 0
        scanning_top_to_bottom = True
        scanning_left_to_right = True
        if (forGL_ParseStyle.PARSE_RIGHT_TO_LEFT == style):
            scanning_left_to_right = False
        no_empty = list()
        try:
            parse_str = in_lang_str
            length = (0 if ((parse_str is None)) else len(parse_str))
            if scanning_left_to_right:
                i = 0
                char = ""
                str_chunk = ""
                quoted_str = ""
                string_depth = 0
                while (i < length):
                    char = hx_strings_Strings.charAt8(parse_str,i)
                    if ("\"" == char):
                        if (0 == string_depth):
                            if (0 < ((0 if ((str_chunk is None)) else len(str_chunk)))):
                                no_empty = self.strChunk(str_chunk,no_empty,style,verbose)
                                str_chunk = ""
                            string_depth = (string_depth + 1)
                            quoted_str = "\""
                        else:
                            string_depth = (string_depth - 1)
                            if (0 == string_depth):
                                quoted_str = (Std.string(quoted_str) + "\"")
                                no_empty.append(quoted_str)
                                quoted_str = ""
                        i = (i + 1)
                        continue
                    if (0 != string_depth):
                        quoted_str = (Std.string(quoted_str) + ("null" if char is None else char))
                    else:
                        str_chunk = (Std.string(str_chunk) + ("null" if char is None else char))
                    i = (i + 1)
                if (0 < ((0 if ((str_chunk is None)) else len(str_chunk)))):
                    no_empty = self.strChunk(str_chunk,no_empty,style,verbose)
                    str_chunk = ""
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Parse style Right to Left not implemented. \n")
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.parse_text_lines_added
                _hx_local_7.parse_text_lines_added = (_hx_local_8 + 1)
                _hx_local_8
                ret_val = -10
                verbose = True
                return list()
            if (0 == len(no_empty)):
                forGL_ForGL_ui.error("ERROR: Nothing to parse. \n")
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.parse_text_lines_added
                _hx_local_9.parse_text_lines_added = (_hx_local_10 + 1)
                _hx_local_10
                ret_val = -3
                verbose = True
                return no_empty
            if verbose:
                forGL_ForGL_ui.msg("\nOriginal definition:\n")
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.parse_text_lines_added
                _hx_local_11.parse_text_lines_added = (_hx_local_12 + 1)
                _hx_local_12
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.parse_text_lines_added
                _hx_local_13.parse_text_lines_added = (_hx_local_14 + 1)
                _hx_local_14
                forGL_ForGL_ui.msg((Std.string(parse_str) + "\n"))
                _hx_local_15 = self
                _hx_local_16 = _hx_local_15.parse_text_lines_added
                _hx_local_15.parse_text_lines_added = (_hx_local_16 + 1)
                _hx_local_16
                forGL_ForGL_ui.msg((Std.string(len(no_empty)) + " tokens found\n"))
                _hx_local_17 = self
                _hx_local_18 = _hx_local_17.parse_text_lines_added
                _hx_local_17.parse_text_lines_added = (_hx_local_18 + 1)
                _hx_local_18
                forGL_ForGL_ui.msg((Std.string(no_empty) + "\n"))
                char_code = Sys.getChar(False)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in Parse.parse(): " + Std.string(e)) + " \n"))
        return no_empty

    def resolveTokens(self,tokens,nlDict,runStack,verbose = False):
        if (verbose is None):
            verbose = False
        #  Resolve the Meanings of the Tokens                                                ")
        lines_added = 0
        append_offset = len(runStack)
        self.left_groups = 0
        self.right_groups = 0
        self.repeat_verb_found = False
        ri = forGL_ResolveInfo()
        type_found = 0
        i = 0
        dictIdx = -1
        token = ""
        token_lower = ""
        try:
            prev_replace = ""
            no_replace = ""
            a_token = forGL_NLToken()
            runIdx = append_offset
            prev_internal_token = ""
            while (i < len(tokens)):
                runIdx = (append_offset + i)
                token = (tokens[i] if i >= 0 and i < len(tokens) else None)
                token_lower = hx_strings_Strings.toLowerCase8(token)
                dictIdx = nlDict.findWord(token)
                if (dictIdx < 0):
                    type_found = forGL_NLTypeAs.resolveType(token,ri,verbose)
                    ask_similar = True
                    if ((0 == type_found) and (("=:" == prev_internal_token))):
                        ask_similar = False
                    if ((ask_similar and ((0 == type_found))) and ((1 < len(token_lower)))):
                        similarWord = nlDict.findSimilar(token_lower)
                        if (0 < ((0 if ((similarWord is None)) else len(similarWord)))):
                            newline_needed = False
                            if ((token_lower != prev_replace) and ((token_lower != no_replace))):
                                forGL_ForGL_ui.msg((((("null" if token_lower is None else token_lower) + "  was not found. Use  ") + Std.string(similarWord)) + "  instead (y/n)? "))
                                ans_done = False
                                while (not ans_done):
                                    char_code = Sys.getChar(True)
                                    if ((13 == char_code) or ((10 == char_code))):
                                        break
                                    if ((89 == char_code) or ((121 == char_code))):
                                        prev_replace = token_lower
                                        token_lower = similarWord
                                        token = token_lower
                                        dictIdx = nlDict.findWord(token)
                                        newline_needed = True
                                        break
                                    elif ((78 == char_code) or ((110 == char_code))):
                                        no_replace = token_lower
                                        newline_needed = True
                                        break
                            elif (token_lower == prev_replace):
                                token_lower = similarWord
                                token = token_lower
                                dictIdx = nlDict.findWord(token)
                            if newline_needed:
                                forGL_ForGL_ui.msg("\n")
                                lines_added = (lines_added + 1)
                if (0 <= dictIdx):
                    type_found = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_type
                    ri.resolve_str = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str
                    ri.resolve_float = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float
                    ri.resolve_int = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int
                    ri.resolve_op_meaning = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_op_means
                    ri.resolve_token_noun_data = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data
                    ri.resolve_use_out = True
                    ri.resolve_out_token = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).internal_token
                    if (16 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 18
                    elif (17 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 19
                    elif (20 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 22
                    elif (21 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 23
                    elif (24 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 26
                    elif (25 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 27
                #  Set defaults                                                                      ")
                a_token.visible_token = token
                a_token.internal_token = token
                a_token.token_str = ""
                a_token.token_type = type_found
                a_token.token_noun_data = 0
                a_token.token_float = 0.0
                a_token.token_int = 0
                a_token.token_op_means = 0
                if (type_found == 9):
                    a_token.token_int = ri.resolve_int
                elif (type_found == 10):
                    a_token.token_int = ri.resolve_int
                elif (type_found == 2):
                    a_token.token_op_means = ri.resolve_op_meaning
                    if (((18 == a_token.token_op_means) or ((22 == a_token.token_op_means))) or ((26 == a_token.token_op_means))):
                        _hx_local_1 = self
                        _hx_local_2 = _hx_local_1.left_groups
                        _hx_local_1.left_groups = (_hx_local_2 + 1)
                        _hx_local_2
                    elif (((19 == a_token.token_op_means) or ((23 == a_token.token_op_means))) or ((27 == a_token.token_op_means))):
                        _hx_local_3 = self
                        _hx_local_4 = _hx_local_3.right_groups
                        _hx_local_3.right_groups = (_hx_local_4 + 1)
                        _hx_local_4
                elif (type_found == 6):
                    #  Set up the Noun data found                                                        ")
                    a_token.token_noun_data = ri.resolve_token_noun_data
                    if (9 == ri.resolve_token_noun_data):
                        a_token.token_int = ri.resolve_int
                    elif (10 == ri.resolve_token_noun_data):
                        a_token.token_int = ri.resolve_int
                    elif (11 == ri.resolve_token_noun_data):
                        a_token.token_float = ri.resolve_float
                    elif (8 == ri.resolve_token_noun_data):
                        a_token.token_str = ri.resolve_str
                    else:
                        forGL_ForGL_ui.msg((("INTERNAL ERROR: Strange value for  resolve_token_noun_data : " + Std.string(ri.resolve_token_noun_data)) + "\n"))
                        lines_added = (lines_added + 1)
                elif (type_found == 11):
                    a_token.token_float = ri.resolve_float
                elif (type_found == 8):
                    a_token.token_str = ri.resolve_str
                elif (type_found == 4):
                    a_token.token_str = ri.resolve_str
                if ri.resolve_use_out:
                    a_token.internal_token = ri.resolve_out_token
                if (("repeat" == a_token.internal_token) and ((3 == a_token.token_type))):
                    self.repeat_verb_found = True
                x = forGL_NLToken()
                runStack.append(x)
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token = a_token.visible_token
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_type = a_token.token_type
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).internal_token = a_token.internal_token
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_noun_data = a_token.token_noun_data
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_str = a_token.token_str
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_float = a_token.token_float
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_int = a_token.token_int
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_op_means = a_token.token_op_means
                prev_internal_token = a_token.internal_token
                i = (i + 1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in Parse.resolveTokens(): " + Std.string(e)) + " \n"))
            lines_added = (lines_added + 1)
        return lines_added

    def resolveAssigns(self,runStack):
        #                                                                                    ")
        #  Resolve (indeterminate) Assigns to be either  Assign From  or  Assign Into        ")
        #  This only changes the Assign type to  From  or  Into  with no other changes       ")
        #                                                                                    ")
        #  Look for any indeterminate Assignment.                                            ")
        #  IF found, see which side has the most terms.                                      ")
        #  IF each side has only 1 term THEN the side with a Data value must be Source       ")
        #  The side with 2 or more terms MUST be the Source side                             ")
        #  IF one side has only 1 term THEN it must be the Assign Destination                ")
        #                                                                                    ")
        #  Below are combinations Difficult to Resolve here. Interpreter will Resolve later.  ")
        #  IF both sides have only 1 term AND both are Noun or Local Noun then Interpreter will Resolve.  ")
        #  Interpreter also will Resolve UNKNOWN type to Local Noun later.                   ")
        #                                                                                    ")
        i = 0
        assignment_count = 0
        statement_start = 0
        statement_end = -1
        assign_pos = -1
        while (i < len(runStack)):
            if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                op_found = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                if (26 == op_found):
                    statement_start = (i + 1)
                    i = (i + 1)
                    continue
                if (((((45 == op_found) or ((46 == op_found))) or ((47 == op_found))) or ((48 == op_found))) or ((27 == op_found))):
                    statement_end = i
                    if (-1 == assign_pos):
                        #  No indeterminate Assignment found, so go on.                                      ")
                        statement_start = (statement_end + 1)
                        statement_end = -1
                        i = (i + 1)
                        continue
                    elif (assign_pos == statement_start):
                        #  Nothing on Left so this is Assign Into.                                           ")
                        (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                        (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                        assign_pos = -1
                        statement_start = (statement_end + 1)
                        statement_end = -1
                        i = (i + 1)
                        continue
                    #                                                                                    ")
                    #  Count number of Tokens before and after the Assign position.                      ")
                    #  IF each side has only 1 term THEN the side with a Data value must be Source       ")
                    #  OR The side with the most is the source.                                          ")
                    #                                                                                    ")
                    left_count = (assign_pos - statement_start)
                    right_count = ((statement_end - assign_pos) - 1)
                    if ((1 == left_count) and ((1 == right_count))):
                        #                                                                                    ")
                        #  IF each side has only 1 term THEN the side with a Data value must be Source       ")
                        #                                                                                    ")
                        left_type = python_internal_ArrayImpl._get(runStack, (assign_pos - 1)).token_type
                        right_type = python_internal_ArrayImpl._get(runStack, (assign_pos + 1)).token_type
                        if ((((8 == left_type) or ((9 == left_type))) or ((10 == left_type))) or ((11 == left_type))):
                            #                                                                                    ")
                            #  Left side is Source so this is Assign INTO                                        ")
                            #                                                                                    ")
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                        elif ((((8 == right_type) or ((9 == right_type))) or ((10 == right_type))) or ((11 == right_type))):
                            #                                                                                    ")
                            #  Right side is Source so this is Assign FROM                                       ")
                            #                                                                                    ")
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 34
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(34,True)
                        #  Otherwise fall through, leave alone and Interpreter will Resolve.                 ")
                    elif ((left_count != right_count) and (((1 == left_count) or ((1 == right_count))))):
                        #  The side with the most is the source.                                             ")
                        #  NEEDS TESTING !                                                                   ")
                        #                                                                                    ")
                        if (1 == left_count):
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 34
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(34,True)
                        else:
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                    #  Otherwise fall through, leave alone and Interpreter will Resolve.                 ")
                    assign_pos = -1
                    statement_start = (statement_end + 1)
                    statement_end = -1
                elif (32 == op_found):
                    assignment_count = (assignment_count + 1)
                    assign_pos = i
            i = (i + 1)
        return

    def refactorForExport(self,runStack):
        #                                                                                    ")
        #  Change to more of a style used by various programming languages                   ")
        #  This is a step towards making  Export as Code  easier to implement elsewhere.     ")
        #                                                                                    ")
        #  Change Punctuation to be a Semicolon (typical programming language statement end)  ")
        #  Rearrange any  Assignments Into  to be  Assignments From                          ")
        #  Rearrange any  Assignments       to be  Assignments From                          ")
        #                                                                                    ")
        #  * Change to Infix form for simple Math Operators  + - / * ^                       ")
        #  * Change to call( ) form for Math functions and Verbs                             ")
        #  *  =  Done later at runtime or Export time by Interpreter                         ")
        #                                                                                    ")
        retArray = list()
        i = 0
        into_assignment_count = 0
        assignment_count = 0
        changes_done = False
        #                                                                                    ")
        #  Change Punctuation to Semicolon can be done without needing a new Array           ")
        #                                                                                    ")
        while (i < len(runStack)):
            if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                op_found = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                if (((45 == op_found) or ((46 == op_found))) or ((47 == op_found))):
                    (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means = 48
                    (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(48,True)
                    (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                    changes_done = True
                if (33 == op_found):
                    into_assignment_count = (into_assignment_count + 1)
                if (32 == op_found):
                    assignment_count = (assignment_count + 1)
            i = (i + 1)
        if ((0 < into_assignment_count) or ((0 < assignment_count))):
            added_count = 0
            statement_start = 0
            statement_end = 0
            assign_pos = -1
            assign_type = 0
            #                                                                                    ")
            #  Go forward until a Semicolon or } (Statement end) is found.                       ")
            #  Find any  Assignment  or  Assign To  Operators to change                          ")
            #  It is possible that NO Assignment statement is found.                             ")
            #  A value may be added on the Data stack or                                         ")
            #  removed from the Data stack without explicit assignment.                          ")
            #                                                                                    ")
            i = 0
            while (i < len(runStack)):
                if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                    op_found1 = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                    if ((48 == op_found1) or ((27 == op_found1))):
                        insert_semicolon = False
                        if (27 == op_found1):
                            insert_semicolon = True
                        statement_end = i
                        j = statement_start
                        if (((assign_pos < 0) or ((34 == assign_type))) or ((assign_pos == statement_start))):
                            #                                                                                    ")
                            #  No Assignment OR already Assign From, just Copy the elements.                     ")
                            #                                                                                    ")
                            while (j <= statement_end):
                                x = forGL_NLToken()
                                retArray.append(x)
                                idx = (len(retArray) - 1)
                                if ((j == statement_end) and insert_semicolon):
                                    #  Insert a Semicolon                                                                ")
                                    added_count = (added_count + 1)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = 2
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = forGL_MeansWhat.opMeanAsStr(48,True)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = 0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = ""
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = 0.0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = 0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = 48
                                    x1 = forGL_NLToken()
                                    retArray.append(x1)
                                    idx = (len(retArray) - 1)
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            statement_start = (statement_end + 1)
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                        else:
                            #                                                                                    ")
                            #  Copy the Right side in original to be the Left side in the new                    ")
                            #                                                                                    ")
                            j = (assign_pos + 1)
                            while (j < statement_end):
                                x2 = forGL_NLToken()
                                retArray.append(x2)
                                idx1 = (len(retArray) - 1)
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            #                                                                                    ")
                            #  Now do the  Assign From  Operator                                                 ")
                            #                                                                                    ")
                            x3 = forGL_NLToken()
                            retArray.append(x3)
                            idx2 = (len(retArray) - 1)
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(34,True)
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_type = 2
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).internal_token = (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).visible_token
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_noun_data = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_str = ""
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_float = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_int = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_op_means = 34
                            #                                                                                    ")
                            #  Copy the Left side in original to be the Right side in the new                    ")
                            #                                                                                    ")
                            j = statement_start
                            while (j < assign_pos):
                                x4 = forGL_NLToken()
                                retArray.append(x4)
                                idx3 = (len(retArray) - 1)
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            #                                                                                    ")
                            #  Add the ending Semicolon                                                          ")
                            #                                                                                    ")
                            x5 = forGL_NLToken()
                            retArray.append(x5)
                            idx4 = (len(retArray) - 1)
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_type = 2
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).internal_token = (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_noun_data = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_str = ""
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_float = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_int = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_op_means = 48
                            if insert_semicolon:
                                #                                                                                    ")
                                #  Now do the  Block End  character                                                  ")
                                #                                                                                    ")
                                added_count = (added_count + 1)
                                x6 = forGL_NLToken()
                                retArray.append(x6)
                                idx4 = (len(retArray) - 1)
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(27,True)
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_type = 2
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).internal_token = (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_noun_data = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_str = ""
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_float = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_int = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_op_means = 27
                            statement_start = (statement_end + 1)
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                    elif (((32 == op_found1) or ((33 == op_found1))) or ((34 == op_found1))):
                        #                                                                                    ")
                        #  Skip over if  Assign Into  is at beginning. Implies Data stack use.               ")
                        #                                                                                    ")
                        if ((33 == op_found1) and ((i == statement_start))):
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                        assign_pos = i
                        assign_type = op_found1
                    elif (("{" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) or (("}" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))):
                        x7 = forGL_NLToken()
                        retArray.append(x7)
                        idx5 = (len(retArray) - 1)
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).visible_token = (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_type = (runStack[i] if i >= 0 and i < len(runStack) else None).token_type
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).internal_token = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_noun_data = (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_str = (runStack[i] if i >= 0 and i < len(runStack) else None).token_str
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_float = (runStack[i] if i >= 0 and i < len(runStack) else None).token_float
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_int = (runStack[i] if i >= 0 and i < len(runStack) else None).token_int
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_op_means = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                        statement_start = (i + 1)
                elif (12 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                    if (((("for" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) or (("if" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))) or (("switch" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))) or (("while" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))):
                        #                                                                                    ")
                        #  Skip the Choice and the following ( expression )                                  ")
                        #                                                                                    ")
                        j1 = i
                        while (j1 < len(runStack)):
                            x8 = forGL_NLToken()
                            retArray.append(x8)
                            idx6 = (len(retArray) - 1)
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).visible_token = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).visible_token
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_type = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_type
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).internal_token = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).internal_token
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_noun_data = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_noun_data
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_str = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_str
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_float = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_float
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_int = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_int
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_op_means = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_op_means
                            if (")" == (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).internal_token):
                                statement_start = (j1 + 1)
                                break
                            j1 = (j1 + 1)
                        i = (j1 + 1)
                        continue
                i = (i + 1)
            if ((len(retArray) - added_count) < len(runStack)):
                #                                                                                    ")
                #  Copy the last few not already done                                                ")
                #                                                                                    ")
                j2 = statement_start
                while (j2 < len(runStack)):
                    x9 = forGL_NLToken()
                    retArray.append(x9)
                    idx7 = (len(retArray) - 1)
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).visible_token = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).visible_token
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_type = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_type
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).internal_token = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).internal_token
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_noun_data = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_noun_data
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_str = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_str
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_float = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_float
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_int = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_int
                    (retArray[idx7] if idx7 >= 0 and idx7 < len(retArray) else None).token_op_means = (runStack[j2] if j2 >= 0 and j2 < len(runStack) else None).token_op_means
                    j2 = (j2 + 1)
            if ((forGL_MeansWhat.opMeanAsStr(27,True) != python_internal_ArrayImpl._get(retArray, (len(retArray) - 1)).internal_token) and ((forGL_MeansWhat.opMeanAsStr(48,True) != python_internal_ArrayImpl._get(retArray, (len(retArray) - 1)).internal_token))):
                #  Last is a Semicolon if NOT a  Block End  character                                ")
                x10 = forGL_NLToken()
                retArray.append(x10)
                idx8 = (len(retArray) - 1)
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_type = 2
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).internal_token = (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).visible_token
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_noun_data = 0
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_str = ""
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_float = 0
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_int = 0
                (retArray[idx8] if idx8 >= 0 and idx8 < len(retArray) else None).token_op_means = 48
        else:
            retArray = runStack
        return retArray

    def resolveChoice(self,rStack):
        #  Resolve settings needed internally by Choice (control flow) tokens                ")
        ret_val = 0
        self.resolveChoice_msgs = ""
        is_balanced = False
        choice_found = ""
        end_paren_idx = -1
        end_block_idx = -1
        else_found = False
        else_start = -1
        else_end = -1
        i = 0
        while (i < len(rStack)):
            choice_found = ""
            else_found = False
            if ((((("for" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token) or (("if" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("switch" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("while" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("return" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))):
                choice_found = (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token
                if ("return" == choice_found):
                    i = (i + 1)
                    continue
            else:
                i = (i + 1)
                continue
            if (not is_balanced):
                if ((self.left_groups != self.right_groups) or ((0 == self.left_groups))):
                    return -4
                is_balanced = True
            if ((len(rStack) - 4) < i):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.resolveChoice_msgs
                _hx_local_2.resolveChoice_msgs = (("null" if _hx_local_3 is None else _hx_local_3) + HxOverrides.stringOrNull(((("SYNTAX ERROR: " + ("null" if choice_found is None else choice_found)) + " missing ( expression ) or statement.\n"))))
                _hx_local_2.resolveChoice_msgs
                return -4
            if ("(" != python_internal_ArrayImpl._get(rStack, (i + 1)).internal_token):
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.resolveChoice_msgs
                _hx_local_4.resolveChoice_msgs = (("null" if _hx_local_5 is None else _hx_local_5) + HxOverrides.stringOrNull(((("SYNTAX ERROR: " + ("null" if choice_found is None else choice_found)) + " ( expression ) not next.\n"))))
                _hx_local_4.resolveChoice_msgs
                return -4
            left_parens = 0
            right_parens = 0
            p = (i + 2)
            while (p < len(rStack)):
                if (")" == (rStack[p] if p >= 0 and p < len(rStack) else None).internal_token):
                    if (left_parens == right_parens):
                        break
                    right_parens = (right_parens + 1)
                elif ("(" == (rStack[p] if p >= 0 and p < len(rStack) else None).internal_token):
                    left_parens = (left_parens + 1)
                p = (p + 1)
            if ((len(rStack) - 2) < p):
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.resolveChoice_msgs
                _hx_local_9.resolveChoice_msgs = (("null" if _hx_local_10 is None else _hx_local_10) + HxOverrides.stringOrNull(((("SYNTAX ERROR: No statement after " + ("null" if choice_found is None else choice_found)) + " expression.\n"))))
                _hx_local_9.resolveChoice_msgs
                return -4
            end_paren_idx = p
            b = (p + 1)
            e = -1
            if ("{" != (rStack[b] if b >= 0 and b < len(rStack) else None).internal_token):
                if ("switch" == choice_found):
                    _hx_local_11 = self
                    _hx_local_12 = _hx_local_11.resolveChoice_msgs
                    _hx_local_11.resolveChoice_msgs = (("null" if _hx_local_12 is None else _hx_local_12) + "SYNTAX ERROR: Single statement not allowed for switch.\n")
                    _hx_local_11.resolveChoice_msgs
                    return -4
                while (b < len(rStack)):
                    if (2 == (rStack[b] if b >= 0 and b < len(rStack) else None).token_type):
                        op_to_do = (rStack[b] if b >= 0 and b < len(rStack) else None).token_op_means
                        if ((((45 == op_to_do) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                            break
                    b = (b + 1)
            else:
                while (b < len(rStack)):
                    if ("}" == (rStack[b] if b >= 0 and b < len(rStack) else None).internal_token):
                        break
                    b = (b + 1)
                if ((("if" == choice_found) and ((b < ((len(rStack) - 3))))) and (("else" == python_internal_ArrayImpl._get(rStack, (b + 1)).internal_token))):
                    if ("{" == python_internal_ArrayImpl._get(rStack, (b + 2)).internal_token):
                        else_start = (b + 2)
                        else_end = (b + 3)
                        while (else_end < len(rStack)):
                            if ("}" == (rStack[else_end] if else_end >= 0 and else_end < len(rStack) else None).internal_token):
                                else_found = True
                                break
                            else_end = (else_end + 1)
            if (len(rStack) <= b):
                b = (len(rStack) - 1)
            end_block_idx = b
            (rStack[i] if i >= 0 and i < len(rStack) else None).token_int = end_paren_idx
            (rStack[i] if i >= 0 and i < len(rStack) else None).token_float = end_block_idx
            if (("if" == choice_found) and else_found):
                (rStack[end_block_idx] if end_block_idx >= 0 and end_block_idx < len(rStack) else None).token_float = ((else_end - end_block_idx) + 1)
            (rStack[end_paren_idx] if end_paren_idx >= 0 and end_paren_idx < len(rStack) else None).token_int = (i + 1)
            if (("for" == choice_found) or (("while" == choice_found))):
                (rStack[end_block_idx] if end_block_idx >= 0 and end_block_idx < len(rStack) else None).token_int = (i + 1)
            i = (end_paren_idx + 1)
        return ret_val

    def saveNounValues(self,nlDict,runStack,nouns):
        #  Save to Dictionary any Noun values that are Not from Local Nouns                  ")
        num_saved = 0
        self.saveNounValues_errors = ""
        i = 0
        while (i < len(nouns)):
            runIdx = (nouns[i] if i >= 0 and i < len(nouns) else None)
            if (6 != (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_type):
                i = (i + 1)
                continue
            dictIdx = nlDict.findWord((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)
            if (0 <= dictIdx):
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_noun_data
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_str
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_float
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_int
                num_saved = (num_saved + 1)
            else:
                err_msg = (("ERROR not Saving: Noun " + Std.string((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)) + " not in dictionary.\n")
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.saveNounValues_errors
                _hx_local_2.saveNounValues_errors = (Std.string(_hx_local_3) + ("null" if err_msg is None else err_msg))
                _hx_local_2.saveNounValues_errors
            i = (i + 1)
        return num_saved

    def updateNounValues(self,nlDict,runStack,nouns,lastOnly = False):
        if (lastOnly is None):
            lastOnly = False
        #  Update from Dictionary any Noun values (Not for Local Nouns)                      ")
        num_updated = 0
        self.updateNounValues_errors = ""
        i = 0
        if lastOnly:
            i = (len(nouns) - 1)
        while (i < len(nouns)):
            runIdx = (nouns[i] if i >= 0 and i < len(nouns) else None)
            if (6 != (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_type):
                i = (i + 1)
                continue
            dictIdx = nlDict.findWord((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)
            if (0 <= dictIdx):
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_noun_data = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_str = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_float = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_int = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int
                num_updated = (num_updated + 1)
            else:
                err_msg = (("ERROR not Updating: Noun " + Std.string((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)) + " not in dictionary.\n")
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.updateNounValues_errors
                _hx_local_2.updateNounValues_errors = (Std.string(_hx_local_3) + ("null" if err_msg is None else err_msg))
                _hx_local_2.updateNounValues_errors
            i = (i + 1)
        return num_updated

    def showWordsTable(self,runStack,show_words = True,show_index = False,text_str = False):
        if (show_words is None):
            show_words = True
        if (show_index is None):
            show_index = False
        if (text_str is None):
            text_str = False
        #                                                                                    ")
        #  Show a Table of resolved Words and/or save to a Text buffer                       ")
        #                                                                                    ")
        self.words_table_text = ""
        lines_added = 0
        msg_text = ""
        if (0 < len(runStack)):
            _hx_len = len(runStack)
            msg_text = (("\n\t\t\t" + Std.string(_hx_len)) + "  Words")
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                self.words_table_text = msg_text
            if show_words:
                lines_added = (lines_added + 2)
            if show_index:
                msg_text = (("  [ 0 to " + Std.string((_hx_len - 1))) + " ]\n")
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_1 = self
                    _hx_local_2 = _hx_local_1.words_table_text
                    _hx_local_1.words_table_text = (("null" if _hx_local_2 is None else _hx_local_2) + ("null" if msg_text is None else msg_text))
                    _hx_local_1.words_table_text
                msg_text = "Index                 Internal           Word     Verb  or  Noun  Details ...\n"
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.words_table_text
                    _hx_local_3.words_table_text = (("null" if _hx_local_4 is None else _hx_local_4) + ("null" if msg_text is None else msg_text))
                    _hx_local_3.words_table_text
                if show_words:
                    lines_added = (lines_added + 1)
                msg_text = "        Name            Name             Type     string, float, integer or bool"
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_6 = self
                    _hx_local_7 = _hx_local_6.words_table_text
                    _hx_local_6.words_table_text = (("null" if _hx_local_7 is None else _hx_local_7) + ("null" if msg_text is None else msg_text))
                    _hx_local_6.words_table_text
            else:
                msg_text = "\n              Internal           Word     Verb  or  Noun  Details ...\n"
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.words_table_text
                    _hx_local_8.words_table_text = (("null" if _hx_local_9 is None else _hx_local_9) + ("null" if msg_text is None else msg_text))
                    _hx_local_8.words_table_text
                if show_words:
                    lines_added = (lines_added + 1)
                msg_text = "Name            Name             Type     string, float, integer or bool\n"
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_11 = self
                    _hx_local_12 = _hx_local_11.words_table_text
                    _hx_local_11.words_table_text = (("null" if _hx_local_12 is None else _hx_local_12) + ("null" if msg_text is None else msg_text))
                    _hx_local_11.words_table_text
            if show_words:
                lines_added = (lines_added + 1)
            msg_text = "--------------------------------------------------------------------------------"
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.words_table_text
                _hx_local_14.words_table_text = (("null" if _hx_local_15 is None else _hx_local_15) + HxOverrides.stringOrNull(((("null" if msg_text is None else msg_text) + "\n"))))
                _hx_local_14.words_table_text
            if show_words:
                lines_added = (lines_added + 1)
            i = 0
            while (i < _hx_len):
                if show_index:
                    msg_text = (("[" + Std.string(i)) + "]\t")
                    if show_words:
                        forGL_ForGL_ui.msg(msg_text)
                    if text_str:
                        _hx_local_17 = self
                        _hx_local_18 = _hx_local_17.words_table_text
                        _hx_local_17.words_table_text = (("null" if _hx_local_18 is None else _hx_local_18) + ("null" if msg_text is None else msg_text))
                        _hx_local_17.words_table_text
                used_inference = False
                _hx_type = (runStack[i] if i >= 0 and i < len(runStack) else None).token_type
                if (0 == _hx_type):
                    used_inference = True
                    _hx_type = 7
                color = forGL_ForGL_ui.getTypeColor(_hx_type)
                msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).visible_token) + "\t\t")
                _hx_str = (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token
                if (((0 if ((_hx_str is None)) else len(_hx_str))) >= 8):
                    msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).visible_token) + "\t")
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_19 = self
                    _hx_local_20 = _hx_local_19.words_table_text
                    _hx_local_19.words_table_text = (("null" if _hx_local_20 is None else _hx_local_20) + ("null" if msg_text is None else msg_text))
                    _hx_local_19.words_table_text
                #                                                                                    ")
                #    Internal Name is what Run time logic depends on                                 ")
                #                                                                                    ")
                msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) + "\t\t")
                str1 = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                if (((0 if ((str1 is None)) else len(str1))) >= 8):
                    msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) + "\t")
                if show_words:
                    forGL_ForGL_ui.msg(msg_text,color)
                if text_str:
                    _hx_local_21 = self
                    _hx_local_22 = _hx_local_21.words_table_text
                    _hx_local_21.words_table_text = (("null" if _hx_local_22 is None else _hx_local_22) + ("null" if msg_text is None else msg_text))
                    _hx_local_21.words_table_text
                if (2 == _hx_type):
                    msg_text = forGL_MeansWhat.opMeanAsStr((runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means)
                    if show_words:
                        forGL_ForGL_ui.msg(msg_text,color)
                    if text_str:
                        _hx_local_23 = self
                        _hx_local_24 = _hx_local_23.words_table_text
                        _hx_local_23.words_table_text = (("null" if _hx_local_24 is None else _hx_local_24) + ("null" if msg_text is None else msg_text))
                        _hx_local_23.words_table_text
                else:
                    msg_text = (HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(_hx_type)) + "\t")
                    if show_words:
                        forGL_ForGL_ui.msg(msg_text,color)
                    if text_str:
                        _hx_local_25 = self
                        _hx_local_26 = _hx_local_25.words_table_text
                        _hx_local_25.words_table_text = (("null" if _hx_local_26 is None else _hx_local_26) + ("null" if msg_text is None else msg_text))
                        _hx_local_25.words_table_text
                if (4 == _hx_type):
                    msg_text = ((" " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_str)) + "\n")
                    if show_words:
                        forGL_ForGL_ui.msg(msg_text)
                    if text_str:
                        _hx_local_27 = self
                        _hx_local_28 = _hx_local_27.words_table_text
                        _hx_local_27.words_table_text = (("null" if _hx_local_28 is None else _hx_local_28) + ("null" if msg_text is None else msg_text))
                        _hx_local_27.words_table_text
                    if show_words:
                        lines_added = (lines_added + 1)
                elif ((6 == _hx_type) or ((7 == _hx_type))):
                    if (8 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data):
                        msg_text = (("\t s: " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_str)) + "\n")
                        if show_words:
                            forGL_ForGL_ui.msg(msg_text)
                        if text_str:
                            _hx_local_30 = self
                            _hx_local_31 = _hx_local_30.words_table_text
                            _hx_local_30.words_table_text = (("null" if _hx_local_31 is None else _hx_local_31) + ("null" if msg_text is None else msg_text))
                            _hx_local_30.words_table_text
                        if show_words:
                            lines_added = (lines_added + 1)
                    elif (11 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data):
                        msg_text = (("\t " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_float)) + "\n")
                        if show_words:
                            forGL_ForGL_ui.msg(msg_text)
                        if text_str:
                            _hx_local_33 = self
                            _hx_local_34 = _hx_local_33.words_table_text
                            _hx_local_33.words_table_text = (("null" if _hx_local_34 is None else _hx_local_34) + ("null" if msg_text is None else msg_text))
                            _hx_local_33.words_table_text
                        if show_words:
                            lines_added = (lines_added + 1)
                    else:
                        if (10 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data):
                            if (1 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_int):
                                msg_text = "\t true\n"
                            else:
                                msg_text = "\t false\n"
                            if show_words:
                                forGL_ForGL_ui.msg(msg_text)
                            if text_str:
                                _hx_local_36 = self
                                _hx_local_37 = _hx_local_36.words_table_text
                                _hx_local_36.words_table_text = (("null" if _hx_local_37 is None else _hx_local_37) + ("null" if msg_text is None else msg_text))
                                _hx_local_36.words_table_text
                        elif (9 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data):
                            msg_text = (("\t " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_int)) + "\n")
                            if show_words:
                                forGL_ForGL_ui.msg(msg_text)
                            if text_str:
                                _hx_local_38 = self
                                _hx_local_39 = _hx_local_38.words_table_text
                                _hx_local_38.words_table_text = (("null" if _hx_local_39 is None else _hx_local_39) + ("null" if msg_text is None else msg_text))
                                _hx_local_38.words_table_text
                        elif used_inference:
                            if show_words:
                                forGL_ForGL_ui.msg("\n")
                            if text_str:
                                _hx_local_40 = self
                                _hx_local_41 = _hx_local_40.words_table_text
                                _hx_local_40.words_table_text = (("null" if _hx_local_41 is None else _hx_local_41) + "\n")
                                _hx_local_40.words_table_text
                        else:
                            def _hx_local_0():
                                _hx_local_42 = (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data
                                if (Std._hx_is(_hx_local_42,Int) or ((_hx_local_42 is None))):
                                    _hx_local_42
                                else:
                                    raise _HxException("Class cast error")
                                return _hx_local_42
                            forGL_ForGL_ui.error(("INTERNAL ERROR: wrong token_noun_data value " + Std.string(_hx_local_0())),1)
                        if show_words:
                            lines_added = (lines_added + 1)
                else:
                    if show_words:
                        forGL_ForGL_ui.msg("\n")
                    if text_str:
                        _hx_local_44 = self
                        _hx_local_45 = _hx_local_44.words_table_text
                        _hx_local_44.words_table_text = (("null" if _hx_local_45 is None else _hx_local_45) + "\n")
                        _hx_local_44.words_table_text
                    if show_words:
                        lines_added = (lines_added + 1)
                i = (i + 1)
        return lines_added

    def cleanUp(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.parse_text_lines_added = None
        _hx_o.left_groups = None
        _hx_o.right_groups = None
        _hx_o.repeat_verb_found = None
        _hx_o.resolveChoice_msgs = None
        _hx_o.saveNounValues_errors = None
        _hx_o.updateNounValues_errors = None
        _hx_o.words_table_text = None


class forGL_DataItem:
    _hx_class_name = "forGL.DataItem"
    __slots__ = ("data_str", "data_float", "data_type", "data_int")
    _hx_fields = ["data_str", "data_float", "data_type", "data_int"]

    def __init__(self,_hx_type,_hx_str,_hx_float,_hx_int):
        self.data_type = _hx_type
        self.data_str = _hx_str
        self.data_float = _hx_float
        self.data_int = _hx_int

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data_str = None
        _hx_o.data_float = None
        _hx_o.data_type = None
        _hx_o.data_int = None


class forGL_ForGL_Run:
    _hx_class_name = "forGL.ForGL_Run"
    __slots__ = ("run_text_line", "export_as_code", "export_as_code_log", "export_as_code_verb_name", "display_internal", "show_details", "show_words_table", "show_stacks", "show_stacks_Data_Only", "single_step", "delay_seconds_default", "delay_seconds", "stdin", "run_verbose", "ForGLData", "nlDict", "nl_Import_used", "nl_Import", "nl_Parse", "in_dictionary_file_name", "use_Built_In_Dictionary", "out_dictionary_file_name", "dataOpNoun_text_line", "steps_done", "steps_done_Verb", "intp_ip", "old_dataStackFrames", "old_dataStack", "old_opStackFrames", "old_opStack", "old_nounStackFrames", "old_nounStack", "old_assignStackFrames", "old_assignStack", "elapsed_intp_time", "user_def", "prev_dataStackOut", "prev_opStackOut", "prev_nounStackOut", "view_DON_throttle", "last_view_DON_time", "prev_show1_data", "start_session_time", "total_intp_time", "verb_to_run", "runStack", "dataStack", "opStack", "nouns", "assignStack", "repeat_found", "repeat_count", "repeat_limit", "repeat_limit_found", "show_text_line", "start_intp_time", "intp_return_result")
    _hx_fields = ["run_text_line", "export_as_code", "export_as_code_log", "export_as_code_verb_name", "display_internal", "show_details", "show_words_table", "show_stacks", "show_stacks_Data_Only", "single_step", "delay_seconds_default", "delay_seconds", "stdin", "run_verbose", "ForGLData", "nlDict", "nl_Import_used", "nl_Import", "nl_Parse", "in_dictionary_file_name", "use_Built_In_Dictionary", "out_dictionary_file_name", "dataOpNoun_text_line", "steps_done", "steps_done_Verb", "intp_ip", "old_dataStackFrames", "old_dataStack", "old_opStackFrames", "old_opStack", "old_nounStackFrames", "old_nounStack", "old_assignStackFrames", "old_assignStack", "elapsed_intp_time", "user_def", "prev_dataStackOut", "prev_opStackOut", "prev_nounStackOut", "view_DON_throttle", "last_view_DON_time", "prev_show1_data", "start_session_time", "total_intp_time", "verb_to_run", "runStack", "dataStack", "opStack", "nouns", "assignStack", "repeat_found", "repeat_count", "repeat_limit", "repeat_limit_found", "show_text_line", "start_intp_time", "intp_return_result"]
    _hx_methods = ["init", "cleanUp", "dataStackToString", "opStackToString", "nounStackToString", "dataStackOut", "viewDataOpNouns", "show1Data", "viewRepeatCount", "runAssignment", "addQuotes", "trimQuotes", "runMath1Data", "runStr2Data", "runMath2Data", "runOperators", "run", "runDef", "runDef_End", "runInterpreter"]

    def __init__(self):
        self.assignStack = None
        self.nouns = None
        self.opStack = None
        self.dataStack = None
        self.runStack = None
        self.nl_Parse = None
        self.nl_Import = None
        self.nlDict = None
        self.ForGLData = None
        self.intp_return_result = 0
        self.start_intp_time = 0.0
        self.show_text_line = 0
        self.repeat_limit_found = False
        self.repeat_limit = -1
        self.repeat_count = 0
        self.repeat_found = False
        self.verb_to_run = "15 test_factorial"
        self.total_intp_time = 0.0
        self.start_session_time = 0.0
        self.prev_show1_data = ""
        self.last_view_DON_time = 0.0
        self.view_DON_throttle = False
        self.prev_nounStackOut = ""
        self.prev_opStackOut = ""
        self.prev_dataStackOut = ""
        self.user_def = ""
        self.elapsed_intp_time = 0.0
        self.old_assignStack = list()
        self.old_assignStackFrames = list()
        self.old_nounStack = list()
        self.old_nounStackFrames = list()
        self.old_opStack = list()
        self.old_opStackFrames = list()
        self.old_dataStack = list()
        self.old_dataStackFrames = list()
        self.intp_ip = 0
        self.steps_done_Verb = 0
        self.steps_done = 0
        self.dataOpNoun_text_line = 0
        self.out_dictionary_file_name = ""
        self.use_Built_In_Dictionary = False
        self.in_dictionary_file_name = ""
        self.nl_Import_used = False
        self.run_verbose = False
        self.stdin = Sys.stdin()
        self.delay_seconds = 1.0
        self.delay_seconds_default = 1.0
        self.single_step = True
        self.show_stacks_Data_Only = False
        self.show_stacks = True
        self.show_words_table = True
        self.show_details = False
        self.display_internal = False
        self.export_as_code_verb_name = ""
        self.export_as_code_log = list()
        self.export_as_code = False
        self.run_text_line = 0
        #  ////////////////////////////////////////////////////////////////////////////////  ")
        #                                                                                    ")
        #  This is the top level class controlling overall Runtime behavior.                 ")
        #                                                                                    ")
        #        See block comment at end of runInterpreter( ) for more information.         ")
        #                                                                                    ")
        #        Key Ideas ...                                                               ")
        #                                                                                    ")
        #    Minimum Dependencies:                                                           ")
        #        Source of forGL definitions to work with                                    ")
        #        Internal format as Source: forGL definitions may have been bound within application  ")
        #            Use Case: User/Programmer has already finished Editing wanted.          ")
        #                So an Internal format is all that is needed to run.                 ")
        #        Internal format may not include original source definitions.                ")
        #                                                                                    ")
        #        External format: forGL definitions arrived from:                            ")
        #            Temporary network connection                                            ")
        #            Temporary file system connection                                        ")
        #            IPC from another process running on same HW/OS platform (future?)       ")
        #                                                                                    ")
        #        See below for more rationale                                                ")
        #                                                                                    ")
        #    Other Dependencies:                                                             ")
        #        (optional) UI is available for display.                                     ")
        #            Use Case: Runtime may be in headless Server mode                        ")
        #                so not needing UI.                                                  ")
        #                                                                                    ")
        #        (optional) Data Store is available to Read/Write persistent data.           ")
        #            Use Case: Runtime may be in Super Calculator mode                       ")
        #                so not needing Data Store.                                          ")
        #                                                                                    ")
        #    Pre Conditions:                                                                 ")
        #        Minimum Dependancies are true                                               ")
        #        Optional Other Dependancies may be true as well                             ")
        #                                                                                    ")
        #    Invariants:                                                                     ")
        #                                                                                    ")
        #    Post Conditions:                                                                ")
        #                                                                                    ")

    def init(self,in_dict_name,lines_added,verbose = False):
        if (verbose is None):
            verbose = False
        #                                                                                    ")
        #  Allow high level code to initialize the Runtime setup                             ")
        #                                                                                    ")
        ret_val = 0
        try:
            lines_added = 0
            self.run_verbose = verbose
            self.ForGLData = forGL_data_ForGL_data()
            self.in_dictionary_file_name = in_dict_name
            if (0 < len(self.in_dictionary_file_name)):
                init_result = self.ForGLData.init(self.in_dictionary_file_name,1)
                self.in_dictionary_file_name = self.ForGLData.actual_path_file
                def _hx_local_0():
                    _hx_local_0 = init_result
                    if (Std._hx_is(_hx_local_0,Int) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_0
                if (_hx_local_0() < 0):
                    forGL_ForGL_ui.error((("\n    SEVERE ERROR  " + Std.string(forGL_MeansWhat.returnMeanAsStr(init_result))) + " trying to Initialize the Data service.  Stopping."))
                    lines_added = (lines_added + 1)
                    ret_val = init_result
                    self.in_dictionary_file_name = ""
                    return ret_val
            self.nlDict = forGL_NLDictionary()
            dict_result = self.nlDict.init(self.in_dictionary_file_name)
            self.use_Built_In_Dictionary = self.nlDict.use_Built_In_Dictionary
            def _hx_local_0():
                _hx_local_2 = dict_result
                if (Std._hx_is(_hx_local_2,Int) or ((_hx_local_2 is None))):
                    _hx_local_2
                else:
                    raise _HxException("Class cast error")
                return _hx_local_2
            if (0 != _hx_local_0()):
                ret_val = dict_result
            else:
                lines_added = (lines_added + 1)
                lines_added = (lines_added + 1)
                lines_added = (lines_added + 1)
                if (0 < len(self.in_dictionary_file_name)):
                    self.nl_Import = forGL_NLImport()
                    import_result = self.nl_Import.importWords(self.ForGLData,self.nlDict,self.in_dictionary_file_name)
                    this1 = self.nl_Import.importWords_msgs
                    if (0 < ((0 if ((this1 is None)) else len(this1)))):
                        if verbose:
                            forGL_ForGL_ui.status(self.nl_Import.importWords_msgs)
                        lines_added = (lines_added + 1)
                        lines_added = (lines_added + 1)
                        lines_added = (lines_added + 1)
                    ret_val = import_result
                else:
                    forGL_ForGL_ui.status("No Dictionary name given so no Import of word(s).",3,False,True)
            def _hx_local_0():
                _hx_local_9 = ret_val
                if (Std._hx_is(_hx_local_9,Int) or ((_hx_local_9 is None))):
                    _hx_local_9
                else:
                    raise _HxException("Class cast error")
                return _hx_local_9
            if (0 == _hx_local_0()):
                self.nl_Parse = forGL_Parse()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in forGL_run.init(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def cleanUp(self):
        self.ForGLData.cleanUp()
        self.nlDict.cleanUp()
        if self.nl_Import_used:
            self.nl_Import.cleanUp()
            self.nl_Import_used = False

    def dataStackToString(self,dStack):
        #  Helper to support showing Data stack values                                       ")
        if ((0 == len(dStack)) and ((0 == len(self.old_dataStack)))):
            return "[]"
        result = "["
        i = 0
        if (0 < len(self.old_dataStack)):
            while (i < len(self.old_dataStack)):
                result = (Std.string(result) + " ")
                if (9 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = (Std.string(result) + Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_int))
                elif (10 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    if (1 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_int):
                        result = (Std.string(result) + "true")
                    else:
                        result = (Std.string(result) + "false")
                elif (11 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = (Std.string(result) + Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_float))
                elif (8 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_str))
                else:
                    forGL_ForGL_ui.error("INTERNAL ERROR: Some other data type in the Data stack. \n")
                    result = (Std.string(result) + "'?'")
                result = (Std.string(result) + " ")
                i = (i + 1)
            result = (Std.string(result) + ":")
            i = 0
        while (i < len(dStack)):
            result = (Std.string(result) + " ")
            if (9 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = (Std.string(result) + Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_int))
            elif (10 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                if (1 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_int):
                    result = (Std.string(result) + "true")
                else:
                    result = (Std.string(result) + "false")
            elif (11 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = (Std.string(result) + Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_float))
            elif (8 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_str))
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Some other data type in the Data stack. \n")
                result = (Std.string(result) + "'?'")
            result = (Std.string(result) + " ")
            i = (i + 1)
        result = (Std.string(result) + "]")
        return result

    def opStackToString(self,rStack,oStack):
        #  Helper to support showing Operator stack values                                   ")
        if ((0 == len(oStack)) and ((0 == len(self.old_opStack)))):
            return "[]"
        result = "["
        i = 0
        result = "["
        if (0 < len(self.old_opStack)):
            while (i < len(self.old_opStack)):
                result = (Std.string(result) + " ")
                rIdx = (self.old_opStack[i] if i >= 0 and i < len(self.old_opStack) else None)
                if self.display_internal:
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).internal_token))
                else:
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).visible_token))
                result = (Std.string(result) + " ")
                i = (i + 1)
            result = (Std.string(result) + ":")
            i = 0
        while (i < len(oStack)):
            result = (Std.string(result) + " ")
            rIdx1 = (oStack[i] if i >= 0 and i < len(oStack) else None)
            if self.display_internal:
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx1] if rIdx1 >= 0 and rIdx1 < len(rStack) else None).internal_token))
            else:
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx1] if rIdx1 >= 0 and rIdx1 < len(rStack) else None).visible_token))
            result = (Std.string(result) + " ")
            i = (i + 1)
        result = (Std.string(result) + "]")
        return result

    def nounStackToString(self,rStack,nStack):
        #  Helper to support showing Noun stack values                                       ")
        if (0 == len(nStack)):
            return "[]"
        result = "["
        i = 0
        while (i < len(nStack)):
            rIdx = (nStack[i] if i >= 0 and i < len(nStack) else None)
            if self.display_internal:
                result = (("null" if result is None else result) + HxOverrides.stringOrNull((((" (" + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).internal_token)) + ")"))))
            else:
                result = (("null" if result is None else result) + HxOverrides.stringOrNull((((" (" + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).visible_token)) + ")"))))
            if (9 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_int))
            elif (10 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                if (1 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_int):
                    result = (("null" if result is None else result) + "true")
                else:
                    result = (("null" if result is None else result) + "false")
            elif (11 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_float))
            elif (8 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_str))
            result = (("null" if result is None else result) + " ")
            i = (i + 1)
        result = (("null" if result is None else result) + "]")
        return result

    def dataStackOut(self,dStack):
        #  Helper to support showing Data stack if changed from before                       ")
        lines_added = 0
        out = self.dataStackToString(dStack)
        if (out != self.prev_dataStackOut):
            forGL_ForGL_ui.setOut(2)
            forGL_ForGL_ui.msg((("Data = " + Std.string(out)) + "\n"))
            forGL_ForGL_ui.setOut()
            self.prev_dataStackOut = out
            lines_added = (lines_added + 1)
        return lines_added

    def viewDataOpNouns(self,rStack,dStack,oStack,nStack,textLine = -1,first_time = False):
        if (textLine is None):
            textLine = -1
        if (first_time is None):
            first_time = False
        #                                                                                    ")
        #  Helper to support showing Data, Operator and Noun stack values                    ")
        #                                                                                    ")
        if ((not first_time) and self.view_DON_throttle):
            #  Display changed Data and other values ONLY a few times a second                   ")
            time = (python_lib_Time.mktime(Date.now().date.timetuple()) * 1000)
            if ((time - self.last_view_DON_time) < 0.2):
                return
            self.last_view_DON_time = time
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            if (not first_time):
                forGL_ForGL_ui.goToPos(textLine,7)
            else:
                forGL_ForGL_ui.goToPos(textLine,0)
        _hx_str = self.dataStackToString(dStack)
        if (_hx_str != self.prev_dataStackOut):
            forGL_ForGL_ui.setOut(2)
            if (not first_time):
                forGL_ForGL_ui.msg(_hx_str,forGL_ForGL_ui.DATA_COLOR)
                forGL_ForGL_ui.eraseToLineEnd((((0 if ((_hx_str is None)) else len(_hx_str))) + 7))
            else:
                _hx_str = ("Data  " + Std.string(_hx_str))
                forGL_ForGL_ui.msg(_hx_str,forGL_ForGL_ui.DATA_COLOR)
                forGL_ForGL_ui.eraseToLineEnd((0 if ((_hx_str is None)) else len(_hx_str)))
            self.prev_dataStackOut = _hx_str
        if (not self.show_stacks_Data_Only):
            _hx_str = ("Ops   " + Std.string(self.opStackToString(rStack,oStack)))
            if (_hx_str != self.prev_opStackOut):
                forGL_ForGL_ui.setOut(3)
                if (0 <= textLine):
                    forGL_ForGL_ui.goToPos((textLine + 1),0)
                else:
                    forGL_ForGL_ui.msg("\n")
                forGL_ForGL_ui.msg(_hx_str,forGL_ForGL_ui.OP_COLOR)
                forGL_ForGL_ui.eraseToLineEnd((0 if ((_hx_str is None)) else len(_hx_str)))
                self.prev_opStackOut = _hx_str
            _hx_str = ("Nouns " + Std.string(self.nounStackToString(rStack,nStack)))
            if (_hx_str != self.prev_nounStackOut):
                forGL_ForGL_ui.setOut(4)
                if (0 <= textLine):
                    forGL_ForGL_ui.goToPos((textLine + 2),0)
                else:
                    forGL_ForGL_ui.msg("\n")
                forGL_ForGL_ui.msg(_hx_str,forGL_ForGL_ui.NOUN_COLOR)
                forGL_ForGL_ui.eraseToLineEnd((0 if ((_hx_str is None)) else len(_hx_str)))
                self.prev_nounStackOut = _hx_str
        forGL_ForGL_ui.setOut()
        forGL_ForGL_ui.restorePos()

    def show1Data(self,dataStr,textLine = -1):
        if (textLine is None):
            textLine = -1
        #                                                                                    ")
        #  Show (built in Verb) output support                                               ")
        #                                                                                    ")
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            forGL_ForGL_ui.goToPos(textLine,0)
        _hx_str = self.prev_show1_data
        self.prev_show1_data = hx_strings_Strings.insertAt(self.prev_show1_data,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(dataStr))
        forGL_ForGL_ui.setOut(5)
        forGL_ForGL_ui.msg(self.prev_show1_data)
        forGL_ForGL_ui.setOut()
        if (0 <= textLine):
            forGL_ForGL_ui.restorePos()

    def viewRepeatCount(self,repeatCount,textLine = -1):
        if (textLine is None):
            textLine = -1
        #                                                                                    ")
        #  Helper to support showing the Repeat Count                                        ")
        #                                                                                    ")
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            forGL_ForGL_ui.goToPos(textLine,0)
        forGL_ForGL_ui.msg(Std.string(repeatCount))
        if (0 <= textLine):
            forGL_ForGL_ui.restorePos()

    def runAssignment(self,rStack,dStack,oStack,nStack,assign_op = 32,op_idx = -1):
        if (assign_op is None):
            assign_op = 32
        if (op_idx is None):
            op_idx = -1
        #  Run an Assignment Operator if Data available and Noun available                   ")
        #  Need 1 Data item (or Noun with values that are pushed as Data) as source          ")
        #  and need a Noun type as destination                                               ")
        #  If NO Noun destination then Assignment is done later.                             ")
        if ((0 < len(nStack)) and ((0 < len(dStack)))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.steps_done
            _hx_local_0.steps_done = (_hx_local_1 + 1)
            _hx_local_1
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.steps_done_Verb
            _hx_local_2.steps_done_Verb = (_hx_local_3 + 1)
            _hx_local_3
            data_type_OK = True
            nounIdx = python_internal_ArrayImpl._get(nStack, (len(nStack) - 1))
            if (0 <= op_idx):
                noun_name = python_internal_ArrayImpl._get(rStack, (op_idx - 1)).internal_token
                k = 0
                while (k < len(nStack)):
                    if (python_internal_ArrayImpl._get(rStack, (nStack[k] if k >= 0 and k < len(nStack) else None)).internal_token == noun_name):
                        nounIdx = (nStack[k] if k >= 0 and k < len(nStack) else None)
                        break
                    k = (k + 1)
            dataIdx = 0
            dataType = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_type
            data1_str = ""
            data1_name = ""
            if (8 != dataType):
                data1_name = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
            if ((9 == dataType) or ((10 == dataType))):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_int = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int
                data1_str = Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int)
            elif (11 == dataType):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_float = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float
                data1_str = Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float)
            elif (8 == dataType):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_str = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
                data1_str = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
            else:
                forGL_ForGL_ui.error("\n   INTERNAL ERROR: Not valid Data type in the Data Stack\n")
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.run_text_line
                _hx_local_5.run_text_line = (_hx_local_6 + 1)
                _hx_local_6
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.run_text_line
                _hx_local_7.run_text_line = (_hx_local_8 + 1)
                _hx_local_8
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.steps_done
                _hx_local_9.steps_done = (_hx_local_10 - 1)
                _hx_local_10
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.steps_done_Verb
                _hx_local_11.steps_done_Verb = (_hx_local_12 - 1)
                _hx_local_12
            if self.show_details:
                msg_str = " "
                if self.display_internal:
                    msg_str = (("null" if msg_str is None else msg_str) + Std.string((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).internal_token))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + Std.string((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).visible_token))
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull((("  now is  " + ("null" if data1_str is None else data1_str)))))
                if (0 < len(data1_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("(" + ("null" if data1_name is None else data1_name)) + ")"))))
                msg_str = (("null" if msg_str is None else msg_str) + "\n")
                forGL_ForGL_ui.msg(msg_str)
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.run_text_line
                _hx_local_18.run_text_line = (_hx_local_19 + 1)
                _hx_local_19
            if data_type_OK:
                if (len(dStack) != 0):
                    dStack.pop(0)
            if self.show_stacks:
                self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        elif (1 < len(nStack)):
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.steps_done
            _hx_local_20.steps_done = (_hx_local_21 - 1)
            _hx_local_21
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.steps_done_Verb
            _hx_local_22.steps_done_Verb = (_hx_local_23 - 1)
            _hx_local_23
            return -10
        else:
            forGL_ForGL_ui.msg(" INFO: Not enough Data or Nouns to do Assignment now. Done later.\n")
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.run_text_line
            _hx_local_24.run_text_line = (_hx_local_25 + 1)
            _hx_local_25
            return 1
        return 0

    def addQuotes(self,_hx_str):
        #  Helper to add start char double Quote and end char double Quote                   ")
        return (("\"" + Std.string(_hx_str)) + "\"")

    def trimQuotes(self,_hx_str):
        #  Helper to remove start char double Quote and end char double Quote                ")
        if (("\"" == hx_strings_Strings.charAt8(_hx_str,0)) and (("\"" == hx_strings_Strings.charAt8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - 1))))):
            this1 = hx_strings_internal__Either2__Either2.a("\"")
            return hx_strings_Strings.trim(_hx_str,this1)
        return _hx_str

    def runMath1Data(self,rStack,dStack,oStack,nStack,after_expression):
        #  Use 1 number (Float or Int or String) with a Math Operator                        ")
        opIdx = (oStack[0] if 0 < len(oStack) else None)
        dataIdx = 0
        if after_expression:
            opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            dataIdx = (len(dStack) - 1)
        math_1_int = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int
        math_1_float = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float
        math_1_type = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_type
        op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
        data1_str = ""
        data1_name = ""
        if (10 == math_1_type):
            forGL_ForGL_ui.error((("  Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a Bool not correct.  Stopping now.\n"))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            return -3
        if (8 == math_1_type):
            resolve_info = forGL_ResolveInfo()
            type_found = forGL_NLTypeAs.resolveType((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
            if ((11 != type_found) and ((9 != type_found))):
                forGL_ForGL_ui.error(((((" Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a String ") + Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str)) + " not available. Stopping.\n"))
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.run_text_line
                _hx_local_2.run_text_line = (_hx_local_3 + 1)
                _hx_local_3
                return -3
            math_1_type = type_found
            math_1_float = resolve_info.resolve_float
            math_1_int = resolve_info.resolve_int
        else:
            data1_name = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
        if (9 == math_1_type):
            math_1_float = math_1_int
            data1_str = Std.string(math_1_int)
        else:
            data1_str = Std.string(math_1_float)
        if after_expression:
            if (len(dStack) != 0):
                dStack.pop()
            if (len(oStack) != 0):
                oStack.pop()
        else:
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(oStack) != 0):
                oStack.pop(0)
        result = 0.0
        result_int = 0
        is_int = False
        try:
            op_to_do1 = op_to_do
            if (op_to_do1 == 50):
                result = Reflect.field(Math,"fabs")(math_1_float)
            elif (op_to_do1 == 51):
                result = ((math_1_float * 180.0) / Math.PI)
            elif (op_to_do1 == 52):
                result = ((math_1_float * Math.PI) / 180.0)
            elif (op_to_do1 == 53):
                result = (Math.NaN if (((math_1_float == Math.POSITIVE_INFINITY) or ((math_1_float == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(math_1_float))
            elif (op_to_do1 == 54):
                result = (Math.NaN if (((math_1_float == Math.POSITIVE_INFINITY) or ((math_1_float == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(math_1_float))
            elif (op_to_do1 == 55):
                result = Math.tan(math_1_float)
            elif (op_to_do1 == 56):
                result = Math.asin(math_1_float)
            elif (op_to_do1 == 57):
                result = Math.acos(math_1_float)
            elif (op_to_do1 == 58):
                result = Math.atan(math_1_float)
            elif (op_to_do1 == 59):
                result = (0.0 if ((math_1_float == Math.NEGATIVE_INFINITY)) else (Math.POSITIVE_INFINITY if ((math_1_float == Math.POSITIVE_INFINITY)) else Reflect.field(Math,"exp")(math_1_float)))
            elif (op_to_do1 == 60):
                result = (Math.NEGATIVE_INFINITY if ((math_1_float == 0.0)) else (Math.NaN if ((math_1_float < 0.0)) else python_lib_Math.log(math_1_float)))
            elif (op_to_do1 == 61):
                result = (((Math.NEGATIVE_INFINITY if ((math_1_float == 0.0)) else (Math.NaN if ((math_1_float < 0.0)) else python_lib_Math.log(math_1_float)))) / python_lib_Math.log(10))
            elif (op_to_do1 == 62):
                if (0.0 > math_1_float):
                    forGL_ForGL_ui.error(((((" ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " of ") + Std.string(math_1_float)) + " not allowed. Stopping now.\n"))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.run_text_line
                    _hx_local_4.run_text_line = (_hx_local_5 + 1)
                    _hx_local_5
                    return -3
                result = (Math.NaN if ((math_1_float < 0)) else python_lib_Math.sqrt(math_1_float))
            elif (op_to_do1 == 63):
                is_int = True
                result_int = Math.floor((math_1_float + 0.5))
            elif (op_to_do1 == 64):
                is_int = True
                result_int = Math.floor(math_1_float)
            elif (op_to_do1 == 65):
                is_int = True
                result_int = Math.ceil(math_1_float)
            else:
                forGL_ForGL_ui.error((((("  INTERNAL ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " of ") + Std.string(math_1_float)) + " Unknown. Stopping now.\n"))
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.run_text_line
                _hx_local_6.run_text_line = (_hx_local_7 + 1)
                _hx_local_7
                return -11
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.warning((("\nMath ERROR: Exception in  runMath1Data(): " + Std.string(e)) + "\n"))
        if is_int:
            if after_expression:
                x = forGL_DataItem(9,"",0.0,result_int)
                dStack.append(x)
            else:
                x1 = forGL_DataItem(9,"",0.0,result_int)
                dStack.insert(0, x1)
            result = result_int
        elif after_expression:
            x2 = forGL_DataItem(11,"",result,0)
            dStack.append(x2)
        else:
            x3 = forGL_DataItem(11,"",result,0)
            dStack.insert(0, x3)
        if self.show_details:
            msg_str = (((" " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "  of  ") + ("null" if data1_str is None else data1_str))
            if (0 < len(data1_name)):
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull((((" ( " + ("null" if data1_name is None else data1_name)) + " )"))))
            forGL_ForGL_ui.msg((((("null" if msg_str is None else msg_str) + "  is  ") + Std.string(result)) + "\n"))
            _hx_local_9 = self
            _hx_local_10 = _hx_local_9.run_text_line
            _hx_local_9.run_text_line = (_hx_local_10 + 1)
            _hx_local_10
        if self.show_stacks:
            self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        return 0

    def runStr2Data(self,op_to_do,dStack,after_expression):
        #   Use 2 Strings with Operators:  +  -  *                                           ")
        dataIdx0 = 0
        dataIdx1 = 1
        if after_expression:
            dataIdx0 = (len(dStack) - 2)
            dataIdx1 = (len(dStack) - 1)
        str1 = self.trimQuotes((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str)
        if (9 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            str1 = Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int)
        elif (11 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            str1 = Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float)
        elif (10 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            if (1 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int):
                str1 = "true"
            else:
                str1 = "false"
        elif (8 != (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Unknown Data item Type: " + Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type)) + " Stopping.\n"))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.run_text_line
            _hx_local_2.run_text_line = (_hx_local_3 + 1)
            _hx_local_3
            return -11
        str2 = self.trimQuotes((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str)
        if (9 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            str2 = Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int)
        elif (11 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            str2 = Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float)
        elif (10 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            if (1 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int):
                str2 = "true"
            else:
                str2 = "false"
        elif (8 != (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Unknown Data item Type: " + Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type)) + " Stopping.\n"))
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 1)
            _hx_local_7
            return -11
        ret_val = 0
        result = ""
        op_to_do1 = op_to_do
        if (op_to_do1 == 1):
            result = hx_strings_Strings.insertAt(str1,(0 if ((str1 is None)) else len(str1)),Std.string(str2))
        elif (op_to_do1 == 2):
            if ((0 < ((0 if ((str2 is None)) else len(str2)))) and ((0 < ((0 if ((str1 is None)) else len(str1)))))):
                pieces = hx_strings_Strings.split8(str1,[str2])
                while (0 < len(pieces)):
                    result = (Std.string(result) + HxOverrides.stringOrNull((None if ((len(pieces) == 0)) else pieces.pop(0))))
            else:
                result = str1
        elif (op_to_do1 == 3):
            forGL_ForGL_ui.error("\nINTERNAL ERROR: Copy a string multiple times is NOT IMPLEMENTED.  Stopping.\n")
            ret_val = -10
        elif (op_to_do1 == 28):
            result = hx_strings_Strings.insertAt(str1,(0 if ((str1 is None)) else len(str1)),Std.string(str2))
        elif (op_to_do1 == 29):
            if ((0 < ((0 if ((str2 is None)) else len(str2)))) and ((0 < ((0 if ((str1 is None)) else len(str1)))))):
                pieces1 = hx_strings_Strings.split8(str1,[str2])
                while (0 < len(pieces1)):
                    result = (Std.string(result) + HxOverrides.stringOrNull((None if ((len(pieces1) == 0)) else pieces1.pop(0))))
            else:
                result = str1
        else:
            forGL_ForGL_ui.error((("\nINTERNAL ERROR:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " Wrong Operator to use with a string.  Stopping.\n"))
            ret_val = -11
        if (0 == ret_val):
            if after_expression:
                if (len(dStack) != 0):
                    dStack.pop()
                if (len(dStack) != 0):
                    dStack.pop()
                x = forGL_DataItem(8,self.addQuotes(result),0,0)
                dStack.append(x)
            else:
                if (len(dStack) != 0):
                    dStack.pop(0)
                if (len(dStack) != 0):
                    dStack.pop(0)
                x1 = forGL_DataItem(8,self.addQuotes(result),0,0)
                dStack.insert(0, x1)
        return ret_val

    def runMath2Data(self,rStack,dStack,oStack,nStack,after_expression):
        #  Use 2 numbers with a Math Operator                                                ")
        #                                                                                    ")
        opIdx = (oStack[0] if 0 < len(oStack) else None)
        dataIdx0 = 0
        dataIdx1 = 1
        if after_expression:
            opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            dataIdx0 = (len(dStack) - 2)
            dataIdx1 = (len(dStack) - 1)
        op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
        running_msg = ""
        data1_str = ""
        data2_str = ""
        data1_name = ""
        data2_name = ""
        if self.show_details:
            running_msg = (("  Running op:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "\n")
        math_1_int = 0
        math_1_float = 0
        math_2_int = 0
        math_2_float = 0
        math_1_type = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type
        math_2_type = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type
        if (8 != math_1_type):
            data1_name = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str
        if (8 != math_2_type):
            data2_name = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str
        need_conversion = False
        if ((math_1_type != math_2_type) and (((10 == math_1_type) or ((10 == math_2_type))))):
            forGL_ForGL_ui.msg(running_msg)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            forGL_ForGL_ui.error(" Syntax ERROR: Only a Bool with a Bool is valid.  Stopping now.\n")
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.run_text_line
            _hx_local_2.run_text_line = (_hx_local_3 + 1)
            _hx_local_3
            return -3
        if (9 == math_1_type):
            math_1_int = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int
            math_1_float = math_1_int
            if (self.show_details or self.export_as_code):
                data1_str = Std.string(math_1_int)
        elif (11 == math_1_type):
            math_1_float = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float
            if (self.show_details or self.export_as_code):
                data1_str = Std.string(math_1_float)
        else:
            need_conversion = True
        if (9 == math_2_type):
            math_2_int = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int
            math_2_float = math_2_int
            if (self.show_details or self.export_as_code):
                data2_str = Std.string(math_2_int)
        elif (11 == math_2_type):
            math_2_float = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float
            if (self.show_details or self.export_as_code):
                data2_str = Std.string(math_2_float)
        else:
            need_conversion = True
        if need_conversion:
            if ((28 == op_to_do) or ((29 == op_to_do))):
                str2result = self.runStr2Data(op_to_do,dStack,after_expression)
                def _hx_local_0():
                    _hx_local_4 = str2result
                    if (Std._hx_is(_hx_local_4,Int) or ((_hx_local_4 is None))):
                        _hx_local_4
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_4
                if (0 == _hx_local_0()):
                    if after_expression:
                        if (len(oStack) != 0):
                            oStack.pop()
                    elif (len(oStack) != 0):
                        oStack.pop(0)
                return str2result
            resolve_info = forGL_ResolveInfo()
            math_error = False
            if (8 == math_1_type):
                math_1_type = forGL_NLTypeAs.resolveType((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
                if (11 == math_1_type):
                    math_1_float = resolve_info.resolve_float
                elif (9 == math_1_type):
                    math_1_int = resolve_info.resolve_int
                    math_1_float = math_1_int
                else:
                    math_error = True
            if ((not math_error) and ((8 == math_2_type))):
                math_2_type = forGL_NLTypeAs.resolveType((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
                if (11 == math_2_type):
                    math_2_float = resolve_info.resolve_float
                elif (9 == math_2_type):
                    math_2_int = resolve_info.resolve_int
                    math_2_float = math_2_int
                else:
                    math_error = True
            if math_error:
                if (((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))):
                    str2result1 = self.runStr2Data(op_to_do,dStack,after_expression)
                    def _hx_local_0():
                        _hx_local_5 = str2result1
                        if (Std._hx_is(_hx_local_5,Int) or ((_hx_local_5 is None))):
                            _hx_local_5
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_5
                    if (0 == _hx_local_0()):
                        if after_expression:
                            if (len(oStack) != 0):
                                oStack.pop()
                        elif (len(oStack) != 0):
                            oStack.pop(0)
                    return str2result1
                forGL_ForGL_ui.error(((" Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a String not available. Stopping now.\n"))
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.run_text_line
                _hx_local_6.run_text_line = (_hx_local_7 + 1)
                _hx_local_7
                return -3
        else:
            if (9 == math_1_type):
                math_1_int = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int
                math_1_float = math_1_int
                if self.show_details:
                    data1_str = Std.string(math_1_int)
            else:
                math_1_float = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float
                if self.show_details:
                    data1_str = Std.string(math_1_float)
            if (9 == math_2_type):
                math_2_int = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int
                math_2_float = math_2_int
                if self.show_details:
                    data2_str = Std.string(math_2_int)
            else:
                math_2_float = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float
                if self.show_details:
                    data2_str = Std.string(math_2_float)
        math_is_float = True
        if (((9 == math_1_type) and ((9 == math_2_type))) or ((10 == math_1_type))):
            if ((((((((((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))) or ((5 == op_to_do))) or ((10 == op_to_do))) or ((11 == op_to_do))) or ((12 == op_to_do))) or ((13 == op_to_do))) or ((14 == op_to_do))) or ((15 == op_to_do))):
                math_is_float = False
        if after_expression:
            if (len(dStack) != 0):
                dStack.pop()
            if (len(dStack) != 0):
                dStack.pop()
            if (len(oStack) != 0):
                oStack.pop()
        else:
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(oStack) != 0):
                oStack.pop(0)
        bool_ret = False
        use_bool = False
        result_int = 0
        result = 0.0
        if (10 == math_1_type):
            use_bool = True
            op_to_do1 = op_to_do
            if (op_to_do1 == 10):
                bool_ret = (math_1_int == math_2_int)
            elif (op_to_do1 == 11):
                bool_ret = (math_1_int != math_2_int)
            elif (op_to_do1 == 12):
                bool_ret = (math_1_int < math_2_int)
            elif (op_to_do1 == 13):
                bool_ret = (math_1_int <= math_2_int)
            elif (op_to_do1 == 14):
                bool_ret = (math_1_int > math_2_int)
            elif (op_to_do1 == 15):
                bool_ret = (math_1_int >= math_2_int)
            else:
                use_bool = False
            if use_bool:
                if bool_ret:
                    result_int = 1
                else:
                    result_int = 0
                if after_expression:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x)
                else:
                    x1 = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x1)
            result = result_int
        elif (not math_is_float):
            #  Integer part                                                                      ")
            try:
                op_to_do2 = op_to_do
                if (op_to_do2 == 1):
                    result_int = (math_1_int + math_2_int)
                elif (op_to_do2 == 2):
                    result_int = (math_1_int - math_2_int)
                elif (op_to_do2 == 3):
                    result_int = (math_1_int * math_2_int)
                elif (op_to_do2 == 4):
                    if (0 == math_2_int):
                        forGL_ForGL_ui.error("ERROR: Divide by 0 not allowed. Stopping. \n")
                        _hx_local_8 = self
                        _hx_local_9 = _hx_local_8.run_text_line
                        _hx_local_8.run_text_line = (_hx_local_9 + 1)
                        _hx_local_9
                        return -3
                    else:
                        temp_float = (math_1_int / math_2_int)
                        result_int = Math.floor(temp_float)
                elif (op_to_do2 == 5):
                    if (0 == math_2_int):
                        result_int = math_1_int
                    else:
                        result_int = HxOverrides.mod(math_1_int, math_2_int)
                elif (op_to_do2 == 10):
                    bool_ret = (math_1_int == math_2_int)
                    use_bool = True
                elif (op_to_do2 == 11):
                    bool_ret = (math_1_int != math_2_int)
                    use_bool = True
                elif (op_to_do2 == 12):
                    bool_ret = (math_1_int < math_2_int)
                    use_bool = True
                elif (op_to_do2 == 13):
                    bool_ret = (math_1_int <= math_2_int)
                    use_bool = True
                elif (op_to_do2 == 14):
                    bool_ret = (math_1_int > math_2_int)
                    use_bool = True
                elif (op_to_do2 == 15):
                    bool_ret = (math_1_int >= math_2_int)
                    use_bool = True
                else:
                    result_int = 1
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                forGL_ForGL_ui.warning((("\nMATH ERROR: Exception in  runMath2Data(): Integer part " + Std.string(e)) + "\n"))
            if use_bool:
                result_int = 0
                if (True == bool_ret):
                    result_int = 1
                if after_expression:
                    x2 = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x2)
                else:
                    x3 = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x3)
            elif after_expression:
                x4 = forGL_DataItem(9,"",0,result_int)
                dStack.append(x4)
            else:
                x5 = forGL_DataItem(9,"",0,result_int)
                dStack.insert(0, x5)
            result = result_int
        else:
            #  Float part                                                                        ")
            try:
                op_to_do3 = op_to_do
                if (op_to_do3 == 1):
                    result = (math_1_float + math_2_float)
                elif (op_to_do3 == 2):
                    result = (math_1_float - math_2_float)
                elif (op_to_do3 == 3):
                    result = (math_1_float * math_2_float)
                elif (op_to_do3 == 4):
                    if (0.0 == math_2_float):
                        forGL_ForGL_ui.error("ERROR: Divide by 0 not allowed. Stopping. \n")
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.run_text_line
                        _hx_local_10.run_text_line = (_hx_local_11 + 1)
                        _hx_local_11
                        return -3
                    else:
                        result = (math_1_float / math_2_float)
                elif (op_to_do3 == 5):
                    result = HxOverrides.modf(math_1_float, math_2_float)
                elif (op_to_do3 == 6):
                    result = (math_1_float if (python_lib_Math.isnan(math_1_float)) else (math_2_float if (python_lib_Math.isnan(math_2_float)) else min(math_1_float,math_2_float)))
                elif (op_to_do3 == 7):
                    result = (math_1_float if (python_lib_Math.isnan(math_1_float)) else (math_2_float if (python_lib_Math.isnan(math_2_float)) else max(math_1_float,math_2_float)))
                elif (op_to_do3 == 8):
                    result = Math.atan2(math_1_float,math_2_float)
                elif (op_to_do3 == 9):
                    result = Math.pow(math_1_float,math_2_float)
                elif (op_to_do3 == 10):
                    bool_ret = (math_1_float == math_2_float)
                    use_bool = True
                elif (op_to_do3 == 11):
                    bool_ret = (math_1_float != math_2_float)
                    use_bool = True
                elif (op_to_do3 == 12):
                    bool_ret = (math_1_float < math_2_float)
                    use_bool = True
                elif (op_to_do3 == 13):
                    bool_ret = (math_1_float <= math_2_float)
                    use_bool = True
                elif (op_to_do3 == 14):
                    bool_ret = (math_1_float > math_2_float)
                    use_bool = True
                elif (op_to_do3 == 15):
                    bool_ret = (math_1_float >= math_2_float)
                    use_bool = True
                else:
                    result = 1.2
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                forGL_ForGL_ui.warning((("\nMATH ERROR: Exception in  runMath2Data(): Float part " + Std.string(e1)) + "\n"))
            if use_bool:
                result_int = 0
                if (True == bool_ret):
                    result_int = 1
                if after_expression:
                    x6 = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x6)
                else:
                    x7 = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x7)
            elif after_expression:
                x8 = forGL_DataItem(11,"",result,0)
                dStack.append(x8)
            else:
                x9 = forGL_DataItem(11,"",result,0)
                dStack.insert(0, x9)
        if self.show_details:
            result_str = Std.string(result)
            if use_bool:
                if (1 == result):
                    result_str = "True"
                else:
                    result_str = "False"
            msg_str = " "
            if (0 < len(data1_name)):
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("(" + ("null" if data1_name is None else data1_name)) + ") "))))
            msg_str = (("null" if msg_str is None else msg_str) + ("null" if data1_str is None else data1_str))
            msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "  "))))
            if (0 < len(data2_name)):
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("(" + ("null" if data2_name is None else data2_name)) + ") "))))
            msg_str = (("null" if msg_str is None else msg_str) + ("null" if data2_str is None else data2_str))
            forGL_ForGL_ui.msg((((("null" if msg_str is None else msg_str) + "  is  ") + ("null" if result_str is None else result_str)) + "\n"))
            _hx_local_17 = self
            _hx_local_18 = _hx_local_17.run_text_line
            _hx_local_17.run_text_line = (_hx_local_18 + 1)
            _hx_local_18
        if self.show_stacks:
            self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        return 0

    def runOperators(self,rStack,dStack,oStack,nStack,after_expression = False,punctuation_hit = False):
        if (after_expression is None):
            after_expression = False
        if (punctuation_hit is None):
            punctuation_hit = False
        #  Run 1 or more Operators                                                           ")
        #  \tPre Conditions  before Running any Operator:                                     ")
        #  \t\tThere is at least 1 Operator available to run.                                  ")
        #  \t\tAt least 1 Data item available for all except Assignment                        ")
        #  \t\tAt least 2 Data items for Math Operators  +  -  *  /  %                         ")
        #  \t\t\tand String Operators  +  concat  concatenate                                   ")
        #                                                                                    ")
        #        Optimization Possible:                                                      ")
        #            Pre Conditions are checked and satisfied BEFORE calling here.           ")
        #            Because there may be multiple Operators to do,                          ")
        #            checking for just Pre Condition of first Operator is likely not much help.  ")
        #                                                                                    ")
        #  \tInvariants:                                                                      ")
        #  \t\t\tOperator Order                                                                 ")
        #  \t\tOperators stay in order of declaration for ordinary Natural Language reading    ")
        #  \t\tOperators stay in innermost to outermost order for Math reading.                ")
        #            Math reading Operator order is enforced by use of Grouping symbols ( )  ")
        #  \t\tOverall order of Operators is determined by results of Parsing and runtime looping.  ")
        #                                                                                    ")
        #  \t\t\tOperator Selection                                                             ")
        #  \t\tOLDEST Operators (within the current Group or Stack Frame) are Run first.       ")
        #  \t\t\tRunning OLDEST first supports Invariant of Operator Order.  BUT ...            ")
        #        Expressions using ( ) after a Operator enables INFERENCE that a Function style was used.  ")
        #            After the end ) is hit, this is called with  after_expression  as true.  ")
        #                The NEWEST and not OLDEST Operator and Data are then run.           ")
        #            Think of cos(x).  x  Data value is pushed as Newest Data                ")
        #                and then cos is run that uses the just pushed x Data value.         ")
        #                                                                                    ")
        #  \t\t\tBlocking until Data item(s) are available                                      ")
        #  \t\tIf there is not enough Data for an Operator to start then it is blocked.        ")
        #  \t\t\tWhen an Operator is blocked all other remaining Operators are blocked.         ")
        #  \t\t\t\tBlocking remaining Operators supports Invariant of Operator Order.            ")
        #                                                                                    ")
        #  \t\t\tData item(s) and Operator Use                                                  ")
        #  \t\tOperators act like Verbs towards the Data stack.                                ")
        #  \t\t\tOLDEST Data item(s) are used.                                                  ")
        #  \t\t\tWhen an Operator uses a Data item the Data is considered to be consumed.       ")
        #  \t\t\t\tConsumed Data item(s) are always removed from the Data stack.                 ")
        #  \t\t\tIf an Operator produces a Result then the Result is saved as OLDEST in Data stack.  ")
        #            A Successful Operator is removed from the OLDEST of the Operator stack.  ")
        #                                                                                    ")
        #  \tPost Conditions                                                                  ")
        #      Successful:                                                                   ")
        #  \t\tResult(s) are on the Data stack as OLDEST data.                                 ")
        #  \t\tOLDEST Operator(s) that are Successful were removed from Operator stack.        ")
        #                                                                                    ")
        #        IF After an Expression is true: (happens only first time through the loop)  ")
        #            1 Result is on the Data stack as NEWEST data.                           ")
        #            1 NEWEST Operator and 1 or 2 NEWEST Data are removed.                   ")
        #            Then other successful result(s) as above.                               ")
        #                                                                                    ")
        #      Not Successful:                                                               ")
        #        return value is Not Zero.                                                   ")
        #            Negative return values are Severe Errors.                               ")
        #            Positive return values are typically Info about not enough Data available.  ")
        ret_val = 0
        original_opStack_length = len(oStack)
        assign_opStack_length = -1
        while (0 < len(oStack)):
            opIdx = (oStack[0] if 0 < len(oStack) else None)
            if after_expression:
                opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
            if ((32 == op_to_do) or ((34 == op_to_do))):
                if ((1 < len(oStack)) and (((oStack[0] if 0 < len(oStack) else None) == opIdx))):
                    if (assign_opStack_length < 0):
                        assign_opStack_length = len(oStack)
                        after_expression = True
                        continue
                    elif (len(oStack) < assign_opStack_length):
                        assign_opStack_length = len(oStack)
                        after_expression = True
                        continue
                if (not punctuation_hit):
                    return 3
                if (0 < len(nStack)):
                    if self.show_details:
                        forGL_ForGL_ui.msg((("\n  Running op:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "\n"))
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.run_text_line
                        _hx_local_0.run_text_line = (_hx_local_1 + 1)
                        _hx_local_1
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.run_text_line
                        _hx_local_2.run_text_line = (_hx_local_3 + 1)
                        _hx_local_3
                    assign_result = self.runAssignment(rStack,dStack,oStack,nStack,op_to_do,opIdx)
                    def _hx_local_0():
                        _hx_local_4 = assign_result
                        if (Std._hx_is(_hx_local_4,Int) or ((_hx_local_4 is None))):
                            _hx_local_4
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_4
                    if (0 != _hx_local_0()):
                        return assign_result
                    elif after_expression:
                        if (len(oStack) != 0):
                            oStack.pop()
                    elif (len(oStack) != 0):
                        oStack.pop(0)
                else:
                    return 2
            elif (0 == len(dStack)):
                return 1
            if ((((((((((((((((50 == op_to_do) or ((51 == op_to_do))) or ((52 == op_to_do))) or ((53 == op_to_do))) or ((54 == op_to_do))) or ((55 == op_to_do))) or ((56 == op_to_do))) or ((57 == op_to_do))) or ((58 == op_to_do))) or ((59 == op_to_do))) or ((60 == op_to_do))) or ((61 == op_to_do))) or ((62 == op_to_do))) or ((63 == op_to_do))) or ((64 == op_to_do))) or ((65 == op_to_do))):
                math_op_result = self.runMath1Data(rStack,dStack,oStack,nStack,after_expression)
                def _hx_local_0():
                    _hx_local_5 = math_op_result
                    if (Std._hx_is(_hx_local_5,Int) or ((_hx_local_5 is None))):
                        _hx_local_5
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_5
                if (0 != _hx_local_0()):
                    return math_op_result
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.steps_done
                _hx_local_6.steps_done = (_hx_local_7 + 1)
                _hx_local_7
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.steps_done_Verb
                _hx_local_8.steps_done_Verb = (_hx_local_9 + 1)
                _hx_local_9
            elif (((((((((((((((((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))) or ((4 == op_to_do))) or ((5 == op_to_do))) or ((6 == op_to_do))) or ((7 == op_to_do))) or ((8 == op_to_do))) or ((9 == op_to_do))) or ((10 == op_to_do))) or ((11 == op_to_do))) or ((12 == op_to_do))) or ((13 == op_to_do))) or ((14 == op_to_do))) or ((15 == op_to_do))) or ((28 == op_to_do))) or ((29 == op_to_do))):
                if (2 <= len(dStack)):
                    math_op_result1 = self.runMath2Data(rStack,dStack,oStack,nStack,after_expression)
                    def _hx_local_0():
                        _hx_local_10 = math_op_result1
                        if (Std._hx_is(_hx_local_10,Int) or ((_hx_local_10 is None))):
                            _hx_local_10
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_10
                    if (0 != _hx_local_0()):
                        return math_op_result1
                    _hx_local_11 = self
                    _hx_local_12 = _hx_local_11.steps_done
                    _hx_local_11.steps_done = (_hx_local_12 + 1)
                    _hx_local_12
                    _hx_local_13 = self
                    _hx_local_14 = _hx_local_13.steps_done_Verb
                    _hx_local_13.steps_done_Verb = (_hx_local_14 + 1)
                    _hx_local_14
                    after_expression = False
                    continue
                else:
                    return 1
            if self.show_stacks:
                self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line,True)
            after_expression = False
        return ret_val

    def run(self):
        #                                                                                    ")
        #  //////////////////////////////////////////////////////////////////////////////    ")
        #                                                                                    ")
        #  Setup to Run forGL script(s)                                                      ")
        #                                                                                    ")
        #  //////////////////////////////////////////////////////////////////////////////    ")
        #                                                                                    ")
        ret_val = 0
        try:
            self.start_session_time = (python_lib_Time.mktime(Date.now().date.timetuple()) * 1000)
            self.total_intp_time = 0.0
            test_def = "3=L. 1.0=p. i=1. while(i<=L){p*i=p.i+1=i}p"
            verb_display_line = self.run_text_line
            words_saved = 0
            run_result = 0
            def _hx_local_0():
                _hx_local_0 = run_result
                if (Std._hx_is(_hx_local_0,Int) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise _HxException("Class cast error")
                return _hx_local_0
            while (0 <= _hx_local_0()):
                self.elapsed_intp_time = 0.0
                _hx_str = self.user_def
                if (0 != ((0 if ((_hx_str is None)) else len(_hx_str)))):
                    test_def = self.user_def
                run_result = self.runDef(test_def,verb_display_line)
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.total_intp_time
                _hx_local_1.total_intp_time = (_hx_local_2 + self.elapsed_intp_time)
                _hx_local_1.total_intp_time
                def _hx_local_0():
                    _hx_local_3 = run_result
                    if (Std._hx_is(_hx_local_3,Int) or ((_hx_local_3 is None))):
                        _hx_local_3
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_3
                if (0 > _hx_local_0()):
                    break
                if (0 == len(self.in_dictionary_file_name)):
                    forGL_ForGL_ui.msg("\n    Hit a Key to run again or  F to Finish ? ")
                else:
                    forGL_ForGL_ui.msg("\n    Hit a Key to run again or  S to Save Verb or  F to Finish ? ")
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.run_text_line
                _hx_local_4.run_text_line = (_hx_local_5 + 1)
                _hx_local_5
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.run_text_line
                _hx_local_6.run_text_line = (_hx_local_7 + 1)
                _hx_local_7
                ans = self.stdin.readLine()
                action = ""
                if (0 < len(ans)):
                    action = ("" if ((0 >= len(ans))) else ans[0]).upper()
                if ("F" == action):
                    break
                if (0 < len(self.in_dictionary_file_name)):
                    if ("S" == action):
                        forGL_ForGL_ui.msg("\rSave Verb as what Name (no name means not Saving) ?\n")
                        _hx_local_8 = self
                        _hx_local_9 = _hx_local_8.run_text_line
                        _hx_local_8.run_text_line = (_hx_local_9 + 1)
                        _hx_local_9
                        name = ""
                        done = False
                        while (not done):
                            ans = self.stdin.readLine()
                            if (0 == len(ans)):
                                break
                            name_internal = hx_strings_Strings.toLowerCase8(ans)
                            dict_idx = self.nlDict.findWord(ans)
                            if (0 <= dict_idx):
                                forGL_ForGL_ui.msg("\r   That word is in the Dictionary. Please use another name.\n")
                                forGL_ForGL_ui.msg("\r")
                                forGL_ForGL_ui.eraseToLineEnd(0)
                                continue
                            add_result = self.nlDict.addWord(ans,4,name_internal,0,self.user_def)
                            def _hx_local_0():
                                _hx_local_10 = add_result
                                if (Std._hx_is(_hx_local_10,Int) or ((_hx_local_10 is None))):
                                    _hx_local_10
                                else:
                                    raise _HxException("Class cast error")
                                return _hx_local_10
                            if (0 == _hx_local_0()):
                                words_saved = (words_saved + 1)
                                break
                            else:
                                break
            show_times = True
            if show_times:
                end_session_time = (python_lib_Time.mktime(Date.now().date.timetuple()) * 1000)
                total_session_time = (((end_session_time - self.start_session_time)) / 1000.0)
                elapsed_session = Math.floor((total_session_time * 1000.0))
                total_session_time = (elapsed_session / 1000.0)
                forGL_ForGL_ui.msg((("\n  ... Elapsed total Run Time " + Std.string(self.total_intp_time)) + " Seconds"))
                forGL_ForGL_ui.msg((("\n  Elapsed total session Time " + Std.string(total_session_time)) + " Seconds\n"))
            def _hx_local_0():
                _hx_local_12 = run_result
                if (Std._hx_is(_hx_local_12,Int) or ((_hx_local_12 is None))):
                    _hx_local_12
                else:
                    raise _HxException("Class cast error")
                return _hx_local_12
            ret_val = _hx_local_0()
            errors = self.ForGLData.getDataErrors()
            if (0 < len(errors)):
                forGL_ForGL_ui.msg((("\n\t\t" + Std.string(len(errors))) + "  Data  handling  ERRORS\n"))
                i = 0
                while (i < len(errors)):
                    forGL_ForGL_ui.msg((errors[i] if i >= 0 and i < len(errors) else None))
                    i = (i + 1)
            warnings = self.ForGLData.getDataWarnings()
            if (0 < len(warnings)):
                forGL_ForGL_ui.msg((("\t\t" + Std.string(len(warnings))) + "  Data  handling  Warnings\n"))
                i1 = 0
                while (i1 < len(warnings)):
                    forGL_ForGL_ui.msg((warnings[i1] if i1 >= 0 and i1 < len(warnings) else None))
                    i1 = (i1 + 1)
            forGL_ForGL_ui.msg("\t\tImport   handling  Messages\n")
            forGL_ForGL_ui.msg(self.nl_Import.importWords_msgs)
            if (0 < words_saved):
                forGL_ForGL_ui.msg("Save your changes as a new file (y/n) ? ",1)
                if forGL_ForGL_ui.enterYes():
                    forGL_ForGL_ui.msg("\r")
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    export = forGL_NLExport()
                    export_result = export.exportWords(self.nlDict,self.in_dictionary_file_name,self.ForGLData)
                    forGL_ForGL_ui.msg("\t\tExport  handling  Messages\n")
                    forGL_ForGL_ui.msg(export.exportWords_msgs)
                    def _hx_local_0():
                        _hx_local_15 = export_result
                        if (Std._hx_is(_hx_local_15,Int) or ((_hx_local_15 is None))):
                            _hx_local_15
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_15
                    if (0 != _hx_local_0()):
                        forGL_ForGL_ui.msg("Problem with Saving your Dictionary. Please check messages and .toml file\n")
            if (0 < len(self.export_as_code_log)):
                forGL_ForGL_ui.msg("\n")
                forGL_ForGL_ui.eraseToLineEnd(0)
                forGL_ForGL_ui.msg("#    Export as Code Log\n")
                i2 = 0
                while (i2 < len(self.export_as_code_log)):
                    forGL_ForGL_ui.msg((self.export_as_code_log[i2] if i2 >= 0 and i2 < len(self.export_as_code_log) else None),2,True)
                    i2 = (i2 + 1)
                forGL_ForGL_ui.msg("\n")
                expAs = forGL_NLExportAs()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in run(): " + Std.string(e)) + " \n"))
            def _hx_local_0():
                _hx_local_17 = -11
                if (Std._hx_is(_hx_local_17,Int) or ((_hx_local_17 is None))):
                    _hx_local_17
                else:
                    raise _HxException("Class cast error")
                return _hx_local_17
            ret_val = _hx_local_0()
        return ret_val

    def runDef(self,def_to_run,textLine):
        #  Run a single forGL script (Verb definition)                                       ")
        ret_val = 0
        try:
            self.run_text_line = textLine
            forGL_ForGL_ui.goToPos(self.run_text_line,0)
            forGL_ForGL_ui.eraseToDispEnd()
            forGL_ForGL_ui.msg("\rExport test Verb to other programming languages (y/n) ?  ")
            self.export_as_code = forGL_ForGL_ui.enterYes()
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            if (not self.export_as_code):
                forGL_ForGL_ui.msg("\rDisplay internal Names when running (y/n) ?  ")
                self.display_internal = forGL_ForGL_ui.enterYes()
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.run_text_line
                _hx_local_2.run_text_line = (_hx_local_3 + 1)
                _hx_local_3
                forGL_ForGL_ui.msg("\r")
                forGL_ForGL_ui.eraseToLineEnd(0)
            else:
                self.display_internal = True
            forGL_ForGL_ui.msg("\rShow details of various information (y/n) ?  ")
            self.show_details = forGL_ForGL_ui.enterYes()
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            forGL_ForGL_ui.msg("\rShow details of Words used (y/n) ?  ")
            self.show_words_table = forGL_ForGL_ui.enterYes()
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 1)
            _hx_local_7
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            self.show_stacks = True
            self.show_stacks_Data_Only = False
            self.single_step = True
            forGL_ForGL_ui.msg("\rShow Stacks: N = none & no Steps  OR  D is only Data  OR  any Key for all ? ")
            ans = self.stdin.readLine()
            if (0 < len(ans)):
                char = ("" if ((0 >= len(ans))) else ans[0])
                if (("N" == char) or (("n" == char))):
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rNo stepping; will Run full speed and not show stacks.\n")
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.run_text_line
                    _hx_local_8.run_text_line = (_hx_local_9 + 1)
                    _hx_local_9
                    self.show_stacks = False
                    self.single_step = False
                    self.delay_seconds_default = 0
                    self.delay_seconds = self.delay_seconds_default
                    self.view_DON_throttle = True
                elif (("D" == char) or (("d" == char))):
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rManual stepping and only Data stack will show.\n")
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.run_text_line
                    _hx_local_10.run_text_line = (_hx_local_11 + 1)
                    _hx_local_11
                    self.show_stacks = True
                    self.show_stacks_Data_Only = True
                    self.single_step = True
                else:
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rManual stepping and all stacks will show.\n")
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.run_text_line
                    _hx_local_12.run_text_line = (_hx_local_13 + 1)
                    _hx_local_13
                    self.show_stacks = True
                    self.single_step = True
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.run_text_line
            _hx_local_14.run_text_line = (_hx_local_15 + 1)
            _hx_local_15
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            if self.show_stacks:
                self.single_step = True
                forGL_ForGL_ui.msg("\rStepping Speed: 0 to 9 (each as .2 sec delay)  OR  any Key for Manual ? ")
                ans1 = self.stdin.readLine()
                if (0 < len(ans1)):
                    char1 = ("" if ((0 >= len(ans1))) else ans1[0])
                    if (("0" <= char1) and ((char1 <= "9"))):
                        self.delay_seconds_default = (((HxString.charCodeAt(char1,0) - 48)) / 5.0)
                        self.delay_seconds = self.delay_seconds_default
                        forGL_ForGL_ui.eraseToLineEnd(0)
                        forGL_ForGL_ui.msg((("\rAutomatic stepping with  " + Std.string(self.delay_seconds)) + "  seconds delay.\n"))
                        _hx_local_16 = self
                        _hx_local_17 = _hx_local_16.run_text_line
                        _hx_local_16.run_text_line = (_hx_local_17 + 1)
                        _hx_local_17
                        self.show_stacks = True
                        self.single_step = False
                    else:
                        forGL_ForGL_ui.eraseToLineEnd(0)
                        forGL_ForGL_ui.msg("\rManual stepping. Hit a key to do next step.\n")
                        _hx_local_18 = self
                        _hx_local_19 = _hx_local_18.run_text_line
                        _hx_local_18.run_text_line = (_hx_local_19 + 1)
                        _hx_local_19
                        self.show_stacks = True
                        self.single_step = True
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.run_text_line
            _hx_local_20.run_text_line = (_hx_local_21 + self.nlDict.showDictionaryWords(False))
            _hx_local_20.run_text_line
            forGL_ForGL_ui.setOut(6)
            forGL_ForGL_ui.msg(("    Test_Verb is:\n" + Std.string(def_to_run)),2,True)
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.run_text_line
            _hx_local_22.run_text_line = (_hx_local_23 + 1)
            _hx_local_23
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.run_text_line
            _hx_local_24.run_text_line = (_hx_local_25 + 1)
            _hx_local_25
            forGL_ForGL_ui.setOut(-1)
            user_Verb = ""
            user_Verb = forGL_ForGL_ui.enterYourVerb()
            _hx_local_26 = self
            _hx_local_27 = _hx_local_26.run_text_line
            _hx_local_26.run_text_line = (_hx_local_27 + 1)
            _hx_local_27
            _hx_local_28 = self
            _hx_local_29 = _hx_local_28.run_text_line
            _hx_local_28.run_text_line = (_hx_local_29 + 1)
            _hx_local_29
            def _hx_local_0():
                _hx_local_30 = forGL_ForGL_ui.enterYourVerb_return
                if (Std._hx_is(_hx_local_30,Int) or ((_hx_local_30 is None))):
                    _hx_local_30
                else:
                    raise _HxException("Class cast error")
                return _hx_local_30
            if (0 != _hx_local_0()):
                return forGL_ForGL_ui.enterYourVerb_return
            if (("test_verb" == hx_strings_Strings.toLowerCase8(user_Verb)) or (("testverb" == hx_strings_Strings.toLowerCase8(user_Verb)))):
                user_Verb = def_to_run
            self.user_def = user_Verb
            if self.export_as_code:
                forGL_ForGL_ui.msg("\r    Please enter the export Name for this Verb ? ")
                self.export_as_code_verb_name = self.stdin.readLine()
                #  TODO: Check that the Verb Name is OK                                              ")
                _hx_local_31 = self
                _hx_local_32 = _hx_local_31.run_text_line
                _hx_local_31.run_text_line = (_hx_local_32 + 1)
                _hx_local_32
                self.export_as_code_log = list()
                _this = self.export_as_code_log
                x = ("# Original Verb  " + HxOverrides.stringOrNull(self.export_as_code_verb_name))
                _this.append(x)
                _this1 = self.export_as_code_log
                x1 = self.user_def
                _this1.append(x1)
            self.repeat_found = False
            self.repeat_count = 0
            self.repeat_limit = -1
            self.repeat_limit_found = False
            tokens = self.nl_Parse.parse(user_Verb,forGL_ParseStyle.PARSE_EURO)
            _hx_local_33 = self
            _hx_local_34 = _hx_local_33.run_text_line
            _hx_local_33.run_text_line = (_hx_local_34 + self.nl_Parse.parse_text_lines_added)
            _hx_local_33.run_text_line
            self.runStack = list()
            _hx_local_35 = self
            _hx_local_36 = _hx_local_35.run_text_line
            _hx_local_35.run_text_line = (_hx_local_36 + self.nl_Parse.resolveTokens(tokens,self.nlDict,self.runStack,self.run_verbose))
            _hx_local_35.run_text_line
            self.repeat_found = self.nl_Parse.repeat_verb_found
            if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not equal.\n"))
                _hx_local_37 = self
                _hx_local_38 = _hx_local_37.run_text_line
                _hx_local_37.run_text_line = (_hx_local_38 + 1)
                _hx_local_38
                _hx_local_39 = self
                _hx_local_40 = _hx_local_39.run_text_line
                _hx_local_39.run_text_line = (_hx_local_40 + 1)
                _hx_local_40
            self.nl_Parse.resolveAssigns(self.runStack)
            choice_result = -11
            if self.export_as_code:
                export_runStack = self.nl_Parse.refactorForExport(self.runStack)
                choice_result = self.nl_Parse.resolveChoice(export_runStack)
                self.runStack = export_runStack
            else:
                choice_result = self.nl_Parse.resolveChoice(self.runStack)
            def _hx_local_0():
                _hx_local_41 = choice_result
                if (Std._hx_is(_hx_local_41,Int) or ((_hx_local_41 is None))):
                    _hx_local_41
                else:
                    raise _HxException("Class cast error")
                return _hx_local_41
            if (0 > _hx_local_0()):
                return choice_result
            if (((self.show_words_table or self.export_as_code)) and ((0 < len(self.runStack)))):
                _hx_local_42 = self
                _hx_local_43 = _hx_local_42.run_text_line
                _hx_local_42.run_text_line = (_hx_local_43 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,self.export_as_code))
                _hx_local_42.run_text_line
            #                                                                                    ")
            #  Feedback the results of Type resolution by Colored text.                          ")
            #  Colors for different word/symbol types                                            ")
            #                                                                                    ")
            forGL_ForGL_ui.setOut(6)
            colored_text_line = self.run_text_line
            colored_text_no_color = ""
            color = forGL_ForGL_ui.DEFAULT_COLOR
            i = 0
            while (i < len(self.runStack)):
                _hx_str = ""
                if self.display_internal:
                    _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).internal_token
                else:
                    _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).visible_token
                no_color_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).internal_token
                color = forGL_ForGL_ui.getTypeColor((self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type)
                forGL_ForGL_ui.msg((("null" if _hx_str is None else _hx_str) + " "),color)
                colored_text_no_color = (("null" if colored_text_no_color is None else colored_text_no_color) + HxOverrides.stringOrNull(((Std.string(no_color_str) + " "))))
                i = (i + 1)
            forGL_ForGL_ui.setOut(-1)
            if self.export_as_code:
                _this2 = self.export_as_code_log
                x2 = ("# forGL Verb after changes for Export as Code  " + HxOverrides.stringOrNull(self.export_as_code_verb_name))
                _this2.append(x2)
                _this3 = self.export_as_code_log
                _this3.append(colored_text_no_color)
                _this4 = self.export_as_code_log
                x3 = ("# forGL Verb exact Syntax table  " + HxOverrides.stringOrNull(self.export_as_code_verb_name))
                _this4.append(x3)
                _this5 = self.export_as_code_log
                x4 = self.nl_Parse.words_table_text
                _this5.append(x4)
            forGL_ForGL_ui.msg("\n")
            _hx_local_46 = self
            _hx_local_47 = _hx_local_46.run_text_line
            _hx_local_46.run_text_line = (_hx_local_47 + 1)
            _hx_local_47
            repeat_text_line = self.run_text_line
            if self.repeat_found:
                forGL_ForGL_ui.msg("\n")
                _hx_local_48 = self
                _hx_local_49 = _hx_local_48.run_text_line
                _hx_local_48.run_text_line = (_hx_local_49 + 1)
                _hx_local_49
            self.show_text_line = self.run_text_line
            self.prev_show1_data = ""
            forGL_ForGL_ui.msg("\n\n")
            _hx_local_50 = self
            _hx_local_51 = _hx_local_50.run_text_line
            _hx_local_50.run_text_line = (_hx_local_51 + 1)
            _hx_local_51
            _hx_local_52 = self
            _hx_local_53 = _hx_local_52.run_text_line
            _hx_local_52.run_text_line = (_hx_local_53 + 1)
            _hx_local_53
            self.dataStack = list()
            self.opStack = list()
            self.assignStack = list()
            self.nouns = list()
            self.dataOpNoun_text_line = self.run_text_line
            if self.show_stacks:
                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line,True)
                forGL_ForGL_ui.msg("\n\n\n")
                _hx_local_54 = self
                _hx_local_55 = _hx_local_54.run_text_line
                _hx_local_54.run_text_line = (_hx_local_55 + 3)
                _hx_local_54.run_text_line
            if self.repeat_found:
                repeat_text_line1 = self.run_text_line
                forGL_ForGL_ui.msg("\n")
                _hx_local_56 = self
                _hx_local_57 = _hx_local_56.run_text_line
                _hx_local_56.run_text_line = (_hx_local_57 + 1)
                _hx_local_57
            self.start_intp_time = (python_lib_Time.mktime(Date.now().date.timetuple()) * 1000)
            self.last_view_DON_time = self.start_intp_time
            self.intp_ip = 0
            self.steps_done = 0
            self.steps_done_Verb = 0
            self.intp_return_result = 0
            intp_done = False
            while (not intp_done):
                #      I N T E R P R E T E R         LOOP                                            ")
                apply_op = False
                i1 = 0
                ip = self.intp_ip
                while (ip < len(self.runStack)):
                    if self.single_step:
                        char_code = Sys.getChar(False)
                        if (27 == char_code):
                            self.single_step = False
                            char_code = Sys.getChar(False)
                        else:
                            if ((48 <= char_code) and ((char_code <= 57))):
                                self.delay_seconds = (char_code - 48)
                            char_code = Sys.getChar(False)
                    elif (0.0 < self.delay_seconds):
                        Sys.sleep(self.delay_seconds)
                    else:
                        self.view_DON_throttle = True
                    if (self.single_step or self.show_stacks):
                        #  Display latest Interpreter values                                                 ")
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                    if (12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        if (((((("if" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("for" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("switch" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("while" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("else" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("return" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                            _hx_local_58 = self
                            _hx_local_59 = _hx_local_58.steps_done
                            _hx_local_58.steps_done = (_hx_local_59 + 1)
                            _hx_local_59
                            ip = (ip + 1)
                            continue
                    if ((((9 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((10 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((11 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((8 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        #      DATA item. Put on Data stack                                                  ")
                        _this6 = self.dataStack
                        x5 = forGL_DataItem((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int)
                        _this6.append(x5)
                        _hx_local_61 = self
                        _hx_local_62 = _hx_local_61.steps_done
                        _hx_local_61.steps_done = (_hx_local_62 + 1)
                        _hx_local_62
                        ip = (ip + 1)
                        continue
                    if (((6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((7 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        #      NOUNS are Named references to Data                                            ")
                        #    Search for a Noun name (internal token) in Noun stack                           ")
                        name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                        if (0 == ((0 if ((name_to_find is None)) else len(name_to_find)))):
                            forGL_ForGL_ui.error((("INTERNAL ERROR: Internal Name of Noun " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)) + " is missing\n"))
                            _hx_local_64 = self
                            _hx_local_65 = _hx_local_64.run_text_line
                            _hx_local_64.run_text_line = (_hx_local_65 + 1)
                            _hx_local_65
                            name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                        nounsIdx = 0
                        runIdx = 0
                        already_known = False
                        while (nounsIdx < len(self.nouns)):
                            runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                            if (name_to_find == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token):
                                already_known = True
                                break
                            nounsIdx = (nounsIdx + 1)
                        local_inference = False
                        if ((not already_known) and ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                            local_inference = True
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type = 7
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_noun_data = 0
                        if (False == already_known):
                            #    add NOUN or LOCAL NOUN as NEWEST                                                ")
                            _this7 = self.nouns
                            _this7.append(ip)
                            if (6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                                self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns,True)
                            nounsIdx = (len(self.nouns) - 1)
                            runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                        if (not local_inference):
                            if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                if (0 < len(self.opStack)):
                                    self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                    name = ""
                                    if self.display_internal:
                                        name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                                    else:
                                        name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                                    if (0 < len(self.assignStack)):
                                        message = (("\nSyntax WARNING:  " + ("null" if name is None else name)) + "  used with no value. ")
                                        message = (("null" if message is None else message) + "Punctuation is missing so no assignment.\n")
                                        message = (("null" if message is None else message) + "Please add Punctuation.\n")
                                        message = (("null" if message is None else message) + "Assignment done anyway to help.\n")
                                        forGL_ForGL_ui.warning(message)
                                        _hx_local_70 = self
                                        _hx_local_71 = _hx_local_70.run_text_line
                                        _hx_local_70.run_text_line = (_hx_local_71 + 1)
                                        _hx_local_71
                                        _hx_local_72 = self
                                        _hx_local_73 = _hx_local_72.run_text_line
                                        _hx_local_72.run_text_line = (_hx_local_73 + 1)
                                        _hx_local_73
                                        _hx_local_74 = self
                                        _hx_local_75 = _hx_local_74.run_text_line
                                        _hx_local_74.run_text_line = (_hx_local_75 + 1)
                                        _hx_local_75
                                        _hx_local_76 = self
                                        _hx_local_77 = _hx_local_76.run_text_line
                                        _hx_local_76.run_text_line = (_hx_local_77 + 1)
                                        _hx_local_77
                                        _this8 = self.assignStack
                                        if (len(_this8) != 0):
                                            _this8.pop()
                                        self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    else:
                                        message1 = (("\nSyntax ERROR:  " + ("null" if name is None else name)) + "  used with no value. = (assignment) is missing.\n")
                                        message1 = (("null" if message1 is None else message1) + "Or a Verb was spelled wrong and a loop may not end !\n")
                                        message1 = (("null" if message1 is None else message1) + "Please fix spelling OR add = with Punctuation at end.\n")
                                        message1 = (("null" if message1 is None else message1) + "Now trying as local Noun and assignment anyway to help.\n")
                                        forGL_ForGL_ui.error(message1)
                                        _hx_local_81 = self
                                        _hx_local_82 = _hx_local_81.run_text_line
                                        _hx_local_81.run_text_line = (_hx_local_82 + 1)
                                        _hx_local_82
                                        _hx_local_83 = self
                                        _hx_local_84 = _hx_local_83.run_text_line
                                        _hx_local_83.run_text_line = (_hx_local_84 + 1)
                                        _hx_local_84
                                        _hx_local_85 = self
                                        _hx_local_86 = _hx_local_85.run_text_line
                                        _hx_local_85.run_text_line = (_hx_local_86 + 1)
                                        _hx_local_86
                                        _hx_local_87 = self
                                        _hx_local_88 = _hx_local_87.run_text_line
                                        _hx_local_87.run_text_line = (_hx_local_88 + 1)
                                        _hx_local_88
                                        _hx_local_89 = self
                                        _hx_local_90 = _hx_local_89.run_text_line
                                        _hx_local_89.run_text_line = (_hx_local_90 + 1)
                                        _hx_local_90
                                        self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                        if (0 < len(self.dataStack)):
                                            dataIdx = (len(self.dataStack) - 1)
                                            data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int
                                            if (9 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                                data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int)
                                            elif (10 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                                if (1 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int):
                                                    data = "true"
                                                else:
                                                    data = "false"
                                            else:
                                                data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float)
                                            _this9 = self.dataStack
                                            if (len(_this9) != 0):
                                                _this9.pop()
                                            forGL_ForGL_ui.warning((((((("\nSyntax WARNING:  " + ("null" if name is None else name)) + " used without a value.  GUESSING: ") + ("null" if name is None else name)) + " = ") + Std.string(data)) + " .\n"))
                                            _hx_local_91 = self
                                            _hx_local_92 = _hx_local_91.run_text_line
                                            _hx_local_91.run_text_line = (_hx_local_92 + 1)
                                            _hx_local_92
                                            _hx_local_93 = self
                                            _hx_local_94 = _hx_local_93.run_text_line
                                            _hx_local_93.run_text_line = (_hx_local_94 + 1)
                                            _hx_local_94
                                        else:
                                            message2 = (((("\nSyntax ERROR:  " + ("null" if name is None else name)) + " used without a value. Suggest ") + ("null" if name is None else name)) + " = your_data .  Stopping.\n")
                                            forGL_ForGL_ui.error(message2,1)
                                            _hx_local_95 = self
                                            _hx_local_96 = _hx_local_95.run_text_line
                                            _hx_local_95.run_text_line = (_hx_local_96 + 1)
                                            _hx_local_96
                                            _hx_local_97 = self
                                            _hx_local_98 = _hx_local_97.run_text_line
                                            _hx_local_97.run_text_line = (_hx_local_98 + 1)
                                            _hx_local_98
                                            self.intp_return_result = -4
                                            break
                            if (not (((((ip + 1) < ((len(self.runStack) - 1))) and ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((34 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))))):
                                if (8 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                    _this10 = self.dataStack
                                    x6 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                                    _this10.append(x6)
                                else:
                                    name1 = ""
                                    if self.display_internal:
                                        name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                                    else:
                                        name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                                    _this11 = self.dataStack
                                    x7 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,name1,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                                    _this11.append(x7)
                        _hx_local_99 = self
                        _hx_local_100 = _hx_local_99.steps_done
                        _hx_local_99.steps_done = (_hx_local_100 + 1)
                        _hx_local_100
                        ip = (ip + 1)
                        continue
                    apply_op = False
                    if (2 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        #    OPERATORS and VERBS                                                             ")
                        op_to_do = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_op_means
                        #    Check for Punctuation. Punctuation is never pushed on Operator stack.           ")
                        if ((((45 == op_to_do) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                            apply_op = True
                            if self.show_stacks:
                                if self.show_details:
                                    forGL_ForGL_ui.msg((("   running Punctuation  " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                                    _hx_local_102 = self
                                    _hx_local_103 = _hx_local_102.run_text_line
                                    _hx_local_102.run_text_line = (_hx_local_103 + 1)
                                    _hx_local_103
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                            if (0 < len(self.assignStack)):
                                _this12 = self.opStack
                                _this13 = self.assignStack
                                x8 = (None if ((len(_this13) == 0)) else _this13.pop())
                                _this12.insert(0, x8)
                            if (0 < len(self.opStack)):
                                ops_result = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                def _hx_local_0():
                                    _hx_local_104 = ops_result
                                    if (Std._hx_is(_hx_local_104,Int) or ((_hx_local_104 is None))):
                                        _hx_local_104
                                    else:
                                        raise _HxException("Class cast error")
                                    return _hx_local_104
                                if (_hx_local_0() < 0):
                                    self.intp_return_result = ops_result
                                    break
                        else:
                            #    Not Punctuation                                                                 ")
                            if (((32 == op_to_do) or ((33 == op_to_do))) or ((34 == op_to_do))):
                                if (33 == op_to_do):
                                    #   Special Case: We know Assign To has only 1 destination after it.                 ")
                                    if (((7 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((6 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                        forGL_ForGL_ui.error("SYNTAX ERROR: Noun or local Noun must follow Assign into. Stopping\n")
                                        _hx_local_105 = self
                                        _hx_local_106 = _hx_local_105.run_text_line
                                        _hx_local_105.run_text_line = (_hx_local_106 + 1)
                                        _hx_local_106
                                        self.intp_return_result = -4
                                        break
                                    if (0 == len(self.dataStack)):
                                        #   Try running pending Operators                                                    ")
                                        if (0 == len(self.opStack)):
                                            forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available and nothing to make data. Stopping\n")
                                            _hx_local_107 = self
                                            _hx_local_108 = _hx_local_107.run_text_line
                                            _hx_local_107.run_text_line = (_hx_local_108 + 1)
                                            _hx_local_108
                                            self.intp_return_result = -4
                                            break
                                        self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                        if (0 == len(self.dataStack)):
                                            forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available. Stopping\n")
                                            _hx_local_109 = self
                                            _hx_local_110 = _hx_local_109.run_text_line
                                            _hx_local_109.run_text_line = (_hx_local_110 + 1)
                                            _hx_local_110
                                            self.intp_return_result = -4
                                            break
                                    if (0 < len(self.opStack)):
                                        self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                    #    Find first reference in the Nouns stack                                         ")
                                    assign_idx = (ip + 1)
                                    name_to_find1 = python_internal_ArrayImpl._get(self.runStack, (ip + 1)).internal_token
                                    nounsIdx1 = 0
                                    runIdx1 = 0
                                    already_known1 = False
                                    while (nounsIdx1 < len(self.nouns)):
                                        runIdx1 = (self.nouns[nounsIdx1] if nounsIdx1 >= 0 and nounsIdx1 < len(self.nouns) else None)
                                        if (name_to_find1 == (self.runStack[runIdx1] if runIdx1 >= 0 and runIdx1 < len(self.runStack) else None).internal_token):
                                            already_known1 = True
                                            assign_idx = runIdx1
                                            break
                                        nounsIdx1 = (nounsIdx1 + 1)
                                    if ((not already_known1) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                        _this14 = self.nouns
                                        _this14.append((ip + 1))
                                    #   Assign into following Noun or Local Noun (using Noun stack reference index)      ")
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_noun_data = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_str = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_str
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_float = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_float
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_int = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                    _this15 = self.dataStack
                                    if (len(_this15) != 0):
                                        _this15.pop()
                                    if (0 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type):
                                        if ((ip + 1) == assign_idx):
                                            python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type = 7
                                            _this16 = self.nouns
                                            _this16.append((ip + 1))
                                    if (2 == python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_type):
                                        #   If Punctuation then skip it as well.                                             ")
                                        next_op = python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_op_means
                                        if ((((45 == next_op) or ((46 == next_op))) or ((47 == next_op))) or ((48 == next_op))):
                                            ip = (ip + 3)
                                        else:
                                            ip = (ip + 2)
                                    else:
                                        ip = (ip + 2)
                                    _hx_local_115 = self
                                    _hx_local_116 = _hx_local_115.steps_done
                                    _hx_local_115.steps_done = (_hx_local_116 + 1)
                                    _hx_local_116
                                    continue
                                else:
                                    #   Assign From and Assignment are deferred until punctuation is hit.                ")
                                    _this17 = self.assignStack
                                    _this17.append(ip)
                                    ip = (ip + 1)
                                    continue
                            elif (30 == op_to_do):
                                result = Math.PI
                                _this18 = self.dataStack
                                x9 = forGL_DataItem(11,"",result,0)
                                _this18.append(x9)
                                _hx_local_118 = self
                                _hx_local_119 = _hx_local_118.steps_done
                                _hx_local_118.steps_done = (_hx_local_119 + 1)
                                _hx_local_119
                                ip = (ip + 1)
                                continue
                            elif (31 == op_to_do):
                                result1 = python_lib_Random.random()
                                _this19 = self.dataStack
                                x10 = forGL_DataItem(11,"",result1,0)
                                _this19.append(x10)
                                _hx_local_121 = self
                                _hx_local_122 = _hx_local_121.steps_done
                                _hx_local_121.steps_done = (_hx_local_122 + 1)
                                _hx_local_122
                                ip = (ip + 1)
                                continue
                            elif ((18 == op_to_do) or ((19 == op_to_do))):
                                if (18 == op_to_do):
                                    #   Entering an expression to evaluate.                                              ")
                                    _this20 = self.old_opStackFrames
                                    x11 = len(self.opStack)
                                    _this20.append(x11)
                                    while (0 < len(self.opStack)):
                                        _this21 = self.old_opStack
                                        _this22 = self.opStack
                                        x12 = (None if ((len(_this22) == 0)) else _this22.pop(0))
                                        _this21.append(x12)
                                    _this23 = self.old_dataStackFrames
                                    x13 = len(self.dataStack)
                                    _this23.append(x13)
                                    while (0 < len(self.dataStack)):
                                        _this24 = self.old_dataStack
                                        _this25 = self.dataStack
                                        x14 = (None if ((len(_this25) == 0)) else _this25.pop(0))
                                        _this24.append(x14)
                                else:
                                    #  Leaving an Expression that was evaluated.                                         ")
                                    #  Make sure everything was evaluated.                                               ")
                                    #  Within a single group to evaluate                                                 ")
                                    #  there is no starting Operator or Data stack values.                               ")
                                    #  This means if there are any Operators to do then do them now.                     ")
                                    if (0 < len(self.opStack)):
                                        ops_result1 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                        def _hx_local_0():
                                            _hx_local_124 = ops_result1
                                            if (Std._hx_is(_hx_local_124,Int) or ((_hx_local_124 is None))):
                                                _hx_local_124
                                            else:
                                                raise _HxException("Class cast error")
                                            return _hx_local_124
                                        if (_hx_local_0() < 0):
                                            self.intp_return_result = ops_result1
                                            break
                                    #                                                                                    ")
                                    #  Restore 1 Frame of old underneath (at Bottom of) Operator and Data stacks         ")
                                    #                                                                                    ")
                                    num_to_do = 0
                                    if (0 < len(self.old_opStackFrames)):
                                        _this26 = self.old_opStackFrames
                                        num_to_do = (None if ((len(_this26) == 0)) else _this26.pop())
                                    while (0 < num_to_do):
                                        _this27 = self.opStack
                                        _this28 = self.old_opStack
                                        x15 = (None if ((len(_this28) == 0)) else _this28.pop())
                                        _this27.insert(0, x15)
                                        num_to_do = (num_to_do - 1)
                                    num_to_do = 0
                                    if (0 < len(self.old_dataStackFrames)):
                                        _this29 = self.old_dataStackFrames
                                        num_to_do = (None if ((len(_this29) == 0)) else _this29.pop())
                                    while (0 < num_to_do):
                                        _this30 = self.dataStack
                                        _this31 = self.old_dataStack
                                        x16 = (None if ((len(_this31) == 0)) else _this31.pop())
                                        _this30.insert(0, x16)
                                        num_to_do = (num_to_do - 1)
                                    if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                        #                                                                                    ")
                                        #  There is an indication of a Choice word before this Expression                    ")
                                        #                                                                                    ")
                                        choice_idx = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                        choice_name = (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).internal_token
                                        if (12 == (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_type):
                                            if (((("for" == choice_name) or (("if" == choice_name))) or (("switch" == choice_name))) or (("while" == choice_name))):
                                                if (("if" == choice_name) or (("while" == choice_name))):
                                                    #   Must be a Bool on the top of Data stack. Error if not.                           ")
                                                    if ((0 == len(self.dataStack)) or ((10 != python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type))):
                                                        forGL_ForGL_ui.error((("SYNTAX ERROR: " + Std.string(choice_name)) + " expression result is not Bool. Stopping.\n"))
                                                        _hx_local_127 = self
                                                        _hx_local_128 = _hx_local_127.run_text_line
                                                        _hx_local_127.run_text_line = (_hx_local_128 + 1)
                                                        _hx_local_128
                                                        forGL_ForGL_ui.msg((("Error location (word number) is " + Std.string(ip)) + "\n"))
                                                        _hx_local_129 = self
                                                        _hx_local_130 = _hx_local_129.run_text_line
                                                        _hx_local_129.run_text_line = (_hx_local_130 + 1)
                                                        _hx_local_130
                                                        _hx_local_131 = self
                                                        _hx_local_132 = _hx_local_131.run_text_line
                                                        _hx_local_131.run_text_line = (_hx_local_132 + self.nl_Parse.showWordsTable(self.runStack,True,True,False))
                                                        _hx_local_131.run_text_line
                                                        self.intp_return_result = -4
                                                        break
                                                    exp_bool = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                                    _this32 = self.dataStack
                                                    if (len(_this32) != 0):
                                                        _this32.pop()
                                                    if (1 == exp_bool):
                                                        ip = (ip + 1)
                                                        continue
                                                    else:
                                                        ip = (Math.floor((self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_float) + 1)
                                                        continue
                                                else:
                                                    forGL_ForGL_ui.error((("INTERNAL ERROR: " + Std.string(choice_name)) + " not implemented. Stopping.\n"))
                                                    _hx_local_134 = self
                                                    _hx_local_135 = _hx_local_134.run_text_line
                                                    _hx_local_134.run_text_line = (_hx_local_135 + 1)
                                                    _hx_local_135
                                                    self.intp_return_result = -10
                                                    break
                                        else:
                                            forGL_ForGL_ui.error("INTERNAL ERROR: Choice indicated but not referenced correctly. Stopping.\n")
                                            _hx_local_136 = self
                                            _hx_local_137 = _hx_local_136.run_text_line
                                            _hx_local_136.run_text_line = (_hx_local_137 + 1)
                                            _hx_local_137
                                            self.intp_return_result = -11
                                            break
                                    if (0 < len(self.opStack)):
                                        ops_result2 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,True)
                                        def _hx_local_0():
                                            _hx_local_138 = ops_result2
                                            if (Std._hx_is(_hx_local_138,Int) or ((_hx_local_138 is None))):
                                                _hx_local_138
                                            else:
                                                raise _HxException("Class cast error")
                                            return _hx_local_138
                                        if (_hx_local_0() < 0):
                                            self.intp_return_result = ops_result2
                                            break
                            elif (not (((22 == op_to_do) or ((23 == op_to_do))))):
                                if ((26 == op_to_do) or ((27 == op_to_do))):
                                    if (26 == op_to_do):
                                        _this33 = self.old_opStackFrames
                                        x17 = len(self.opStack)
                                        _this33.append(x17)
                                        while (0 < len(self.opStack)):
                                            _this34 = self.old_opStack
                                            _this35 = self.opStack
                                            x18 = (None if ((len(_this35) == 0)) else _this35.pop(0))
                                            _this34.append(x18)
                                        _this36 = self.old_dataStackFrames
                                        x19 = len(self.dataStack)
                                        _this36.append(x19)
                                        while (0 < len(self.dataStack)):
                                            _this37 = self.old_dataStack
                                            _this38 = self.dataStack
                                            x20 = (None if ((len(_this38) == 0)) else _this38.pop(0))
                                            _this37.append(x20)
                                    else:
                                        if (0 < len(self.opStack)):
                                            ops_result3 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                            def _hx_local_0():
                                                _hx_local_139 = ops_result3
                                                if (Std._hx_is(_hx_local_139,Int) or ((_hx_local_139 is None))):
                                                    _hx_local_139
                                                else:
                                                    raise _HxException("Class cast error")
                                                return _hx_local_139
                                            if (_hx_local_0() < 0):
                                                self.intp_return_result = ops_result3
                                                break
                                        if (0 < len(self.assignStack)):
                                            _this39 = self.assignStack
                                            r_idx = (None if ((len(_this39) == 0)) else _this39.pop())
                                            assign_op = (self.runStack[r_idx] if r_idx >= 0 and r_idx < len(self.runStack) else None).token_op_means
                                            self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns,assign_op)
                                        num_to_do1 = 0
                                        if (0 < len(self.old_opStackFrames)):
                                            _this40 = self.old_opStackFrames
                                            num_to_do1 = (None if ((len(_this40) == 0)) else _this40.pop())
                                        while (0 < num_to_do1):
                                            _this41 = self.opStack
                                            _this42 = self.old_opStack
                                            x21 = (None if ((len(_this42) == 0)) else _this42.pop())
                                            _this41.insert(0, x21)
                                            num_to_do1 = (num_to_do1 - 1)
                                        num_to_do1 = 0
                                        if (0 < len(self.old_dataStackFrames)):
                                            _this43 = self.old_dataStackFrames
                                            num_to_do1 = (None if ((len(_this43) == 0)) else _this43.pop())
                                        while (0 < num_to_do1):
                                            _this44 = self.dataStack
                                            _this45 = self.old_dataStack
                                            x22 = (None if ((len(_this45) == 0)) else _this45.pop())
                                            _this44.insert(0, x22)
                                            num_to_do1 = (num_to_do1 - 1)
                                        if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                            ip = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                            _hx_local_142 = self
                                            _hx_local_143 = _hx_local_142.steps_done
                                            _hx_local_142.steps_done = (_hx_local_143 + 1)
                                            _hx_local_143
                                            continue
                                        if (0.0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float):
                                            ip = (ip + Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float))
                                            _hx_local_145 = self
                                            _hx_local_146 = _hx_local_145.steps_done
                                            _hx_local_145.steps_done = (_hx_local_146 + 1)
                                            _hx_local_146
                                            continue
                                else:
                                    #   Any Operator that is Not Punctuation is pushed                                   ")
                                    _this46 = self.opStack
                                    _this46.append(ip)
                                    if self.show_stacks:
                                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                                    ops_result4 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    def _hx_local_0():
                                        _hx_local_147 = ops_result4
                                        if (Std._hx_is(_hx_local_147,Int) or ((_hx_local_147 is None))):
                                            _hx_local_147
                                        else:
                                            raise _HxException("Class cast error")
                                        return _hx_local_147
                                    if (_hx_local_0() < 0):
                                        self.intp_return_result = ops_result4
                                        break
                            _hx_local_148 = self
                            _hx_local_149 = _hx_local_148.steps_done
                            _hx_local_148.steps_done = (_hx_local_149 + 1)
                            _hx_local_149
                            ip = (ip + 1)
                            continue
                    verb_pending = False
                    if (((4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        verb_pending = True
                        if (0 < len(self.opStack)):
                            apply_op = True
                            ip = (ip - 1)
                    if apply_op:
                        if (0 < len(self.opStack)):
                            ops_result5 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                            def _hx_local_0():
                                _hx_local_152 = ops_result5
                                if (Std._hx_is(_hx_local_152,Int) or ((_hx_local_152 is None))):
                                    _hx_local_152
                                else:
                                    raise _HxException("Class cast error")
                                return _hx_local_152
                            if (_hx_local_0() < 0):
                                self.intp_return_result = ops_result5
                                break
                            ip = (ip + 1)
                            continue
                    if (((4 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) and ((3 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        ip = (ip + 1)
                        continue
                    if (self.show_details and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        forGL_ForGL_ui.msg((("\n   running Verb   " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                        _hx_local_155 = self
                        _hx_local_156 = _hx_local_155.run_text_line
                        _hx_local_155.run_text_line = (_hx_local_156 + 1)
                        _hx_local_156
                        _hx_local_157 = self
                        _hx_local_158 = _hx_local_157.run_text_line
                        _hx_local_157.run_text_line = (_hx_local_158 + 1)
                        _hx_local_158
                    if (4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        #                                                                                    ")
                        #    Run a Verb defined in the Dictionary                                            ")
                        verb_text = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str
                        if (0 == ((0 if ((verb_text is None)) else len(verb_text)))):
                            ip = (ip + 1)
                            continue
                        verb_tokens = self.nl_Parse.parse(verb_text,forGL_ParseStyle.PARSE_EURO,False)
                        if (0 == len(verb_tokens)):
                            ip = (ip + 1)
                            continue
                        #                                                                                    ")
                        #  Save only Noun values to Dictionary (Not Local Nouns)                             ")
                        #                                                                                    ")
                        self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                        old_length = len(self.runStack)
                        #                                                                                    ")
                        #  ADD more structures AT THE END of existing Run Stack.                             ")
                        #     ? THIS TRIES TO AVOID EXCESSIVE RESOURCE USE ?                                 ")
                        #                                                                                    ")
                        _hx_local_161 = self
                        _hx_local_162 = _hx_local_161.run_text_line
                        _hx_local_161.run_text_line = (_hx_local_162 + self.nl_Parse.resolveTokens(verb_tokens,self.nlDict,self.runStack,self.run_verbose))
                        _hx_local_161.run_text_line
                        self.repeat_found = self.nl_Parse.repeat_verb_found
                        if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                            forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not same.\n"))
                            _hx_local_163 = self
                            _hx_local_164 = _hx_local_163.run_text_line
                            _hx_local_163.run_text_line = (_hx_local_164 + 1)
                            _hx_local_164
                            _hx_local_165 = self
                            _hx_local_166 = _hx_local_165.run_text_line
                            _hx_local_165.run_text_line = (_hx_local_166 + 1)
                            _hx_local_166
                        self.nl_Parse.resolveAssigns(self.runStack)
                        choice_result1 = -11
                        if self.export_as_code:
                            export_runStack1 = self.nl_Parse.refactorForExport(self.runStack)
                            choice_result1 = self.nl_Parse.resolveChoice(export_runStack1)
                            self.runStack = export_runStack1
                        else:
                            choice_result1 = self.nl_Parse.resolveChoice(self.runStack)
                        def _hx_local_0():
                            _hx_local_167 = choice_result1
                            if (Std._hx_is(_hx_local_167,Int) or ((_hx_local_167 is None))):
                                _hx_local_167
                            else:
                                raise _HxException("Class cast error")
                            return _hx_local_167
                        if (0 > _hx_local_0()):
                            self.intp_return_result = choice_result1
                            break
                        if (((self.show_words_table or self.export_as_code)) and ((0 < len(self.runStack)))):
                            _hx_local_168 = self
                            _hx_local_169 = _hx_local_168.run_text_line
                            _hx_local_168.run_text_line = (_hx_local_169 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,self.export_as_code))
                            _hx_local_168.run_text_line
                        if self.export_as_code:
                            j = 0
                            exp_text = ""
                            while (j < len(self.runStack)):
                                str1 = ""
                                if self.display_internal:
                                    str1 = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).internal_token
                                    if ("" == str1):
                                        str1 = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                                else:
                                    str1 = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                                exp_text = (("null" if exp_text is None else exp_text) + HxOverrides.stringOrNull(((("null" if str1 is None else str1) + " "))))
                                j = (j + 1)
                            _this47 = self.export_as_code_log
                            _this47.append(exp_text)
                        #                                                                                    ")
                        #  ADD a structure so after the Verb to be called is done,                           ")
                        #  we can resume running in the original Verb after this called Verb.                ")
                        #                                                                                    ")
                        _this48 = self.runStack
                        x23 = forGL_NLToken()
                        _this48.append(x23)
                        rIdx = (len(self.runStack) - 1)
                        new_length = len(self.runStack)
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_type = 5
                        #                                                                                    ")
                        #  Return placeholder ONLY Slightly Visible by seeing an extra blank space           ")
                        #                                                                                    ")
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).internal_token = " "
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).visible_token = " "
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_int = (ip + 1)
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_float = (new_length - old_length)
                        _this49 = self.old_assignStackFrames
                        x24 = len(self.assignStack)
                        _this49.append(x24)
                        while (0 < len(self.assignStack)):
                            _this50 = self.old_assignStack
                            _this51 = self.assignStack
                            x25 = (None if ((len(_this51) == 0)) else _this51.pop(0))
                            _this50.append(x25)
                        _this52 = self.old_nounStackFrames
                        x26 = len(self.nouns)
                        _this52.append(x26)
                        while (0 < len(self.nouns)):
                            _this53 = self.old_nounStack
                            _this54 = self.nouns
                            x27 = (None if ((len(_this54) == 0)) else _this54.pop(0))
                            _this53.append(x27)
                        _this55 = self.old_opStackFrames
                        x28 = len(self.opStack)
                        _this55.append(x28)
                        while (0 < len(self.opStack)):
                            _this56 = self.old_opStack
                            _this57 = self.opStack
                            x29 = (None if ((len(_this57) == 0)) else _this57.pop(0))
                            _this56.append(x29)
                        ip = old_length
                        continue
                    elif (5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        #                                                                                    ")
                        #  Save only Noun values to Dictionary (Not Local Nouns)                             ")
                        #                                                                                    ")
                        self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                        #                                                                                    ")
                        #  EMPTY the Nouns Stack                                                             ")
                        #                                                                                    ")
                        num_to_do2 = len(self.nouns)
                        while (0 < num_to_do2):
                            _this58 = self.nouns
                            if (len(_this58) != 0):
                                _this58.pop()
                            num_to_do2 = (num_to_do2 - 1)
                        #  Restore 1 Frame of old underneath (at Bottom of) Assign, Noun, Operator and Data stacks  ")
                        num_to_do2 = 0
                        if (0 < len(self.old_assignStackFrames)):
                            _this59 = self.old_assignStackFrames
                            num_to_do2 = (None if ((len(_this59) == 0)) else _this59.pop())
                        while (0 < num_to_do2):
                            _this60 = self.assignStack
                            _this61 = self.old_assignStack
                            x30 = (None if ((len(_this61) == 0)) else _this61.pop())
                            _this60.insert(0, x30)
                            num_to_do2 = (num_to_do2 - 1)
                        num_to_do2 = 0
                        if (0 < len(self.old_nounStackFrames)):
                            _this62 = self.old_nounStackFrames
                            num_to_do2 = (None if ((len(_this62) == 0)) else _this62.pop())
                        while (0 < num_to_do2):
                            _this63 = self.nouns
                            _this64 = self.old_nounStack
                            x31 = (None if ((len(_this64) == 0)) else _this64.pop())
                            _this63.insert(0, x31)
                            num_to_do2 = (num_to_do2 - 1)
                        num_to_do2 = 0
                        if (0 < len(self.old_opStackFrames)):
                            _this65 = self.old_opStackFrames
                            num_to_do2 = (None if ((len(_this65) == 0)) else _this65.pop())
                        while (0 < num_to_do2):
                            _this66 = self.opStack
                            _this67 = self.old_opStack
                            x32 = (None if ((len(_this67) == 0)) else _this67.pop())
                            _this66.insert(0, x32)
                            num_to_do2 = (num_to_do2 - 1)
                        new_ip = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int
                        num_to_remove = Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float)
                        num_to_do2 = num_to_remove
                        while (0 < num_to_do2):
                            _this68 = self.runStack
                            if (len(_this68) != 0):
                                _this68.pop()
                            num_to_do2 = (num_to_do2 - 1)
                        #   Update Noun values from Dictionary (Not Local Nouns)                             ")
                        self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns)
                        if ((len(self.runStack) - 1) < new_ip):
                            break
                        ip = new_ip
                        continue
                    elif (3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        #                                                                                    ")
                        #      Built In  VERB                                                                ")
                        #                                                                                    ")
                        if ("repeat" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                            #                                                                                    ")
                            #      Repeat built in: Need to set up Limit for number of Repeats ?                 ")
                            #                                                                                    ")
                            if (self.repeat_limit < 0):
                                if (0 < len(self.dataStack)):
                                    repeat_data_type = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                                    if (9 == repeat_data_type):
                                        if (0 <= python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int):
                                            self.repeat_limit_found = True
                                            self.repeat_limit = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                if (self.repeat_limit < 0):
                                    self.repeat_limit = 0
                            _hx_local_177 = self
                            _hx_local_178 = _hx_local_177.repeat_count
                            _hx_local_177.repeat_count = (_hx_local_178 + 1)
                            _hx_local_178
                            if (self.repeat_count <= self.repeat_limit):
                                if self.repeat_limit_found:
                                    _this69 = self.dataStack
                                    if (len(_this69) != 0):
                                        _this69.pop()
                                #                                                                                    ")
                                #      MUST Reset  all LOCAL Nouns to UNKNOWN in Run stack                           ")
                                #      MUST Remove all LOCAL Nouns in Noun stack                                     ")
                                #                                                                                    ")
                                i1 = (len(self.nouns) - 1)
                                while (0 <= i1):
                                    nounIdx = (self.nouns[i1] if i1 >= 0 and i1 < len(self.nouns) else None)
                                    if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                                        (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type = 0
                                        python_internal_ArrayImpl.remove(self.nouns,nounIdx)
                                    i1 = (i1 - 1)
                                if (0 < len(self.nouns)):
                                    if self.show_stacks:
                                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                                if (0 < len(self.opStack)):
                                    forGL_ForGL_ui.warning((("WARNING: Doing Repeat with leftover Operators: " + Std.string(self.opStackToString(self.runStack,self.opStack))) + "\n"))
                                    _hx_local_180 = self
                                    _hx_local_181 = _hx_local_180.run_text_line
                                    _hx_local_180.run_text_line = (_hx_local_181 + 1)
                                    _hx_local_181
                                forGL_ForGL_ui.msg("\r")
                                forGL_ForGL_ui.msg((Std.string(self.repeat_count) + "\t"))
                                ip = 0
                                continue
                            elif self.repeat_limit_found:
                                _this70 = self.dataStack
                                if (len(_this70) != 0):
                                    _this70.pop()
                        elif (("show" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                            #                                                                                    ")
                            #      Show or View what is on the Data stack                                        ")
                            #  Show removes 1 item.                                                              ")
                            #                                                                                    ")
                            #      View will display all items without removal. Handy for User Debugging         ")
                            #                                                                                    ")
                            #  Note: View is specific to forGL and not for Export as Code                        ")
                            #                                                                                    ")
                            showing = True
                            if ("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                                showing = False
                                forGL_ForGL_ui.msg("\n        Data  Stack\n")
                                _hx_local_182 = self
                                _hx_local_183 = _hx_local_182.run_text_line
                                _hx_local_182.run_text_line = (_hx_local_183 + 1)
                                _hx_local_183
                                _hx_local_184 = self
                                _hx_local_185 = _hx_local_184.run_text_line
                                _hx_local_184.run_text_line = (_hx_local_185 + 1)
                                _hx_local_185
                            i1 = (len(self.dataStack) - 1)
                            while (i1 >= 0):
                                dataIdx1 = i1
                                dataStr = ""
                                if (9 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int)
                                elif (10 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = "false"
                                    if (1 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int):
                                        dataStr = "true"
                                elif (11 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_float)
                                elif (8 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                    if showing:
                                        dataStr = self.trimQuotes(dataStr)
                                else:
                                    forGL_ForGL_ui.error(" \nINTERNAL ERROR: Data not Float, Integer, Bool or String\n")
                                    _hx_local_186 = self
                                    _hx_local_187 = _hx_local_186.run_text_line
                                    _hx_local_186.run_text_line = (_hx_local_187 + 1)
                                    _hx_local_187
                                    _hx_local_188 = self
                                    _hx_local_189 = _hx_local_188.run_text_line
                                    _hx_local_188.run_text_line = (_hx_local_189 + 1)
                                    _hx_local_189
                                    i1 = (i1 - 1)
                                    continue
                                if showing:
                                    if (0 < ((0 if ((dataStr is None)) else len(dataStr)))):
                                        self.show1Data(dataStr,self.show_text_line)
                                    if self.export_as_code:
                                        exp = dataStr
                                        #  Use Noun name if available for Export                                             ")
                                        tmp = None
                                        if (8 != (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                            this1 = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                            tmp = (0 < ((0 if ((this1 is None)) else len(this1))))
                                        else:
                                            tmp = False
                                        if tmp:
                                            exp = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                        _this71 = self.export_as_code_log
                                        _this71.append((("show ( " + ("null" if exp is None else exp)) + " )"))
                                    _this72 = self.dataStack
                                    if (len(_this72) != 0):
                                        _this72.pop()
                                    break
                                else:
                                    forGL_ForGL_ui.msg((("null" if dataStr is None else dataStr) + "\n"))
                                    _hx_local_191 = self
                                    _hx_local_192 = _hx_local_191.run_text_line
                                    _hx_local_191.run_text_line = (_hx_local_192 + 1)
                                    _hx_local_192
                                i1 = (i1 - 1)
                    ip = (ip + 1)
                #                                                                                    ")
                #      END  OF  INTERPRETER  LOOP                                                    ")
                #                                                                                    ")
                self.intp_ip = ip
                forGL_ForGL_ui.outputBuffersUsed()
                if (self.intp_ip >= len(self.runStack)):
                    break
                def _hx_local_0():
                    _hx_local_195 = self.intp_return_result
                    if (Std._hx_is(_hx_local_195,Int) or ((_hx_local_195 is None))):
                        _hx_local_195
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_195
                if (0 != _hx_local_0()):
                    break
            ret_val = self.runDef_End()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in runDef(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def runDef_End(self):
        #                                                                                    ")
        #  Do some checks, messages, and clean up after a Verb and Verbs it uses is Run      ")
        #                                                                                    ")
        ret_val = self.intp_return_result
        forGL_ForGL_ui.msg("\n   Finished. No more Natural Language words to process.\n")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.run_text_line
        _hx_local_0.run_text_line = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.run_text_line
        _hx_local_2.run_text_line = (_hx_local_3 + 1)
        _hx_local_3
        self.show_stacks_Data_Only = False
        if self.show_stacks:
            self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line,True)
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.run_text_line,True)
            forGL_ForGL_ui.msg("\n\n\n")
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 3)
            _hx_local_6.run_text_line
        forGL_ForGL_ui.goToPos(self.run_text_line,0)
        if (len(self.dataStack) > 0):
            data_count = len(self.dataStack)
            if (data_count > 1):
                message = (("There are " + Std.string(data_count)) + " Data items.\n")
                message = (("null" if message is None else message) + "You can use the Show built in Verb to take 1 item off the stack and Show it.\n")
                message = (("null" if message is None else message) + "You can use the View built in Verb to View all the stacks with no changes.\n")
                forGL_ForGL_ui.msg(message)
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.run_text_line
                _hx_local_10.run_text_line = (_hx_local_11 + 1)
                _hx_local_11
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.run_text_line
                _hx_local_12.run_text_line = (_hx_local_13 + 1)
                _hx_local_13
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.run_text_line
                _hx_local_14.run_text_line = (_hx_local_15 + 1)
                _hx_local_15
        if (len(self.nouns) > 0):
            nounIdx = python_internal_ArrayImpl._get(self.nouns, (len(self.nouns) - 1))
            if self.display_internal:
                forGL_ForGL_ui.msg((Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).internal_token) + " "),forGL_ForGL_ui.NOUN_COLOR)
            else:
                forGL_ForGL_ui.msg((Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token) + " "),forGL_ForGL_ui.NOUN_COLOR)
            forGL_ForGL_ui.msg((("is " + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_noun_data))) + " "))
            _g = (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_noun_data
            if (_g == 0):
                if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                    forGL_ForGL_ui.warning((("\nWARNING: Local Noun  " + Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token)) + "  had no value. Likely not used?"))
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.run_text_line
                    _hx_local_16.run_text_line = (_hx_local_17 + 1)
                    _hx_local_17
                elif (6 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                    forGL_ForGL_ui.error((("\nINTERNAL ERROR: Noun  " + Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token)) + "  data is unknown."))
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.run_text_line
                    _hx_local_18.run_text_line = (_hx_local_19 + 1)
                    _hx_local_19
            elif (_g == 8):
                forGL_ForGL_ui.msg((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_str,forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 9):
                forGL_ForGL_ui.msg(Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_int),forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 10):
                if (1 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_int):
                    forGL_ForGL_ui.msg("true",forGL_ForGL_ui.DATA_COLOR)
                else:
                    forGL_ForGL_ui.msg("false",forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 11):
                forGL_ForGL_ui.msg(Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_float),forGL_ForGL_ui.DATA_COLOR)
            else:
                forGL_ForGL_ui.error("\nINTERNAL ERROR: Wrong type of Noun data")
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.run_text_line
                _hx_local_20.run_text_line = (_hx_local_21 + 1)
                _hx_local_21
            forGL_ForGL_ui.msg("\n")
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.run_text_line
            _hx_local_22.run_text_line = (_hx_local_23 + 1)
            _hx_local_23
        if (0 < len(self.opStack)):
            forGL_ForGL_ui.msg((("\n   There are " + Std.string(len(self.opStack))) + " Operations not done.\n"))
            forGL_ForGL_ui.msg("This usually indicates a logical problem with the Verb (code).\n")
            forGL_ForGL_ui.msg("If you have gotten any ERRORS or WARNINGS those will guide you.")
        end_intp_time = (python_lib_Time.mktime(Date.now().date.timetuple()) * 1000)
        self.elapsed_intp_time = (((end_intp_time - self.start_intp_time)) / 1000.0)
        elapsed = Math.floor((self.elapsed_intp_time * 1000.0))
        self.elapsed_intp_time = (elapsed / 1000.0)
        forGL_ForGL_ui.msg((((((("  ... Elapsed       Run time " + Std.string(self.elapsed_intp_time)) + " Seconds of ") + Std.string(self.steps_done)) + " Internal and ") + Std.string(self.steps_done_Verb)) + " Verb steps.\n"))
        return ret_val

    def runInterpreter(self):
        #      I N T E R P R E T E R         LOOP                                            ")
        apply_op = False
        i = 0
        ip = self.intp_ip
        while (ip < len(self.runStack)):
            if self.single_step:
                char_code = Sys.getChar(False)
                if (27 == char_code):
                    self.single_step = False
                    char_code = Sys.getChar(False)
                else:
                    if ((48 <= char_code) and ((char_code <= 57))):
                        self.delay_seconds = (char_code - 48)
                    char_code = Sys.getChar(False)
            elif (0.0 < self.delay_seconds):
                Sys.sleep(self.delay_seconds)
            else:
                self.view_DON_throttle = True
            if (self.single_step or self.show_stacks):
                #  Display latest Interpreter values                                                 ")
                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
            if (12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                if (((((("if" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("for" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("switch" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("while" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("else" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("return" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.steps_done
                    _hx_local_0.steps_done = (_hx_local_1 + 1)
                    _hx_local_1
                    ip = (ip + 1)
                    continue
            if ((((9 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((10 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((11 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((8 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                #      DATA item. Put on Data stack                                                  ")
                _this = self.dataStack
                x = forGL_DataItem((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int)
                _this.append(x)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.steps_done
                _hx_local_3.steps_done = (_hx_local_4 + 1)
                _hx_local_4
                ip = (ip + 1)
                continue
            if (((6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((7 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                #      NOUNS are Named references to Data                                            ")
                #    Search for a Noun name (internal token) in Noun stack                           ")
                name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                if (0 == ((0 if ((name_to_find is None)) else len(name_to_find)))):
                    forGL_ForGL_ui.error((("INTERNAL ERROR: Internal Name of Noun " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)) + " is missing\n"))
                    _hx_local_6 = self
                    _hx_local_7 = _hx_local_6.run_text_line
                    _hx_local_6.run_text_line = (_hx_local_7 + 1)
                    _hx_local_7
                    name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                nounsIdx = 0
                runIdx = 0
                already_known = False
                while (nounsIdx < len(self.nouns)):
                    runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                    if (name_to_find == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token):
                        already_known = True
                        break
                    nounsIdx = (nounsIdx + 1)
                local_inference = False
                if ((not already_known) and ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                    local_inference = True
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type = 7
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_noun_data = 0
                if (False == already_known):
                    #    add NOUN or LOCAL NOUN as NEWEST                                                ")
                    _this1 = self.nouns
                    _this1.append(ip)
                    if (6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns,True)
                    nounsIdx = (len(self.nouns) - 1)
                    runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                    if self.show_stacks:
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                if (not local_inference):
                    if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                        if (0 < len(self.opStack)):
                            self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                        if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                            name = ""
                            if self.display_internal:
                                name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                            else:
                                name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                            if (0 < len(self.assignStack)):
                                message = (("\nSyntax WARNING:  " + ("null" if name is None else name)) + "  used with no value. ")
                                message = (("null" if message is None else message) + "Punctuation is missing so no assignment.\n")
                                message = (("null" if message is None else message) + "Please add Punctuation.\n")
                                message = (("null" if message is None else message) + "Assignment done anyway to help.\n")
                                forGL_ForGL_ui.warning(message)
                                _hx_local_12 = self
                                _hx_local_13 = _hx_local_12.run_text_line
                                _hx_local_12.run_text_line = (_hx_local_13 + 1)
                                _hx_local_13
                                _hx_local_14 = self
                                _hx_local_15 = _hx_local_14.run_text_line
                                _hx_local_14.run_text_line = (_hx_local_15 + 1)
                                _hx_local_15
                                _hx_local_16 = self
                                _hx_local_17 = _hx_local_16.run_text_line
                                _hx_local_16.run_text_line = (_hx_local_17 + 1)
                                _hx_local_17
                                _hx_local_18 = self
                                _hx_local_19 = _hx_local_18.run_text_line
                                _hx_local_18.run_text_line = (_hx_local_19 + 1)
                                _hx_local_19
                                _this2 = self.assignStack
                                if (len(_this2) != 0):
                                    _this2.pop()
                                self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                            else:
                                message1 = (("\nSyntax ERROR:  " + ("null" if name is None else name)) + "  used with no value. = (assignment) is missing.\n")
                                message1 = (("null" if message1 is None else message1) + "Or a Verb was spelled wrong and a loop may not end !\n")
                                message1 = (("null" if message1 is None else message1) + "Please fix spelling OR add = with Punctuation at end.\n")
                                message1 = (("null" if message1 is None else message1) + "Now trying as local Noun and assignment anyway to help.\n")
                                forGL_ForGL_ui.error(message1)
                                _hx_local_23 = self
                                _hx_local_24 = _hx_local_23.run_text_line
                                _hx_local_23.run_text_line = (_hx_local_24 + 1)
                                _hx_local_24
                                _hx_local_25 = self
                                _hx_local_26 = _hx_local_25.run_text_line
                                _hx_local_25.run_text_line = (_hx_local_26 + 1)
                                _hx_local_26
                                _hx_local_27 = self
                                _hx_local_28 = _hx_local_27.run_text_line
                                _hx_local_27.run_text_line = (_hx_local_28 + 1)
                                _hx_local_28
                                _hx_local_29 = self
                                _hx_local_30 = _hx_local_29.run_text_line
                                _hx_local_29.run_text_line = (_hx_local_30 + 1)
                                _hx_local_30
                                _hx_local_31 = self
                                _hx_local_32 = _hx_local_31.run_text_line
                                _hx_local_31.run_text_line = (_hx_local_32 + 1)
                                _hx_local_32
                                self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                            if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                if (0 < len(self.dataStack)):
                                    dataIdx = (len(self.dataStack) - 1)
                                    data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int
                                    if (9 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                        data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int)
                                    elif (10 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                        if (1 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int):
                                            data = "true"
                                        else:
                                            data = "false"
                                    else:
                                        data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float)
                                    _this3 = self.dataStack
                                    if (len(_this3) != 0):
                                        _this3.pop()
                                    forGL_ForGL_ui.warning((((((("\nSyntax WARNING:  " + ("null" if name is None else name)) + " used without a value.  GUESSING: ") + ("null" if name is None else name)) + " = ") + Std.string(data)) + " .\n"))
                                    _hx_local_33 = self
                                    _hx_local_34 = _hx_local_33.run_text_line
                                    _hx_local_33.run_text_line = (_hx_local_34 + 1)
                                    _hx_local_34
                                    _hx_local_35 = self
                                    _hx_local_36 = _hx_local_35.run_text_line
                                    _hx_local_35.run_text_line = (_hx_local_36 + 1)
                                    _hx_local_36
                                else:
                                    message2 = (((("\nSyntax ERROR:  " + ("null" if name is None else name)) + " used without a value. Suggest ") + ("null" if name is None else name)) + " = your_data .  Stopping.\n")
                                    forGL_ForGL_ui.error(message2,1)
                                    _hx_local_37 = self
                                    _hx_local_38 = _hx_local_37.run_text_line
                                    _hx_local_37.run_text_line = (_hx_local_38 + 1)
                                    _hx_local_38
                                    _hx_local_39 = self
                                    _hx_local_40 = _hx_local_39.run_text_line
                                    _hx_local_39.run_text_line = (_hx_local_40 + 1)
                                    _hx_local_40
                                    self.intp_return_result = -4
                                    break
                    if (not (((((ip + 1) < ((len(self.runStack) - 1))) and ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((34 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))))):
                        if (8 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                            _this4 = self.dataStack
                            x1 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                            _this4.append(x1)
                        else:
                            name1 = ""
                            if self.display_internal:
                                name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                            else:
                                name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                            _this5 = self.dataStack
                            x2 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,name1,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                            _this5.append(x2)
                _hx_local_41 = self
                _hx_local_42 = _hx_local_41.steps_done
                _hx_local_41.steps_done = (_hx_local_42 + 1)
                _hx_local_42
                ip = (ip + 1)
                continue
            apply_op = False
            if (2 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                #    OPERATORS and VERBS                                                             ")
                op_to_do = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_op_means
                #    Check for Punctuation. Punctuation is never pushed on Operator stack.           ")
                if ((((45 == op_to_do) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                    apply_op = True
                    if self.show_stacks:
                        if self.show_details:
                            forGL_ForGL_ui.msg((("   running Punctuation  " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                            _hx_local_44 = self
                            _hx_local_45 = _hx_local_44.run_text_line
                            _hx_local_44.run_text_line = (_hx_local_45 + 1)
                            _hx_local_45
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                    if (0 < len(self.assignStack)):
                        _this6 = self.opStack
                        _this7 = self.assignStack
                        x3 = (None if ((len(_this7) == 0)) else _this7.pop())
                        _this6.insert(0, x3)
                    if (0 < len(self.opStack)):
                        ops_result = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                        def _hx_local_0():
                            _hx_local_46 = ops_result
                            if (Std._hx_is(_hx_local_46,Int) or ((_hx_local_46 is None))):
                                _hx_local_46
                            else:
                                raise _HxException("Class cast error")
                            return _hx_local_46
                        if (_hx_local_0() < 0):
                            self.intp_return_result = ops_result
                            break
                else:
                    #    Not Punctuation                                                                 ")
                    if (((32 == op_to_do) or ((33 == op_to_do))) or ((34 == op_to_do))):
                        if (33 == op_to_do):
                            #   Special Case: We know Assign To has only 1 destination after it.                 ")
                            if (((7 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((6 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                forGL_ForGL_ui.error("SYNTAX ERROR: Noun or local Noun must follow Assign into. Stopping\n")
                                _hx_local_47 = self
                                _hx_local_48 = _hx_local_47.run_text_line
                                _hx_local_47.run_text_line = (_hx_local_48 + 1)
                                _hx_local_48
                                self.intp_return_result = -4
                                break
                            if (0 == len(self.dataStack)):
                                #   Try running pending Operators                                                    ")
                                if (0 == len(self.opStack)):
                                    forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available and nothing to make data. Stopping\n")
                                    _hx_local_49 = self
                                    _hx_local_50 = _hx_local_49.run_text_line
                                    _hx_local_49.run_text_line = (_hx_local_50 + 1)
                                    _hx_local_50
                                    self.intp_return_result = -4
                                    break
                                self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                if (0 == len(self.dataStack)):
                                    forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available. Stopping\n")
                                    _hx_local_51 = self
                                    _hx_local_52 = _hx_local_51.run_text_line
                                    _hx_local_51.run_text_line = (_hx_local_52 + 1)
                                    _hx_local_52
                                    self.intp_return_result = -4
                                    break
                            if (0 < len(self.opStack)):
                                self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                            #    Find first reference in the Nouns stack                                         ")
                            assign_idx = (ip + 1)
                            name_to_find1 = python_internal_ArrayImpl._get(self.runStack, (ip + 1)).internal_token
                            nounsIdx1 = 0
                            runIdx1 = 0
                            already_known1 = False
                            while (nounsIdx1 < len(self.nouns)):
                                runIdx1 = (self.nouns[nounsIdx1] if nounsIdx1 >= 0 and nounsIdx1 < len(self.nouns) else None)
                                if (name_to_find1 == (self.runStack[runIdx1] if runIdx1 >= 0 and runIdx1 < len(self.runStack) else None).internal_token):
                                    already_known1 = True
                                    assign_idx = runIdx1
                                    break
                                nounsIdx1 = (nounsIdx1 + 1)
                            if ((not already_known1) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                _this8 = self.nouns
                                _this8.append((ip + 1))
                            #   Assign into following Noun or Local Noun (using Noun stack reference index)      ")
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_noun_data = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_str = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_str
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_float = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_float
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_int = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                            _this9 = self.dataStack
                            if (len(_this9) != 0):
                                _this9.pop()
                            if (0 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type):
                                if ((ip + 1) == assign_idx):
                                    python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type = 7
                                    _this10 = self.nouns
                                    _this10.append((ip + 1))
                            if (2 == python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_type):
                                #   If Punctuation then skip it as well.                                             ")
                                next_op = python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_op_means
                                if ((((45 == next_op) or ((46 == next_op))) or ((47 == next_op))) or ((48 == next_op))):
                                    ip = (ip + 3)
                                else:
                                    ip = (ip + 2)
                            else:
                                ip = (ip + 2)
                            _hx_local_57 = self
                            _hx_local_58 = _hx_local_57.steps_done
                            _hx_local_57.steps_done = (_hx_local_58 + 1)
                            _hx_local_58
                            continue
                        else:
                            #   Assign From and Assignment are deferred until punctuation is hit.                ")
                            _this11 = self.assignStack
                            _this11.append(ip)
                            ip = (ip + 1)
                            continue
                    elif (30 == op_to_do):
                        result = Math.PI
                        _this12 = self.dataStack
                        x4 = forGL_DataItem(11,"",result,0)
                        _this12.append(x4)
                        _hx_local_60 = self
                        _hx_local_61 = _hx_local_60.steps_done
                        _hx_local_60.steps_done = (_hx_local_61 + 1)
                        _hx_local_61
                        ip = (ip + 1)
                        continue
                    elif (31 == op_to_do):
                        result1 = python_lib_Random.random()
                        _this13 = self.dataStack
                        x5 = forGL_DataItem(11,"",result1,0)
                        _this13.append(x5)
                        _hx_local_63 = self
                        _hx_local_64 = _hx_local_63.steps_done
                        _hx_local_63.steps_done = (_hx_local_64 + 1)
                        _hx_local_64
                        ip = (ip + 1)
                        continue
                    elif ((18 == op_to_do) or ((19 == op_to_do))):
                        if (18 == op_to_do):
                            #   Entering an expression to evaluate.                                              ")
                            _this14 = self.old_opStackFrames
                            x6 = len(self.opStack)
                            _this14.append(x6)
                            while (0 < len(self.opStack)):
                                _this15 = self.old_opStack
                                _this16 = self.opStack
                                x7 = (None if ((len(_this16) == 0)) else _this16.pop(0))
                                _this15.append(x7)
                            _this17 = self.old_dataStackFrames
                            x8 = len(self.dataStack)
                            _this17.append(x8)
                            while (0 < len(self.dataStack)):
                                _this18 = self.old_dataStack
                                _this19 = self.dataStack
                                x9 = (None if ((len(_this19) == 0)) else _this19.pop(0))
                                _this18.append(x9)
                        else:
                            #  Leaving an Expression that was evaluated.                                         ")
                            #  Make sure everything was evaluated.                                               ")
                            #  Within a single group to evaluate                                                 ")
                            #  there is no starting Operator or Data stack values.                               ")
                            #  This means if there are any Operators to do then do them now.                     ")
                            if (0 < len(self.opStack)):
                                ops_result1 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                def _hx_local_0():
                                    _hx_local_66 = ops_result1
                                    if (Std._hx_is(_hx_local_66,Int) or ((_hx_local_66 is None))):
                                        _hx_local_66
                                    else:
                                        raise _HxException("Class cast error")
                                    return _hx_local_66
                                if (_hx_local_0() < 0):
                                    self.intp_return_result = ops_result1
                                    break
                            #                                                                                    ")
                            #  Restore 1 Frame of old underneath (at Bottom of) Operator and Data stacks         ")
                            #                                                                                    ")
                            num_to_do = 0
                            if (0 < len(self.old_opStackFrames)):
                                _this20 = self.old_opStackFrames
                                num_to_do = (None if ((len(_this20) == 0)) else _this20.pop())
                            while (0 < num_to_do):
                                _this21 = self.opStack
                                _this22 = self.old_opStack
                                x10 = (None if ((len(_this22) == 0)) else _this22.pop())
                                _this21.insert(0, x10)
                                num_to_do = (num_to_do - 1)
                            num_to_do = 0
                            if (0 < len(self.old_dataStackFrames)):
                                _this23 = self.old_dataStackFrames
                                num_to_do = (None if ((len(_this23) == 0)) else _this23.pop())
                            while (0 < num_to_do):
                                _this24 = self.dataStack
                                _this25 = self.old_dataStack
                                x11 = (None if ((len(_this25) == 0)) else _this25.pop())
                                _this24.insert(0, x11)
                                num_to_do = (num_to_do - 1)
                            if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                #                                                                                    ")
                                #  There is an indication of a Choice word before this Expression                    ")
                                #                                                                                    ")
                                choice_idx = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                choice_name = (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).internal_token
                                if (12 == (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_type):
                                    if (((("for" == choice_name) or (("if" == choice_name))) or (("switch" == choice_name))) or (("while" == choice_name))):
                                        if (("if" == choice_name) or (("while" == choice_name))):
                                            #   Must be a Bool on the top of Data stack. Error if not.                           ")
                                            if ((0 == len(self.dataStack)) or ((10 != python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type))):
                                                forGL_ForGL_ui.error((("SYNTAX ERROR: " + Std.string(choice_name)) + " expression result is not Bool. Stopping.\n"))
                                                _hx_local_69 = self
                                                _hx_local_70 = _hx_local_69.run_text_line
                                                _hx_local_69.run_text_line = (_hx_local_70 + 1)
                                                _hx_local_70
                                                forGL_ForGL_ui.msg((("Error location (word number) is " + Std.string(ip)) + "\n"))
                                                _hx_local_71 = self
                                                _hx_local_72 = _hx_local_71.run_text_line
                                                _hx_local_71.run_text_line = (_hx_local_72 + 1)
                                                _hx_local_72
                                                _hx_local_73 = self
                                                _hx_local_74 = _hx_local_73.run_text_line
                                                _hx_local_73.run_text_line = (_hx_local_74 + self.nl_Parse.showWordsTable(self.runStack,True,True,False))
                                                _hx_local_73.run_text_line
                                                self.intp_return_result = -4
                                                break
                                            exp_bool = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                            _this26 = self.dataStack
                                            if (len(_this26) != 0):
                                                _this26.pop()
                                            if (1 == exp_bool):
                                                ip = (ip + 1)
                                                continue
                                            else:
                                                ip = (Math.floor((self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_float) + 1)
                                                continue
                                        else:
                                            forGL_ForGL_ui.error((("INTERNAL ERROR: " + Std.string(choice_name)) + " not implemented. Stopping.\n"))
                                            _hx_local_76 = self
                                            _hx_local_77 = _hx_local_76.run_text_line
                                            _hx_local_76.run_text_line = (_hx_local_77 + 1)
                                            _hx_local_77
                                            self.intp_return_result = -10
                                            break
                                else:
                                    forGL_ForGL_ui.error("INTERNAL ERROR: Choice indicated but not referenced correctly. Stopping.\n")
                                    _hx_local_78 = self
                                    _hx_local_79 = _hx_local_78.run_text_line
                                    _hx_local_78.run_text_line = (_hx_local_79 + 1)
                                    _hx_local_79
                                    self.intp_return_result = -11
                                    break
                            if (0 < len(self.opStack)):
                                ops_result2 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,True)
                                def _hx_local_0():
                                    _hx_local_80 = ops_result2
                                    if (Std._hx_is(_hx_local_80,Int) or ((_hx_local_80 is None))):
                                        _hx_local_80
                                    else:
                                        raise _HxException("Class cast error")
                                    return _hx_local_80
                                if (_hx_local_0() < 0):
                                    self.intp_return_result = ops_result2
                                    break
                    elif (not (((22 == op_to_do) or ((23 == op_to_do))))):
                        if ((26 == op_to_do) or ((27 == op_to_do))):
                            if (26 == op_to_do):
                                _this27 = self.old_opStackFrames
                                x12 = len(self.opStack)
                                _this27.append(x12)
                                while (0 < len(self.opStack)):
                                    _this28 = self.old_opStack
                                    _this29 = self.opStack
                                    x13 = (None if ((len(_this29) == 0)) else _this29.pop(0))
                                    _this28.append(x13)
                                _this30 = self.old_dataStackFrames
                                x14 = len(self.dataStack)
                                _this30.append(x14)
                                while (0 < len(self.dataStack)):
                                    _this31 = self.old_dataStack
                                    _this32 = self.dataStack
                                    x15 = (None if ((len(_this32) == 0)) else _this32.pop(0))
                                    _this31.append(x15)
                            else:
                                if (0 < len(self.opStack)):
                                    ops_result3 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    def _hx_local_0():
                                        _hx_local_81 = ops_result3
                                        if (Std._hx_is(_hx_local_81,Int) or ((_hx_local_81 is None))):
                                            _hx_local_81
                                        else:
                                            raise _HxException("Class cast error")
                                        return _hx_local_81
                                    if (_hx_local_0() < 0):
                                        self.intp_return_result = ops_result3
                                        break
                                if (0 < len(self.assignStack)):
                                    _this33 = self.assignStack
                                    r_idx = (None if ((len(_this33) == 0)) else _this33.pop())
                                    assign_op = (self.runStack[r_idx] if r_idx >= 0 and r_idx < len(self.runStack) else None).token_op_means
                                    self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns,assign_op)
                                num_to_do1 = 0
                                if (0 < len(self.old_opStackFrames)):
                                    _this34 = self.old_opStackFrames
                                    num_to_do1 = (None if ((len(_this34) == 0)) else _this34.pop())
                                while (0 < num_to_do1):
                                    _this35 = self.opStack
                                    _this36 = self.old_opStack
                                    x16 = (None if ((len(_this36) == 0)) else _this36.pop())
                                    _this35.insert(0, x16)
                                    num_to_do1 = (num_to_do1 - 1)
                                num_to_do1 = 0
                                if (0 < len(self.old_dataStackFrames)):
                                    _this37 = self.old_dataStackFrames
                                    num_to_do1 = (None if ((len(_this37) == 0)) else _this37.pop())
                                while (0 < num_to_do1):
                                    _this38 = self.dataStack
                                    _this39 = self.old_dataStack
                                    x17 = (None if ((len(_this39) == 0)) else _this39.pop())
                                    _this38.insert(0, x17)
                                    num_to_do1 = (num_to_do1 - 1)
                                if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                    ip = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                    _hx_local_84 = self
                                    _hx_local_85 = _hx_local_84.steps_done
                                    _hx_local_84.steps_done = (_hx_local_85 + 1)
                                    _hx_local_85
                                    continue
                                if (0.0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float):
                                    ip = (ip + Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float))
                                    _hx_local_87 = self
                                    _hx_local_88 = _hx_local_87.steps_done
                                    _hx_local_87.steps_done = (_hx_local_88 + 1)
                                    _hx_local_88
                                    continue
                        else:
                            #   Any Operator that is Not Punctuation is pushed                                   ")
                            _this40 = self.opStack
                            _this40.append(ip)
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                            ops_result4 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                            def _hx_local_0():
                                _hx_local_89 = ops_result4
                                if (Std._hx_is(_hx_local_89,Int) or ((_hx_local_89 is None))):
                                    _hx_local_89
                                else:
                                    raise _HxException("Class cast error")
                                return _hx_local_89
                            if (_hx_local_0() < 0):
                                self.intp_return_result = ops_result4
                                break
                    _hx_local_90 = self
                    _hx_local_91 = _hx_local_90.steps_done
                    _hx_local_90.steps_done = (_hx_local_91 + 1)
                    _hx_local_91
                    ip = (ip + 1)
                    continue
            verb_pending = False
            if (((4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                verb_pending = True
                if (0 < len(self.opStack)):
                    apply_op = True
                    ip = (ip - 1)
            if apply_op:
                if (0 < len(self.opStack)):
                    ops_result5 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                    def _hx_local_0():
                        _hx_local_94 = ops_result5
                        if (Std._hx_is(_hx_local_94,Int) or ((_hx_local_94 is None))):
                            _hx_local_94
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_94
                    if (_hx_local_0() < 0):
                        self.intp_return_result = ops_result5
                        break
                    ip = (ip + 1)
                    continue
            if (((4 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) and ((3 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                ip = (ip + 1)
                continue
            if (self.show_details and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                forGL_ForGL_ui.msg((("\n   running Verb   " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                _hx_local_97 = self
                _hx_local_98 = _hx_local_97.run_text_line
                _hx_local_97.run_text_line = (_hx_local_98 + 1)
                _hx_local_98
                _hx_local_99 = self
                _hx_local_100 = _hx_local_99.run_text_line
                _hx_local_99.run_text_line = (_hx_local_100 + 1)
                _hx_local_100
            if (4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                #                                                                                    ")
                #    Run a Verb defined in the Dictionary                                            ")
                verb_text = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str
                if (0 == ((0 if ((verb_text is None)) else len(verb_text)))):
                    ip = (ip + 1)
                    continue
                verb_tokens = self.nl_Parse.parse(verb_text,forGL_ParseStyle.PARSE_EURO,False)
                if (0 == len(verb_tokens)):
                    ip = (ip + 1)
                    continue
                #                                                                                    ")
                #  Save only Noun values to Dictionary (Not Local Nouns)                             ")
                #                                                                                    ")
                self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                old_length = len(self.runStack)
                #                                                                                    ")
                #  ADD more structures AT THE END of existing Run Stack.                             ")
                #     ? THIS TRIES TO AVOID EXCESSIVE RESOURCE USE ?                                 ")
                #                                                                                    ")
                _hx_local_103 = self
                _hx_local_104 = _hx_local_103.run_text_line
                _hx_local_103.run_text_line = (_hx_local_104 + self.nl_Parse.resolveTokens(verb_tokens,self.nlDict,self.runStack,self.run_verbose))
                _hx_local_103.run_text_line
                self.repeat_found = self.nl_Parse.repeat_verb_found
                if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                    forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not same.\n"))
                    _hx_local_105 = self
                    _hx_local_106 = _hx_local_105.run_text_line
                    _hx_local_105.run_text_line = (_hx_local_106 + 1)
                    _hx_local_106
                    _hx_local_107 = self
                    _hx_local_108 = _hx_local_107.run_text_line
                    _hx_local_107.run_text_line = (_hx_local_108 + 1)
                    _hx_local_108
                self.nl_Parse.resolveAssigns(self.runStack)
                choice_result = -11
                if self.export_as_code:
                    export_runStack = self.nl_Parse.refactorForExport(self.runStack)
                    choice_result = self.nl_Parse.resolveChoice(export_runStack)
                    self.runStack = export_runStack
                else:
                    choice_result = self.nl_Parse.resolveChoice(self.runStack)
                def _hx_local_0():
                    _hx_local_109 = choice_result
                    if (Std._hx_is(_hx_local_109,Int) or ((_hx_local_109 is None))):
                        _hx_local_109
                    else:
                        raise _HxException("Class cast error")
                    return _hx_local_109
                if (0 > _hx_local_0()):
                    self.intp_return_result = choice_result
                    break
                if (((self.show_words_table or self.export_as_code)) and ((0 < len(self.runStack)))):
                    _hx_local_110 = self
                    _hx_local_111 = _hx_local_110.run_text_line
                    _hx_local_110.run_text_line = (_hx_local_111 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,self.export_as_code))
                    _hx_local_110.run_text_line
                if self.export_as_code:
                    j = 0
                    exp_text = ""
                    while (j < len(self.runStack)):
                        _hx_str = ""
                        if self.display_internal:
                            _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).internal_token
                            if ("" == _hx_str):
                                _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                        else:
                            _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                        exp_text = (("null" if exp_text is None else exp_text) + HxOverrides.stringOrNull(((("null" if _hx_str is None else _hx_str) + " "))))
                        j = (j + 1)
                    _this41 = self.export_as_code_log
                    _this41.append(exp_text)
                #                                                                                    ")
                #  ADD a structure so after the Verb to be called is done,                           ")
                #  we can resume running in the original Verb after this called Verb.                ")
                #                                                                                    ")
                _this42 = self.runStack
                x18 = forGL_NLToken()
                _this42.append(x18)
                rIdx = (len(self.runStack) - 1)
                new_length = len(self.runStack)
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_type = 5
                #                                                                                    ")
                #  Return placeholder ONLY Slightly Visible by seeing an extra blank space           ")
                #                                                                                    ")
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).internal_token = " "
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).visible_token = " "
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_int = (ip + 1)
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_float = (new_length - old_length)
                _this43 = self.old_assignStackFrames
                x19 = len(self.assignStack)
                _this43.append(x19)
                while (0 < len(self.assignStack)):
                    _this44 = self.old_assignStack
                    _this45 = self.assignStack
                    x20 = (None if ((len(_this45) == 0)) else _this45.pop(0))
                    _this44.append(x20)
                _this46 = self.old_nounStackFrames
                x21 = len(self.nouns)
                _this46.append(x21)
                while (0 < len(self.nouns)):
                    _this47 = self.old_nounStack
                    _this48 = self.nouns
                    x22 = (None if ((len(_this48) == 0)) else _this48.pop(0))
                    _this47.append(x22)
                _this49 = self.old_opStackFrames
                x23 = len(self.opStack)
                _this49.append(x23)
                while (0 < len(self.opStack)):
                    _this50 = self.old_opStack
                    _this51 = self.opStack
                    x24 = (None if ((len(_this51) == 0)) else _this51.pop(0))
                    _this50.append(x24)
                ip = old_length
                continue
            elif (5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                #                                                                                    ")
                #  Save only Noun values to Dictionary (Not Local Nouns)                             ")
                #                                                                                    ")
                self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                #                                                                                    ")
                #  EMPTY the Nouns Stack                                                             ")
                #                                                                                    ")
                num_to_do2 = len(self.nouns)
                while (0 < num_to_do2):
                    _this52 = self.nouns
                    if (len(_this52) != 0):
                        _this52.pop()
                    num_to_do2 = (num_to_do2 - 1)
                #  Restore 1 Frame of old underneath (at Bottom of) Assign, Noun, Operator and Data stacks  ")
                num_to_do2 = 0
                if (0 < len(self.old_assignStackFrames)):
                    _this53 = self.old_assignStackFrames
                    num_to_do2 = (None if ((len(_this53) == 0)) else _this53.pop())
                while (0 < num_to_do2):
                    _this54 = self.assignStack
                    _this55 = self.old_assignStack
                    x25 = (None if ((len(_this55) == 0)) else _this55.pop())
                    _this54.insert(0, x25)
                    num_to_do2 = (num_to_do2 - 1)
                num_to_do2 = 0
                if (0 < len(self.old_nounStackFrames)):
                    _this56 = self.old_nounStackFrames
                    num_to_do2 = (None if ((len(_this56) == 0)) else _this56.pop())
                while (0 < num_to_do2):
                    _this57 = self.nouns
                    _this58 = self.old_nounStack
                    x26 = (None if ((len(_this58) == 0)) else _this58.pop())
                    _this57.insert(0, x26)
                    num_to_do2 = (num_to_do2 - 1)
                num_to_do2 = 0
                if (0 < len(self.old_opStackFrames)):
                    _this59 = self.old_opStackFrames
                    num_to_do2 = (None if ((len(_this59) == 0)) else _this59.pop())
                while (0 < num_to_do2):
                    _this60 = self.opStack
                    _this61 = self.old_opStack
                    x27 = (None if ((len(_this61) == 0)) else _this61.pop())
                    _this60.insert(0, x27)
                    num_to_do2 = (num_to_do2 - 1)
                new_ip = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int
                num_to_remove = Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float)
                num_to_do2 = num_to_remove
                while (0 < num_to_do2):
                    _this62 = self.runStack
                    if (len(_this62) != 0):
                        _this62.pop()
                    num_to_do2 = (num_to_do2 - 1)
                #   Update Noun values from Dictionary (Not Local Nouns)                             ")
                self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns)
                if ((len(self.runStack) - 1) < new_ip):
                    break
                ip = new_ip
                continue
            elif (3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                #                                                                                    ")
                #      Built In  VERB                                                                ")
                #                                                                                    ")
                if ("repeat" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                    #                                                                                    ")
                    #      Repeat built in: Need to set up Limit for number of Repeats ?                 ")
                    #                                                                                    ")
                    if (self.repeat_limit < 0):
                        if (0 < len(self.dataStack)):
                            repeat_data_type = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                            if (9 == repeat_data_type):
                                if (0 <= python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int):
                                    self.repeat_limit_found = True
                                    self.repeat_limit = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                        if (self.repeat_limit < 0):
                            self.repeat_limit = 0
                    _hx_local_119 = self
                    _hx_local_120 = _hx_local_119.repeat_count
                    _hx_local_119.repeat_count = (_hx_local_120 + 1)
                    _hx_local_120
                    if (self.repeat_count <= self.repeat_limit):
                        if self.repeat_limit_found:
                            _this63 = self.dataStack
                            if (len(_this63) != 0):
                                _this63.pop()
                        #                                                                                    ")
                        #      MUST Reset  all LOCAL Nouns to UNKNOWN in Run stack                           ")
                        #      MUST Remove all LOCAL Nouns in Noun stack                                     ")
                        #                                                                                    ")
                        i = (len(self.nouns) - 1)
                        while (0 <= i):
                            nounIdx = (self.nouns[i] if i >= 0 and i < len(self.nouns) else None)
                            if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                                (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type = 0
                                python_internal_ArrayImpl.remove(self.nouns,nounIdx)
                            i = (i - 1)
                        if (0 < len(self.nouns)):
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                        if (0 < len(self.opStack)):
                            forGL_ForGL_ui.warning((("WARNING: Doing Repeat with leftover Operators: " + Std.string(self.opStackToString(self.runStack,self.opStack))) + "\n"))
                            _hx_local_122 = self
                            _hx_local_123 = _hx_local_122.run_text_line
                            _hx_local_122.run_text_line = (_hx_local_123 + 1)
                            _hx_local_123
                        forGL_ForGL_ui.msg("\r")
                        forGL_ForGL_ui.msg((Std.string(self.repeat_count) + "\t"))
                        ip = 0
                        continue
                    elif self.repeat_limit_found:
                        _this64 = self.dataStack
                        if (len(_this64) != 0):
                            _this64.pop()
                elif (("show" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                    #                                                                                    ")
                    #      Show or View what is on the Data stack                                        ")
                    #  Show removes 1 item.                                                              ")
                    #                                                                                    ")
                    #      View will display all items without removal. Handy for User Debugging         ")
                    #                                                                                    ")
                    #  Note: View is specific to forGL and not for Export as Code                        ")
                    #                                                                                    ")
                    showing = True
                    if ("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                        showing = False
                        forGL_ForGL_ui.msg("\n        Data  Stack\n")
                        _hx_local_124 = self
                        _hx_local_125 = _hx_local_124.run_text_line
                        _hx_local_124.run_text_line = (_hx_local_125 + 1)
                        _hx_local_125
                        _hx_local_126 = self
                        _hx_local_127 = _hx_local_126.run_text_line
                        _hx_local_126.run_text_line = (_hx_local_127 + 1)
                        _hx_local_127
                    i = (len(self.dataStack) - 1)
                    while (i >= 0):
                        dataIdx1 = i
                        dataStr = ""
                        if (9 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int)
                        elif (10 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = "false"
                            if (1 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int):
                                dataStr = "true"
                        elif (11 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_float)
                        elif (8 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                            if showing:
                                dataStr = self.trimQuotes(dataStr)
                        else:
                            forGL_ForGL_ui.error(" \nINTERNAL ERROR: Data not Float, Integer, Bool or String\n")
                            _hx_local_128 = self
                            _hx_local_129 = _hx_local_128.run_text_line
                            _hx_local_128.run_text_line = (_hx_local_129 + 1)
                            _hx_local_129
                            _hx_local_130 = self
                            _hx_local_131 = _hx_local_130.run_text_line
                            _hx_local_130.run_text_line = (_hx_local_131 + 1)
                            _hx_local_131
                            i = (i - 1)
                            continue
                        if showing:
                            if (0 < ((0 if ((dataStr is None)) else len(dataStr)))):
                                self.show1Data(dataStr,self.show_text_line)
                            if self.export_as_code:
                                exp = dataStr
                                #  Use Noun name if available for Export                                             ")
                                tmp = None
                                if (8 != (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    this1 = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                    tmp = (0 < ((0 if ((this1 is None)) else len(this1))))
                                else:
                                    tmp = False
                                if tmp:
                                    exp = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                _this65 = self.export_as_code_log
                                _this65.append((("show ( " + ("null" if exp is None else exp)) + " )"))
                            _this66 = self.dataStack
                            if (len(_this66) != 0):
                                _this66.pop()
                            break
                        else:
                            forGL_ForGL_ui.msg((("null" if dataStr is None else dataStr) + "\n"))
                            _hx_local_133 = self
                            _hx_local_134 = _hx_local_133.run_text_line
                            _hx_local_133.run_text_line = (_hx_local_134 + 1)
                            _hx_local_134
                        i = (i - 1)
            ip = (ip + 1)
        #                                                                                    ")
        #      END  OF  INTERPRETER  LOOP                                                    ")
        #                                                                                    ")
        self.intp_ip = ip
        forGL_ForGL_ui.outputBuffersUsed()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.run_text_line = None
        _hx_o.export_as_code = None
        _hx_o.export_as_code_log = None
        _hx_o.export_as_code_verb_name = None
        _hx_o.display_internal = None
        _hx_o.show_details = None
        _hx_o.show_words_table = None
        _hx_o.show_stacks = None
        _hx_o.show_stacks_Data_Only = None
        _hx_o.single_step = None
        _hx_o.delay_seconds_default = None
        _hx_o.delay_seconds = None
        _hx_o.stdin = None
        _hx_o.run_verbose = None
        _hx_o.ForGLData = None
        _hx_o.nlDict = None
        _hx_o.nl_Import_used = None
        _hx_o.nl_Import = None
        _hx_o.nl_Parse = None
        _hx_o.in_dictionary_file_name = None
        _hx_o.use_Built_In_Dictionary = None
        _hx_o.out_dictionary_file_name = None
        _hx_o.dataOpNoun_text_line = None
        _hx_o.steps_done = None
        _hx_o.steps_done_Verb = None
        _hx_o.intp_ip = None
        _hx_o.old_dataStackFrames = None
        _hx_o.old_dataStack = None
        _hx_o.old_opStackFrames = None
        _hx_o.old_opStack = None
        _hx_o.old_nounStackFrames = None
        _hx_o.old_nounStack = None
        _hx_o.old_assignStackFrames = None
        _hx_o.old_assignStack = None
        _hx_o.elapsed_intp_time = None
        _hx_o.user_def = None
        _hx_o.prev_dataStackOut = None
        _hx_o.prev_opStackOut = None
        _hx_o.prev_nounStackOut = None
        _hx_o.view_DON_throttle = None
        _hx_o.last_view_DON_time = None
        _hx_o.prev_show1_data = None
        _hx_o.start_session_time = None
        _hx_o.total_intp_time = None
        _hx_o.verb_to_run = None
        _hx_o.runStack = None
        _hx_o.dataStack = None
        _hx_o.opStack = None
        _hx_o.nouns = None
        _hx_o.assignStack = None
        _hx_o.repeat_found = None
        _hx_o.repeat_count = None
        _hx_o.repeat_limit = None
        _hx_o.repeat_limit_found = None
        _hx_o.show_text_line = None
        _hx_o.start_intp_time = None
        _hx_o.intp_return_result = None


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "set_bigEndian", "readLine"]

    def readByte(self):
        raise _HxException("Not implemented")

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                _this = buf.b
                _this.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                e = _hx_e1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise _HxException(e)
            else:
                raise _hx_e
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "throwEof"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def close(self):
        self.stream.close()

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
        _hx_o.canSeek = None


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "readByte", "close", "readLine"]


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return HxString.charCodeAt(ret,0)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "close", "readLine"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def close(self):
        self.impl.close()

    def readLine(self):
        return self.impl.readLine()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        self.stream.close()

    def flush(self):
        self.stream.flush()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.canSeek = None


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None


class hx_strings_ansi__AnsiWriter_AbstractStringWriter:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.AbstractStringWriter"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["flush", "write"]

    def flush(self):
        pass

    def write(self,_hx_str):
        raise _HxException("Not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None


class hx_strings_ansi__AnsiWriter_OutputStringWriter(hx_strings_ansi__AnsiWriter_AbstractStringWriter):
    _hx_class_name = "hx.strings.ansi._AnsiWriter.OutputStringWriter"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["flush", "write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_ansi__AnsiWriter_AbstractStringWriter


    def __init__(self,out):
        self.out = out

    def flush(self):
        self.out.flush()

    def write(self,_hx_str):
        self.out.writeString(_hx_str)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class hx_strings_ansi_AnsiWriter:
    _hx_class_name = "hx.strings.ansi.AnsiWriter"
    __slots__ = ("_out", "out")
    _hx_fields = ["_out"]
    _hx_methods = ["get_out", "attr", "bg", "clearScreen", "clearLine", "cursor", "fg", "flush", "write"]

    def __init__(self,out):
        self.out = None
        self._out = out

    def get_out(self):
        return self._out.out

    def attr(self,attr):
        self._out.write((("\x1B[" + Std.string(attr)) + "m"))
        return self

    def bg(self,color):
        self._out.write(((("\x1B[" + "4") + Std.string(color)) + "m"))
        return self

    def clearScreen(self):
        self._out.write(("\x1B[" + "2J"))
        return self

    def clearLine(self):
        self._out.write(("\x1B[" + "K"))
        return self

    def cursor(self,cmd):
        _hx_str = hx_strings_ansi_Ansi.cursor(cmd)
        self._out.write(_hx_str)
        return self

    def fg(self,color):
        self._out.write(((("\x1B[" + "3") + Std.string(color)) + "m"))
        return self

    def flush(self):
        self._out.flush()
        return self

    def write(self,_hx_str):
        self._out.write(_hx_str)
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._out = None


class forGL_ForGL_ui:
    _hx_class_name = "forGL.ForGL_ui"
    __slots__ = ()
    _hx_statics = ["system_name", "error_count_ui", "error_msgs_ui", "warning_count_ui", "warning_msgs_ui", "out_buffers", "COMMENT_COLOR", "DATA_COLOR", "NOUN_COLOR", "OP_COLOR", "VERB_COLOR", "VERB_BI_COLOR", "DEFAULT_COLOR", "current_line", "current_column", "blanks78", "stdin", "stdout", "writer", "setOut", "outputBuffersUsed", "eraseToLineEnd", "getCurrentPos", "hideCursor", "savePos", "goToPos", "eraseToDispEnd", "restorePos", "showCursor", "msg_call_count", "msg", "status_msgs", "status", "error", "warning", "getTypeColor", "enterYourVerb_return", "enterYourVerb", "enterYes", "init", "popUp"]

    @staticmethod
    def setOut(outputWhere = 0):
        if (outputWhere is None):
            outputWhere = 0

    @staticmethod
    def outputBuffersUsed():
        pass

    @staticmethod
    def eraseToLineEnd(used):
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "K"))
        _this1 = _this
        _this1._out.flush()

    @staticmethod
    def getCurrentPos(line,column):
        line = forGL_ForGL_ui.current_line
        column = forGL_ForGL_ui.current_column

    @staticmethod
    def hideCursor():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "?25l"))

    @staticmethod
    def savePos():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "s"))

    @staticmethod
    def goToPos(line,column):
        _this = forGL_ForGL_ui.writer
        _this._out.write((((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H"))
        forGL_ForGL_ui.current_line = line
        forGL_ForGL_ui.current_column = column

    @staticmethod
    def eraseToDispEnd():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "J"))

    @staticmethod
    def restorePos():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "u"))

    @staticmethod
    def showCursor():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "?25h"))

    @staticmethod
    def msg(message,color = 7,end_CR = False):
        if (color is None):
            color = 7
        if (end_CR is None):
            end_CR = False
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.msg_call_count
        _hx_local_0.msg_call_count = (_hx_local_1 + 1)
        _hx_local_1
        if (forGL_ForGL_ui.DEFAULT_COLOR == color):
            if (True == end_CR):
                _hx_str = Std.string(message)
                python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + "\n"))
            else:
                python_Lib.printString(Std.string(message))
        else:
            _this = forGL_ForGL_ui.writer
            _this._out.write(((("\x1B[" + "3") + Std.string(color)) + "m"))
            _this1 = _this
            str1 = Std.string(message)
            _this1._out.write(str1)
            _this2 = _this1
            _this2._out.flush()
            _this3 = forGL_ForGL_ui.writer
            _this3._out.write(((("\x1B[" + "3") + Std.string(forGL_ForGL_ui.DEFAULT_COLOR)) + "m"))
            _this4 = _this3
            _this4._out.flush()
            if (True == end_CR):
                _this5 = forGL_ForGL_ui.writer
                _this5._out.write("\n")
                _this6 = _this5
                _this6._out.flush()

    @staticmethod
    def status(message,color = 7,end_CR = False,wait = False):
        if (color is None):
            color = 7
        if (end_CR is None):
            end_CR = False
        if (wait is None):
            wait = False
        show_msg = True
        if (0 == ((0 if ((message is None)) else len(message)))):
            forGL_ForGL_ui.status_msgs = ""
            end_CR = False
            wait = False
        else:
            forGL_ForGL_ui.status_msgs = hx_strings_Strings.insertAt(message,(0 if ((message is None)) else len(message)),Std.string(forGL_ForGL_ui.status_msgs))
        forGL_ForGL_ui.savePos()
        forGL_ForGL_ui.goToPos(1,20)
        forGL_ForGL_ui.eraseToLineEnd(20)
        if show_msg:
            forGL_ForGL_ui.msg(forGL_ForGL_ui.status_msgs,color,end_CR)
        if wait:
            Sys.getChar(False)
        forGL_ForGL_ui.restorePos()

    @staticmethod
    def error(message,color = 1):
        if (color is None):
            color = 1
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.error_count_ui
        _hx_local_0.error_count_ui = (_hx_local_1 + 1)
        _hx_local_1
        _hx_str = forGL_ForGL_ui.error_msgs_ui
        forGL_ForGL_ui.error_msgs_ui = hx_strings_Strings.insertAt(forGL_ForGL_ui.error_msgs_ui,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(message))
        forGL_ForGL_ui.status("")
        forGL_ForGL_ui.msg(message,color)
        forGL_ForGL_ui.status(message,color,False,True)

    @staticmethod
    def warning(message,color = 3):
        if (color is None):
            color = 3
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.warning_count_ui
        _hx_local_0.warning_count_ui = (_hx_local_1 + 1)
        _hx_local_1
        _hx_str = forGL_ForGL_ui.warning_msgs_ui
        forGL_ForGL_ui.warning_msgs_ui = hx_strings_Strings.insertAt(forGL_ForGL_ui.warning_msgs_ui,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(message))
        forGL_ForGL_ui.status("")
        forGL_ForGL_ui.msg(message,color)
        forGL_ForGL_ui.status(message,color,False,True)

    @staticmethod
    def getTypeColor(_hx_type):
        color = forGL_ForGL_ui.DEFAULT_COLOR
        type1 = _hx_type
        if (type1 == 0):
            color = forGL_ForGL_ui.DEFAULT_COLOR
        elif (type1 == 1):
            color = forGL_ForGL_ui.COMMENT_COLOR
        elif (type1 == 2):
            color = forGL_ForGL_ui.OP_COLOR
        elif (type1 == 3):
            color = forGL_ForGL_ui.VERB_BI_COLOR
        elif (type1 == 4):
            color = forGL_ForGL_ui.VERB_COLOR
        elif (type1 == 5):
            pass
        elif (type1 == 6):
            color = forGL_ForGL_ui.NOUN_COLOR
        elif (type1 == 7):
            color = forGL_ForGL_ui.NOUN_COLOR
        elif (type1 == 8):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 9):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 10):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 11):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 12):
            color = forGL_ForGL_ui.VERB_BI_COLOR
        else:
            pass
        return color

    @staticmethod
    def enterYourVerb():
        forGL_ForGL_ui.enterYourVerb_return = 0
        user_Verb = ""
        try:
            forGL_ForGL_ui.msg("Type  test_verb  OR  your Verb and hit Enter or only Enter to stop.\n")
            #                                                                                    ")
            #  EXCEPTION  Happens  Here  IF:                                                     ")
            #  Running on Windows                                                                ")
            #  and Font does not have information about glyphs                                   ")
            #  Outline boxes show  ▯▯▯  instead of expected glyphs                               ")
            #                                                                                    ")
            user_Verb = forGL_ForGL_ui.stdin.readLine()
            this1 = hx_strings_internal__Either2__Either2.a(" \t")
            user_Verb = hx_strings_Strings.trim(user_Verb,this1)
            if (0 == ((0 if ((user_Verb is None)) else len(user_Verb)))):
                forGL_ForGL_ui.enterYourVerb_return = -1
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.warning((("\nINTERNAL ERROR: Exception in  UI.enterYourVerb():  stdin.readLine()  " + Std.string(e)) + "\n"))
            if ("Windows" == forGL_ForGL_ui.system_name):
                forGL_ForGL_ui.warning("If you see outline boxes  ▯▯▯  instead of expected text:\nIt usually means the font does not have the data for those characters.\nPlease try the forGL GUI application.")
            forGL_ForGL_ui.enterYourVerb_return = -11
        return user_Verb

    @staticmethod
    def enterYes():
        yes_entered = False
        ans = forGL_ForGL_ui.stdin.readLine()
        if (0 < ((0 if ((ans is None)) else len(ans)))):
            this1 = hx_strings_internal__Either2__Either2.a(" \t")
            ans = hx_strings_Strings.trim(ans,this1)
            if (("Y" == hx_strings_Strings.charAt8(ans,0)) or (("y" == hx_strings_Strings.charAt8(ans,0)))):
                yes_entered = True
        return yes_entered

    @staticmethod
    def init():
        ret_val = 0
        return ret_val

    @staticmethod
    def popUp(msg):
        pass


class forGL_data_ForGL_data:
    _hx_class_name = "forGL.data.ForGL_data"
    __slots__ = ("actual_path_file", "actual_file_type", "data_call_count", "toml", "findWordDef_type", "replaceOrAddWord_replaced")
    _hx_fields = ["actual_path_file", "actual_file_type", "data_call_count", "toml", "findWordDef_type", "replaceOrAddWord_replaced"]
    _hx_methods = ["callCount", "init", "cleanUp", "loadFile", "getListOfWords", "findWordDef", "getDataErrors", "getDataWarnings", "renameFile", "saveToFile", "replaceOrAddWord"]

    def __init__(self):
        self.toml = None
        self.replaceOrAddWord_replaced = False
        self.findWordDef_type = 0
        self.data_call_count = 0
        self.actual_file_type = 0
        self.actual_path_file = ""

    def callCount(self):
        return self.data_call_count

    def init(self,path_file,file_type):
        result = 0
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.data_call_count
        _hx_local_0.data_call_count = (_hx_local_1 + 1)
        _hx_local_1
        self.toml = forGL_data_ForGL_toml()
        result = self.loadFile(path_file,file_type)
        return result

    def cleanUp(self):
        ret_val = 0
        try:
            self.toml.cleanUp()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in forGL_data.cleanUp(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def loadFile(self,path_name,expected_type):
        ret_val = 0
        extension = HxString.substr(path_name,(len(path_name) - 5),5)
        if (".toml" != extension.lower()):
            forGL_ForGL_ui.error((((("ERROR: File extension not .toml : " + ("null" if path_name is None else path_name)) + " ") + ("null" if extension is None else extension)) + "\n"))
            ret_val = -3
        else:
            ret_val = self.toml.init(path_name,expected_type)
            if (0 == ret_val):
                self.actual_file_type = self.toml.actual_file_type
                self.actual_path_file = self.toml.actual_path_file
        return ret_val

    def getListOfWords(self,warn_if_not_unique = True):
        if (warn_if_not_unique is None):
            warn_if_not_unique = True
        wordList = self.toml.getWordList(warn_if_not_unique)
        return wordList

    def findWordDef(self,word_visible_name,rInfo):
        self.findWordDef_type = 0
        ret_val = self.toml.getWord(word_visible_name,rInfo)
        def _hx_local_0():
            _hx_local_0 = ret_val
            if (Std._hx_is(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise _HxException("Class cast error")
            return _hx_local_0
        if (0 == _hx_local_0()):
            self.findWordDef_type = self.toml.getWord_type
        return ret_val

    def getDataErrors(self):
        return self.toml.error_msgs

    def getDataWarnings(self):
        return self.toml.warning_msgs

    def renameFile(self,old_path_name,new_path_name):
        ret_val = 0
        try:
            sys_FileSystem.rename(old_path_name,new_path_name)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            ret_val = -11
        return ret_val

    def saveToFile(self,new_path_name):
        save_result = self.toml.saveData(new_path_name)
        return save_result

    def replaceOrAddWord(self,word_visible_name,word_type,rInfo):
        self.replaceOrAddWord_replaced = False
        replaceOrAdd_result = self.toml.changeOrAddWord(word_visible_name,word_type,rInfo)
        def _hx_local_0():
            _hx_local_0 = replaceOrAdd_result
            if (Std._hx_is(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise _HxException("Class cast error")
            return _hx_local_0
        if (0 == _hx_local_0()):
            self.replaceOrAddWord_replaced = self.toml.changeOrAddWord_changed
        return replaceOrAdd_result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.actual_path_file = None
        _hx_o.actual_file_type = None
        _hx_o.data_call_count = None
        _hx_o.toml = None
        _hx_o.findWordDef_type = None
        _hx_o.replaceOrAddWord_replaced = None


class forGL_data_ForGL_toml:
    _hx_class_name = "forGL.data.ForGL_toml"
    __slots__ = ("actual_path_file", "actual_file_type", "error_msgs", "warning_msgs", "data_call_count", "fReadHandle", "ws_chars", "fileLines", "comment_lines", "sections", "section_names", "word_list", "type_list", "built_in_list", "value_list", "getStr_type", "getStrML_end_line", "valid_str_ML", "getWord_type", "getWord_word_idx", "changeOrAddWord_changed", "changeOrAddWord_msgs")
    _hx_fields = ["actual_path_file", "actual_file_type", "error_msgs", "warning_msgs", "data_call_count", "fReadHandle", "ws_chars", "fileLines", "comment_lines", "sections", "section_names", "word_list", "type_list", "built_in_list", "value_list", "getStr_type", "getStrML_end_line", "valid_str_ML", "getWord_type", "getWord_word_idx", "changeOrAddWord_changed", "changeOrAddWord_msgs"]
    _hx_methods = ["callCount", "init", "cleanUp", "nameValidate", "getStr", "getStrML", "getWordList", "getWord", "changeOrAddWord", "saveData"]

    def __init__(self):
        self.fReadHandle = None
        self.changeOrAddWord_msgs = ""
        self.changeOrAddWord_changed = False
        self.getWord_word_idx = -1
        self.getWord_type = 0
        self.valid_str_ML = False
        self.getStrML_end_line = 0
        self.getStr_type = 0
        self.value_list = list()
        self.built_in_list = list()
        self.type_list = list()
        self.word_list = list()
        self.section_names = list()
        self.sections = list()
        self.comment_lines = 0
        self.fileLines = list()
        strLen = len(" ")
        tmp = (-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt(" ",0))
        strLen1 = len("\t")
        self.ws_chars = [tmp, (-1 if (((strLen1 == 0) or ((0 >= strLen1)))) else HxString.charCodeAt("\t",0))]
        self.data_call_count = 0
        self.warning_msgs = list()
        self.error_msgs = list()
        self.actual_file_type = 0
        self.actual_path_file = ""

    def callCount(self):
        return self.data_call_count

    def init(self,path_file = "forGL_Dict.toml",file_type = None):
        if (path_file is None):
            path_file = "forGL_Dict.toml"
        #  Initialize  toml  file handling with a given file to Read                         ")
        ret_val = 0
        self.error_msgs = [""]
        _this = self.error_msgs
        if (len(_this) != 0):
            _this.pop()
        self.warning_msgs = [""]
        _this1 = self.warning_msgs
        if (len(_this1) != 0):
            _this1.pop()
        self.actual_path_file = path_file
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.data_call_count
        _hx_local_0.data_call_count = (_hx_local_1 + 1)
        _hx_local_1
        try:
            does_exist = sys_FileSystem.exists(self.actual_path_file)
            if (False == does_exist):
                #  Try up 1 directory level                                                          ")
                does_exist = sys_FileSystem.exists(("../" + HxOverrides.stringOrNull(self.actual_path_file)))
                if (False == does_exist):
                    err_msg = (("ERROR: Path or File not found: " + Std.string(path_file)) + "\n")
                    _this2 = self.error_msgs
                    _this2.append(err_msg)
                    forGL_ForGL_ui.error(err_msg)
                    return -3
                else:
                    self.actual_path_file = ("../" + HxOverrides.stringOrNull(self.actual_path_file))
            #  Make sure this has .toml file extension                                           ")
            extension = HxString.substr(self.actual_path_file,(len(self.actual_path_file) - 5),5)
            if (".toml" != extension.lower()):
                err_msg1 = ((("ERROR: File extension not .toml : " + HxOverrides.stringOrNull(self.actual_path_file)) + ("null" if extension is None else extension)) + "\n")
                _this3 = self.error_msgs
                _this3.append(err_msg1)
                forGL_ForGL_ui.error(err_msg1)
                return -3
            #  Make sure this is Not a directory                                                 ")
            is_dir = sys_FileSystem.isDirectory(self.actual_path_file)
            if (True == is_dir):
                err_msg2 = (("ERROR: Directory found but should be a File: " + HxOverrides.stringOrNull(self.actual_path_file)) + "\n")
                forGL_ForGL_ui.error(err_msg2)
                return -3
            #  Read the .toml file                                                               ")
            self.fReadHandle = sys_io_File.read(self.actual_path_file,True)
            self.fileLines = [""]
            _this4 = self.fileLines
            if (len(_this4) != 0):
                _this4.pop()
            temp_line = ""
            try:
                while True:
                    temp_line = self.fReadHandle.readLine()
                    hx_strings_Strings.trim(temp_line)
                    _this5 = self.fileLines
                    _this5.append(temp_line)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                        pass
                else:
                    raise _hx_e
            self.fReadHandle.close()
            i = 0
            self.comment_lines = 0
            self.actual_file_type = 0
            found_file_type = False
            first_toml_table = -1
            while (i < len(self.fileLines)):
                this1 = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                if (0 == ((0 if ((this1 is None)) else len(this1)))):
                    i = (i + 1)
                    continue
                if ("#" == hx_strings_Strings.charAt8((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),0)):
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.comment_lines
                    _hx_local_3.comment_lines = (_hx_local_4 + 1)
                    _hx_local_4
                    i = (i + 1)
                    continue
                if ("[" == hx_strings_Strings.charAt8((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),0)):
                    _this6 = self.sections
                    _this6.append(i)
                    _this7 = self.section_names
                    this2 = hx_strings_internal__Either2__Either2.a("[]")
                    x = hx_strings_Strings.trim((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),this2)
                    _this7.append(x)
                    if (first_toml_table < 0):
                        first_toml_table = i
                        if ("[forGL_dictionary]" == (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)):
                            self.actual_file_type = 1
                            found_file_type = True
                        elif ("[forGL_commands]" == (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)):
                            self.actual_file_type = 2
                            found_file_type = True
                        elif ("[forGL_data]" == (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)):
                            self.actual_file_type = 3
                            found_file_type = True
                        else:
                            self.actual_file_type = 0
                            err_msg3 = (("ERROR: Unknown File type. Closing File. First section is: " + Std.string((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None))) + "\n")
                            _this8 = self.error_msgs
                            _this8.append(err_msg3)
                            forGL_ForGL_ui.error(err_msg3)
                            self.cleanUp()
                            return -3
                        if found_file_type:
                            if (i != first_toml_table):
                                forGL_ForGL_ui.error("ERROR: [forGL_dictionary] is not first section in file.\n")
                            found_file_type = False
                i = (i + 1)
            if ((0 != file_type) and ((self.actual_file_type != file_type))):
                forGL_ForGL_ui.error("ERROR: Type of .toml file is not as expected.\n")
                ret_val = -3
            else:
                forGL_ForGL_ui.status((((Std.string(len(self.fileLines)) + " lines and ") + Std.string(self.comment_lines)) + " comment lines.\n"))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            err_msg4 = (("\nINTERNAL ERROR: Exception in forGL_toml.init(): " + Std.string(e1)) + " \n")
            _this9 = self.error_msgs
            _this9.append(err_msg4)
            forGL_ForGL_ui.error(err_msg4)
            ret_val = -11
        def _hx_local_0():
            _hx_local_7 = ret_val
            if (Std._hx_is(_hx_local_7,Int) or ((_hx_local_7 is None))):
                _hx_local_7
            else:
                raise _HxException("Class cast error")
            return _hx_local_7
        tmp = (_hx_local_0() < 0)
        return ret_val

    def cleanUp(self):
        ret_val = 0
        try:
            self.fileLines = [""]
            _this = self.fileLines
            if (len(_this) != 0):
                _this.pop()
            self.comment_lines = 0
            self.sections = [0]
            _this1 = self.sections
            if (len(_this1) != 0):
                _this1.pop()
            self.section_names = [""]
            _this2 = self.section_names
            if (len(_this2) != 0):
                _this2.pop()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            err_msg = (("Exception in forGL_toml.cleanUp(): " + Std.string(e)) + " \n")
            _this3 = self.error_msgs
            _this3.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            ret_val = -11
        return ret_val

    def nameValidate(self,in_name,check_reserved = True):
        if (check_reserved is None):
            check_reserved = True
        #  Validate a possible word name in a Dictionary                                     ")
        if (0 == ((0 if ((in_name is None)) else len(in_name)))):
            return False
        temp = in_name
        result = ""
        pieces = hx_strings_Strings.split8(temp,["'", "\"", " ", "\t", "\r", "\n", "\\"])
        i = 0
        while (i < len(pieces)):
            _hx_str = (pieces[i] if i >= 0 and i < len(pieces) else None)
            if (0 < ((0 if ((_hx_str is None)) else len(_hx_str)))):
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),(pieces[i] if i >= 0 and i < len(pieces) else None))
            i = (i + 1)
        if (((0 if ((result is None)) else len(result))) != ((0 if ((temp is None)) else len(temp)))):
            return False
        if check_reserved:
            pieces = hx_strings_Strings.split8(result,["+", "-", "*", "/", "%", "<=", "<", "==", "=", ">=", ">", "!=", "!", "?", "(", ")", "[", "]", "{", "}", ",", ".", ";", ":"])
            result = ""
            i = 0
            while (i < len(pieces)):
                str1 = (pieces[i] if i >= 0 and i < len(pieces) else None)
                if (0 < ((0 if ((str1 is None)) else len(str1)))):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),(pieces[i] if i >= 0 and i < len(pieces) else None))
                i = (i + 1)
            if (((0 if ((result is None)) else len(result))) != ((0 if ((temp is None)) else len(temp)))):
                return False
        if (("0" <= hx_strings_Strings.charAt8(result,0)) and (("9" >= hx_strings_Strings.charAt8(result,0)))):
            return False
        return True

    def getStr(self,in_str,get_type = False):
        if (get_type is None):
            get_type = False
        #  After = whitespace get contents of Quoted string without the Quotes               ")
        self.getStr_type = 0
        temp = in_str
        if (((0 if ((temp is None)) else len(temp))) <= 2):
            err_msg = "SYNTAX ERROR: Input string too small from getStr\n"
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            return ""
        i = 0
        while ((i < ((0 if ((temp is None)) else len(temp)))) and (("\"" != hx_strings_Strings.charAt8(temp,i)))):
            i = (i + 1)
        if (i >= ((0 if ((temp is None)) else len(temp)))):
            err_msg1 = "SYNTAX ERROR: Quote character not found in getStr\n"
            _this1 = self.error_msgs
            _this1.append(err_msg1)
            forGL_ForGL_ui.error(err_msg1)
            return ""
        temp2 = hx_strings_Strings.substring8(temp,(i + 1))
        if (1 <= ((0 if ((temp2 is None)) else len(temp2)))):
            if ("\"" == hx_strings_Strings.charAt8(temp2,(((0 if ((temp2 is None)) else len(temp2))) - 1))):
                temp2 = hx_strings_Strings.substring8(temp2,0,(((0 if ((temp2 is None)) else len(temp2))) - 1))
        else:
            err_msg2 = "SYNTAX ERROR: Empty String from getStr 2\n"
            _this2 = self.error_msgs
            _this2.append(err_msg2)
            forGL_ForGL_ui.error(err_msg2)
            temp2 = ""
        if get_type:
            if (0 < ((0 if ((temp2 is None)) else len(temp2)))):
                if (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("operator")):
                    self.getStr_type = 2
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("noun")):
                    self.getStr_type = 6
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("verb")):
                    self.getStr_type = 4
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("choice")):
                    self.getStr_type = 12
        return temp2

    def getStrML(self,word_type,in_str,start_line):
        #  After = whitespace get contents of various value strings without the Quotes       ")
        err_msg = ""
        temp = ""
        result = ""
        self.getStrML_end_line = start_line
        self.valid_str_ML = False
        i = 0
        char_found = hx_strings_Strings.charAt8(in_str,i)
        while ("=" != char_found):
            if ("" == char_found):
                break
            i = (i + 1)
            char_found = hx_strings_Strings.charAt8(in_str,i)
        if ("" == char_found):
            err_msg = ("ERROR: getStrML = character not found at line " + Std.string(start_line))
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.status("")
            forGL_ForGL_ui.error(err_msg,1)
            return ""
        i = (i + 1)
        char_found = hx_strings_Strings.charAt8(in_str,i)
        while ("" != char_found):
            if ((" " != char_found) and (("\t" != char_found))):
                break
            i = (i + 1)
            char_found = hx_strings_Strings.charAt8(in_str,i)
        if ("" == char_found):
            err_msg = ("ERROR: getStrML no visible character after = at line " + Std.string(start_line))
            _this1 = self.error_msgs
            _this1.append(err_msg)
            forGL_ForGL_ui.status("")
            forGL_ForGL_ui.error(err_msg,1)
            return ""
        is_first_quote = False
        is_triple_quote = False
        temp = hx_strings_Strings.substring8(in_str,i)
        if ("\"" == hx_strings_Strings.charAt8(temp,0)):
            is_first_quote = True
            if (3 <= ((0 if ((temp is None)) else len(temp)))):
                if (("\"" == hx_strings_Strings.charAt8(temp,1)) and (("\"" == hx_strings_Strings.charAt8(temp,2)))):
                    is_triple_quote = True
        if ((not is_triple_quote) and is_first_quote):
            getStr_result = self.getStr(temp)
            self.valid_str_ML = True
            return getStr_result
        if (not is_triple_quote):
            self.valid_str_ML = True
            result = temp
            if (4 == word_type):
                tempLines = list()
                current_line = (start_line + 1)
                while (current_line < len(self.fileLines)):
                    temp = (self.fileLines[current_line] if current_line >= 0 and current_line < len(self.fileLines) else None)
                    if ((0 < ((0 if ((temp is None)) else len(temp)))) and (("[" == hx_strings_Strings.charAt8(temp,0)))):
                        break
                    tempLines.append(temp)
                    self.getStrML_end_line = current_line
                    current_line = (current_line + 1)
                t = (len(tempLines) - 1)
                while (0 <= t):
                    temp = (tempLines[t] if t >= 0 and t < len(tempLines) else None)
                    if (0 < ((0 if ((temp is None)) else len(temp)))):
                        break
                    if (len(tempLines) != 0):
                        tempLines.pop()
                    t = (t - 1)
                t = 0
                while (t < len(tempLines)):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((tempLines[t] if t >= 0 and t < len(tempLines) else None)))
                    t = (t + 1)
                    if (t == len(tempLines)):
                        break
                    result = (Std.string(result) + "\n")
            hx_strings_Strings.trim(result)
            return result
        temp = hx_strings_Strings.substring8(temp,3)
        current_line1 = start_line
        while ("\"\"\"" != hx_strings_Strings.right(temp,3)):
            result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string(temp))
            result = (Std.string(result) + "\n")
            current_line1 = (current_line1 + 1)
            if (len(self.fileLines) <= current_line1):
                self.getStrML_end_line = current_line1
                err_msg = "ERROR: Missing \"\"\" (3 double quote characters) at end.\n"
                _this2 = self.error_msgs
                _this2.append(err_msg)
                forGL_ForGL_ui.status("")
                forGL_ForGL_ui.error(err_msg,1)
                return ""
            temp = (self.fileLines[current_line1] if current_line1 >= 0 and current_line1 < len(self.fileLines) else None)
        temp = hx_strings_Strings.substring8(temp,0,(((0 if ((temp is None)) else len(temp))) - 3))
        result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string(temp))
        self.getStrML_end_line = current_line1
        self.valid_str_ML = True
        return result

    def getWordList(self,warn_not_unique = True):
        if (warn_not_unique is None):
            warn_not_unique = True
        #  Get a list of Words declared                                                      ")
        i = 0
        ret_list = list()
        if (0 < len(self.word_list)):
            #  This can be called multiple times. If list already found just return a Copy.      ")
            i = 0
            while (i < len(self.word_list)):
                x = (self.word_list[i] if i >= 0 and i < len(self.word_list) else None)
                ret_list.append(x)
                i = (i + 1)
            return ret_list
        k = 0
        k_limit = 0
        line_num = "0"
        line_limit = (len(self.fileLines) - 1)
        line_buf = ""
        word_type = 0
        word_name = ""
        built_in_name = ""
        value = ""
        while (i < len(self.sections)):
            word_type = 0
            word_name = ""
            built_in_name = ""
            value = ""
            k = (self.sections[i] if i >= 0 and i < len(self.sections) else None)
            if (i < ((len(self.sections) - 1))):
                k_limit = (python_internal_ArrayImpl._get(self.sections, (i + 1)) - 1)
            else:
                k_limit = line_limit
            k = (k + 1)
            while (k <= k_limit):
                line_buf = (self.fileLines[k] if k >= 0 and k < len(self.fileLines) else None)
                line_num = Std.string((k + 1))
                if ("word_type" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 9)) else hx_strings_Strings.substring8(line_buf,0,9)))):
                    temp_word_type_str = self.getStr(line_buf,True)
                    if (0 != self.getStr_type):
                        word_type = self.getStr_type
                    else:
                        warn_msg = (((("WARNING: Invalid word type: " + Std.string(temp_word_type_str)) + " at line ") + ("null" if line_num is None else line_num)) + " found. Skipping to next word.\n")
                        _this = self.warning_msgs
                        _this.append(warn_msg)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg,1,False,True)
                        break
                elif ("name" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 4)) else hx_strings_Strings.substring8(line_buf,0,4)))):
                    if (0 == word_type):
                        warn_msg1 = (("WARNING: word_type needs to be before name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this1 = self.warning_msgs
                        _this1.append(warn_msg1)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg1,1,False,True)
                        break
                    temp_name = self.getStr(line_buf)
                    valid_name = False
                    if (0 < ((0 if ((temp_name is None)) else len(temp_name)))):
                        if (2 == word_type):
                            valid_name = self.nameValidate(temp_name,False)
                        else:
                            valid_name = self.nameValidate(temp_name)
                        if (valid_name and warn_not_unique):
                            n = 0
                            word_name_lower = hx_strings_Strings.toLowerCase8(temp_name)
                            while (n < len(self.word_list)):
                                if (hx_strings_Strings.toLowerCase8((self.word_list[n] if n >= 0 and n < len(self.word_list) else None)) == word_name_lower):
                                    break
                                n = (n + 1)
                            if (n < len(self.word_list)):
                                warn_msg2 = (((("\nWARNING: word_name " + Std.string(temp_name)) + " at line ") + ("null" if line_num is None else line_num)) + " is not unique. Spelling matches earlier word.\n")
                                _this2 = self.warning_msgs
                                _this2.append(warn_msg2)
                                forGL_ForGL_ui.status("")
                                forGL_ForGL_ui.status(warn_msg2,1,False,True)
                                break
                    if valid_name:
                        word_name = temp_name
                    else:
                        warn_msg3 = (((("WARNING: Invalid name: " + Std.string(temp_name)) + " at line ") + ("null" if line_num is None else line_num)) + ". Skipping.\n")
                        _this3 = self.warning_msgs
                        _this3.append(warn_msg3)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg3,1,False,True)
                        break
                elif ("built_in_name" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 13)) else hx_strings_Strings.substring8(line_buf,0,13)))):
                    if (0 == word_type):
                        warn_msg4 = (("WARNING: word_type needs to be before built_in_name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this4 = self.warning_msgs
                        _this4.append(warn_msg4)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg4,1,False,True)
                        break
                    if (0 == ((0 if ((word_name is None)) else len(word_name)))):
                        warn_msg5 = (("WARNING: name needs to be before built_in_name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this5 = self.warning_msgs
                        _this5.append(warn_msg5)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg5,1,False,True)
                        break
                    temp_built_in_name = self.getStr(line_buf)
                    valid_built_in_name = False
                    if (0 < ((0 if ((temp_built_in_name is None)) else len(temp_built_in_name)))):
                        if (2 == word_type):
                            valid_built_in_name = self.nameValidate(temp_built_in_name,False)
                        else:
                            valid_built_in_name = self.nameValidate(temp_built_in_name)
                    if valid_built_in_name:
                        built_in_name = temp_built_in_name
                    else:
                        warn_msg6 = (((("WARNING: Invalid built in name: " + Std.string(temp_built_in_name)) + " at line ") + ("null" if line_num is None else line_num)) + " found. Skipping to next word.\n")
                        _this6 = self.warning_msgs
                        _this6.append(warn_msg6)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg6,1,False,True)
                        break
                elif ("value" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 5)) else hx_strings_Strings.substring8(line_buf,0,5)))):
                    if (0 == word_type):
                        warn_msg7 = (("WARNING: word_type needs to be before value at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this7 = self.warning_msgs
                        _this7.append(warn_msg7)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg7,1,False,True)
                        break
                    if (0 == ((0 if ((word_name is None)) else len(word_name)))):
                        warn_msg8 = (("WARNING: name needs to be before value at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this8 = self.warning_msgs
                        _this8.append(warn_msg8)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg8,1,False,True)
                        break
                    temp_value = self.getStrML(word_type,line_buf,k)
                    if self.valid_str_ML:
                        value = temp_value
                        if (k_limit <= self.getStrML_end_line):
                            k = k_limit
                        else:
                            k = self.getStrML_end_line
                else:
                    tmp = ((((0 if ((line_buf is None)) else len(line_buf))) >= 9) and (("#" != hx_strings_Strings.charAt8(line_buf,0))))
                if (((k_limit <= k) and ((0 != word_type))) and ((0 < ((0 if ((word_name is None)) else len(word_name)))))):
                    if ("" == built_in_name):
                        if (2 == word_type):
                            err_msg = (((("\nERROR: Operator word_name " + Std.string(word_name)) + " near line ") + ("null" if line_num is None else line_num)) + " missing built_in_name.\n")
                            _this9 = self.error_msgs
                            _this9.append(err_msg)
                            forGL_ForGL_ui.status("")
                            forGL_ForGL_ui.error(err_msg,1)
                            break
                        built_in_name = hx_strings_Strings.toLowerCase8(word_name)
                    _this10 = self.type_list
                    _this10.append(word_type)
                    _this11 = self.word_list
                    _this11.append(word_name)
                    _this12 = self.built_in_list
                    _this12.append(built_in_name)
                    _this13 = self.value_list
                    _this13.append(value)
                k = (k + 1)
            i = (i + 1)
        i = 0
        while (i < len(self.word_list)):
            x1 = (self.word_list[i] if i >= 0 and i < len(self.word_list) else None)
            ret_list.append(x1)
            i = (i + 1)
        return ret_list

    def getWord(self,word_visible_name,rInfo):
        #  Get details about a known word in a file.                                         ")
        #  The correctness of the word needs checking by caller at Dictionary level.         ")
        #  Sets  getWord_type  and  getWord_word_idx  as well                                ")
        ret_val = 0
        self.getWord_type = 0
        self.getWord_word_idx = -1
        rInfo.resolve_op_meaning = 0
        rInfo.resolve_out_token = ""
        rInfo.resolve_use_out = False
        rInfo.resolve_token_noun_data = 0
        rInfo.resolve_str = ""
        rInfo.resolve_float = 0.0
        rInfo.resolve_int = 0
        n = 0
        word_name_lower = hx_strings_Strings.toLowerCase8(word_visible_name)
        while (n < len(self.word_list)):
            if ((self.word_list[n] if n >= 0 and n < len(self.word_list) else None) == word_visible_name):
                break
            if (hx_strings_Strings.toLowerCase8((self.word_list[n] if n >= 0 and n < len(self.word_list) else None)) == word_name_lower):
                break
            n = (n + 1)
        if (n < len(self.word_list)):
            #  Found the word                                                                    ")
            self.getWord_word_idx = n
            word_type = (self.type_list[n] if n >= 0 and n < len(self.type_list) else None)
            if (2 == word_type):
                #                                                                                    ")
                #  Also this may be a Built In Verb name in a different language.                    ")
                #  See  NLImport  importWords  for details.                                          ")
                #                                                                                    ")
                self.getWord_type = 2
                rInfo.resolve_use_out = True
                #  Example in  importWords                                                           ")
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (6 == word_type):
                self.getWord_type = 6
                rInfo.resolve_token_noun_data = 8
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (4 == word_type):
                self.getWord_type = 4
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (12 == word_type):
                self.getWord_type = 12
                rInfo.resolve_use_out = True
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Unexpected word type in getWord.",1)
            rInfo.resolve_out_token = (self.built_in_list[n] if n >= 0 and n < len(self.built_in_list) else None)
        else:
            ret_val = -3
        return ret_val

    def changeOrAddWord(self,word_visible_name,word_type,rInfo):
        #  Change contents or Add a new word                                                 ")
        ret_val = 0
        self.changeOrAddWord_changed = False
        self.changeOrAddWord_msgs = ""
        get_rInfo = forGL_ResolveInfo()
        value = ""
        idx = -1
        getWord_result = self.getWord(word_visible_name,get_rInfo)
        if (4 == word_type):
            value = rInfo.resolve_str
        elif (6 == word_type):
            if (8 == rInfo.resolve_token_noun_data):
                value = rInfo.resolve_str
                if (((((0 if ((value is None)) else len(value))) < 2) or (("\"" != hx_strings_Strings.charAt8(value,0)))) or (("\"" != hx_strings_Strings.charAt8(value,(((0 if ((value is None)) else len(value))) - 1))))):
                    value = (("\"" + Std.string(value)) + "\"")
            elif (11 == rInfo.resolve_token_noun_data):
                value = Std.string(rInfo.resolve_float)
            elif (9 == rInfo.resolve_token_noun_data):
                value = Std.string(rInfo.resolve_int)
            elif (10 == rInfo.resolve_token_noun_data):
                if (1 == rInfo.resolve_int):
                    value = "true"
                else:
                    value = "false"
            else:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.changeOrAddWord_msgs
                _hx_local_0.changeOrAddWord_msgs = (Std.string(_hx_local_1) + HxOverrides.stringOrNull(((("INTERNAL ERROR: Noun type not recognized: " + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(rInfo.resolve_token_noun_data))) + "\n"))))
                _hx_local_0.changeOrAddWord_msgs
                value = "0"
                ret_val = -11
        def _hx_local_0():
            _hx_local_2 = getWord_result
            if (Std._hx_is(_hx_local_2,Int) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise _HxException("Class cast error")
            return _hx_local_2
        if (0 == _hx_local_0()):
            self.changeOrAddWord_changed = True
            idx1 = self.getWord_word_idx
            python_internal_ArrayImpl._set(self.type_list, idx1, word_type)
            python_internal_ArrayImpl._set(self.word_list, idx1, word_visible_name)
            if ((2 == word_type) or ((12 == word_type))):
                python_internal_ArrayImpl._set(self.built_in_list, idx1, rInfo.resolve_out_token)
            else:
                python_internal_ArrayImpl._set(self.value_list, idx1, value)
        else:
            _this = self.word_list
            _this.append(word_visible_name)
            _this1 = self.type_list
            _this1.append(word_type)
            if ((2 == word_type) or ((12 == word_type))):
                _this2 = self.built_in_list
                x = rInfo.resolve_out_token
                _this2.append(x)
                value = ""
            else:
                _this3 = self.built_in_list
                _this3.append("")
            _this4 = self.value_list
            _this4.append(value)
        return ret_val

    def saveData(self,new_path_name):
        #  Save in memory Data to a File                                                     ")
        ret_val = 0
        try:
            out_file = sys_io_File.write(new_path_name,False)
            line = ""
            word_idx = -1
            word_type_idx = -1
            name_idx = -1
            built_in_idx = -1
            value_idx = -1
            found_name = False
            temp_name = ""
            temp_type = 0
            temp_built_in = ""
            temp_value = ""
            rInfo = forGL_ResolveInfo()
            words_to_do = self.getWordList(False)
            if (0 == len(words_to_do)):
                return 0
            i = 0
            while (i < len(self.fileLines)):
                line = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                if ((0 == ((0 if ((line is None)) else len(line)))) or (("#" == hx_strings_Strings.charAt8(line,0)))):
                    i = (i + 1)
                    continue
                if ("word_type" == ((line if ((((0 if ((line is None)) else len(line))) <= 9)) else hx_strings_Strings.substring8(line,0,9)))):
                    word_idx = -1
                    name_idx = -1
                    built_in_idx = -1
                    value_idx = -1
                    word_type_idx = i
                    self.getStr(line,True)
                    temp_type = self.getStr_type
                elif ("name" == ((line if ((((0 if ((line is None)) else len(line))) <= 4)) else hx_strings_Strings.substring8(line,0,4)))):
                    name_idx = i
                    temp_name = self.getStr(line)
                    getWord_result = self.getWord(temp_name,rInfo)
                    def _hx_local_0():
                        _hx_local_1 = getWord_result
                        if (Std._hx_is(_hx_local_1,Int) or ((_hx_local_1 is None))):
                            _hx_local_1
                        else:
                            raise _HxException("Class cast error")
                        return _hx_local_1
                    if (0 == _hx_local_0()):
                        word_idx = self.getWord_word_idx
                        found_name = True
                elif ("built_in_name" == ((line if ((((0 if ((line is None)) else len(line))) <= 13)) else hx_strings_Strings.substring8(line,0,13)))):
                    built_in_idx = i
                elif ("value" == ((line if ((((0 if ((line is None)) else len(line))) <= 5)) else hx_strings_Strings.substring8(line,0,5)))):
                    value_idx = i
                else:
                    i = (i + 1)
                    continue
                if ((0 <= built_in_idx) or ((0 <= value_idx))):
                    if found_name:
                        if (2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"operator\"")
                        elif (6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"noun\"")
                        elif (4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"verb\"")
                        elif (12 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"choice\"")
                        python_internal_ArrayImpl._set(self.fileLines, name_idx, (("name = \"" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "\""))
                        if ((2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)) or ((12 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)))):
                            python_internal_ArrayImpl._set(self.fileLines, built_in_idx, (("built_in_name = \"" + Std.string((self.built_in_list[word_idx] if word_idx >= 0 and word_idx < len(self.built_in_list) else None))) + "\""))
                        else:
                            python_internal_ArrayImpl._set(self.fileLines, value_idx, ("value = " + Std.string((self.value_list[word_idx] if word_idx >= 0 and word_idx < len(self.value_list) else None))))
                        python_internal_ArrayImpl.remove(words_to_do,temp_name)
                        temp_name = ""
                        found_name = False
                i = (i + 1)
            i = 0
            while (i < len(self.fileLines)):
                line = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                out_file.writeString((Std.string(line) + "\n"))
                i = (i + 1)
            out_file.flush()
            word_name = ""
            k = 0
            i = 0
            while (i < len(words_to_do)):
                word_name = (words_to_do[i] if i >= 0 and i < len(words_to_do) else None)
                k = 0
                while (k < len(self.word_list)):
                    if (word_name == (self.word_list[k] if k >= 0 and k < len(self.word_list) else None)):
                        word_idx = k
                        break
                    k = (k + 1)
                if (len(self.word_list) <= k):
                    line = (("# INTERNAL ERROR: Expected word " + Std.string((words_to_do[i] if i >= 0 and i < len(words_to_do) else None))) + " not found.")
                    out_file.writeString((Std.string(line) + "\n"))
                    i = (i + 1)
                    continue
                out_file.writeString("\n")
                line = (("[_" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "_]")
                out_file.writeString((Std.string(line) + "\n"))
                line = "word_type = \""
                if (2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "operator\"")
                elif (6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "noun\"")
                elif (4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "verb\"")
                elif (12 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "choice\"")
                else:
                    line = ((("# INTERNAL ERROR: word " + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + " has invalid word_type : ") + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr((self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None))))
                    out_file.writeString((Std.string(line) + "\n"))
                    i = (i + 1)
                    continue
                out_file.writeString((Std.string(line) + "\n"))
                line = (("name = \"" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "\"")
                out_file.writeString((Std.string(line) + "\n"))
                if ((6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)) or ((4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)))):
                    line = ("value = " + Std.string((self.value_list[word_idx] if word_idx >= 0 and word_idx < len(self.value_list) else None)))
                else:
                    line = (("built_in_name = \"" + Std.string((self.built_in_list[word_idx] if word_idx >= 0 and word_idx < len(self.built_in_list) else None))) + "\"")
                out_file.writeString((Std.string(line) + "\n"))
                i = (i + 1)
            out_file.flush()
            out_file.close()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            forGL_ForGL_ui.msg((("\nException in saveData(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.actual_path_file = None
        _hx_o.actual_file_type = None
        _hx_o.error_msgs = None
        _hx_o.warning_msgs = None
        _hx_o.data_call_count = None
        _hx_o.fReadHandle = None
        _hx_o.ws_chars = None
        _hx_o.fileLines = None
        _hx_o.comment_lines = None
        _hx_o.sections = None
        _hx_o.section_names = None
        _hx_o.word_list = None
        _hx_o.type_list = None
        _hx_o.built_in_list = None
        _hx_o.value_list = None
        _hx_o.getStr_type = None
        _hx_o.getStrML_end_line = None
        _hx_o.valid_str_ML = None
        _hx_o.getWord_type = None
        _hx_o.getWord_word_idx = None
        _hx_o.changeOrAddWord_changed = None
        _hx_o.changeOrAddWord_msgs = None


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v1))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + "\n"))


class haxe_Utf8:
    _hx_class_name = "haxe.Utf8"
    __slots__ = ()
    _hx_statics = ["compare"]

    @staticmethod
    def compare(a,b):
        if (a > b):
            return 1
        elif (a == b):
            return 0
        else:
            return -1


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["get", "update"]
    _hx_statics = ["make"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def get(self):
        return ((self.a2 << 16) | self.a1)

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    @staticmethod
    def make(b):
        a = haxe_crypto_Adler32()
        a.update(b,0,b.length)
        return a.get()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString", "toString"]
    _hx_statics = ["alloc", "ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = True):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = True):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise _HxException("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos2 = pout
            pout = (pout + 1)
            v1 = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos2] = (v1 & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g1 = 0
        _g2 = self.base.length
        while (_g1 < _g2):
            i1 = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i1], i1)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise _HxException("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None


class haxe_crypto_Crc32:
    _hx_class_name = "haxe.crypto.Crc32"
    __slots__ = ()
    _hx_statics = ["make"]

    @staticmethod
    def make(data):
        c_crc = -1
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = (((c_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
        return (c_crc ^ -1)


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = list()

    def getBytes(self):
        buf = bytearray(self.b)
        _hx_bytes = haxe_io_Bytes(len(buf),buf)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        _this = self.b.b
        _this.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b1 = _this.b
        b2 = buf.b
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this1 = _this.b
            _this1.append(b2[i])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, list())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, list())


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())


class haxe_iterators_StringIterator:
    _hx_class_name = "haxe.iterators.StringIterator"
    __slots__ = ("s",)
    _hx_fields = ["s"]

    def __init__(self,s):
        self.s = s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None


class haxe_iterators_StringKeyValueIterator:
    _hx_class_name = "haxe.iterators.StringKeyValueIterator"
    __slots__ = ("s",)
    _hx_fields = ["s"]

    def __init__(self,s):
        self.s = s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None

class haxe_macro_Constant(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Constant"
    _hx_constructs = ["CInt", "CFloat", "CString", "CIdent", "CRegexp"]

    @staticmethod
    def CInt(v):
        return haxe_macro_Constant("CInt", 0, [v])

    @staticmethod
    def CFloat(f):
        return haxe_macro_Constant("CFloat", 1, [f])

    @staticmethod
    def CString(s):
        return haxe_macro_Constant("CString", 2, [s])

    @staticmethod
    def CIdent(s):
        return haxe_macro_Constant("CIdent", 3, [s])

    @staticmethod
    def CRegexp(r,opt):
        return haxe_macro_Constant("CRegexp", 4, [r,opt])

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, [op])
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, list())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, list())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, list())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, list())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, list())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, list())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, list())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, list())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, list())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, list())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, list())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, list())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, list())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, list())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, list())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, list())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, list())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, list())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, list())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, list())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, list())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, list())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, list())

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, list())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, list())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, list())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, list())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, list())

class haxe_macro_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ExprDef"
    _hx_constructs = ["EConst", "EArray", "EBinop", "EField", "EParenthesis", "EObjectDecl", "EArrayDecl", "ECall", "ENew", "EUnop", "EVars", "EFunction", "EBlock", "EFor", "EIf", "EWhile", "ESwitch", "ETry", "EReturn", "EBreak", "EContinue", "EUntyped", "EThrow", "ECast", "EDisplay", "EDisplayNew", "ETernary", "ECheckType", "EMeta"]

    @staticmethod
    def EConst(c):
        return haxe_macro_ExprDef("EConst", 0, [c])

    @staticmethod
    def EArray(e1,e2):
        return haxe_macro_ExprDef("EArray", 1, [e1,e2])

    @staticmethod
    def EBinop(op,e1,e2):
        return haxe_macro_ExprDef("EBinop", 2, [op,e1,e2])

    @staticmethod
    def EField(e,field):
        return haxe_macro_ExprDef("EField", 3, [e,field])

    @staticmethod
    def EParenthesis(e):
        return haxe_macro_ExprDef("EParenthesis", 4, [e])

    @staticmethod
    def EObjectDecl(fields):
        return haxe_macro_ExprDef("EObjectDecl", 5, [fields])

    @staticmethod
    def EArrayDecl(values):
        return haxe_macro_ExprDef("EArrayDecl", 6, [values])

    @staticmethod
    def ECall(e,params):
        return haxe_macro_ExprDef("ECall", 7, [e,params])

    @staticmethod
    def ENew(t,params):
        return haxe_macro_ExprDef("ENew", 8, [t,params])

    @staticmethod
    def EUnop(op,postFix,e):
        return haxe_macro_ExprDef("EUnop", 9, [op,postFix,e])

    @staticmethod
    def EVars(vars):
        return haxe_macro_ExprDef("EVars", 10, [vars])

    @staticmethod
    def EFunction(name,f):
        return haxe_macro_ExprDef("EFunction", 11, [name,f])

    @staticmethod
    def EBlock(exprs):
        return haxe_macro_ExprDef("EBlock", 12, [exprs])

    @staticmethod
    def EFor(it,expr):
        return haxe_macro_ExprDef("EFor", 13, [it,expr])

    @staticmethod
    def EIf(econd,eif,eelse):
        return haxe_macro_ExprDef("EIf", 14, [econd,eif,eelse])

    @staticmethod
    def EWhile(econd,e,normalWhile):
        return haxe_macro_ExprDef("EWhile", 15, [econd,e,normalWhile])

    @staticmethod
    def ESwitch(e,cases,edef):
        return haxe_macro_ExprDef("ESwitch", 16, [e,cases,edef])

    @staticmethod
    def ETry(e,catches):
        return haxe_macro_ExprDef("ETry", 17, [e,catches])

    @staticmethod
    def EReturn(e = None):
        return haxe_macro_ExprDef("EReturn", 18, [e])

    @staticmethod
    def EUntyped(e):
        return haxe_macro_ExprDef("EUntyped", 21, [e])

    @staticmethod
    def EThrow(e):
        return haxe_macro_ExprDef("EThrow", 22, [e])

    @staticmethod
    def ECast(e,t):
        return haxe_macro_ExprDef("ECast", 23, [e,t])

    @staticmethod
    def EDisplay(e,displayKind):
        return haxe_macro_ExprDef("EDisplay", 24, [e,displayKind])

    @staticmethod
    def EDisplayNew(t):
        return haxe_macro_ExprDef("EDisplayNew", 25, [t])

    @staticmethod
    def ETernary(econd,eif,eelse):
        return haxe_macro_ExprDef("ETernary", 26, [econd,eif,eelse])

    @staticmethod
    def ECheckType(e,t):
        return haxe_macro_ExprDef("ECheckType", 27, [e,t])

    @staticmethod
    def EMeta(s,e):
        return haxe_macro_ExprDef("EMeta", 28, [s,e])
haxe_macro_ExprDef.EBreak = haxe_macro_ExprDef("EBreak", 19, list())
haxe_macro_ExprDef.EContinue = haxe_macro_ExprDef("EContinue", 20, list())

class haxe_macro_DisplayKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.DisplayKind"
    _hx_constructs = ["DKCall", "DKDot", "DKStructure", "DKMarked", "DKPattern"]

    @staticmethod
    def DKPattern(outermost):
        return haxe_macro_DisplayKind("DKPattern", 4, [outermost])
haxe_macro_DisplayKind.DKCall = haxe_macro_DisplayKind("DKCall", 0, list())
haxe_macro_DisplayKind.DKDot = haxe_macro_DisplayKind("DKDot", 1, list())
haxe_macro_DisplayKind.DKStructure = haxe_macro_DisplayKind("DKStructure", 2, list())
haxe_macro_DisplayKind.DKMarked = haxe_macro_DisplayKind("DKMarked", 3, list())

class haxe_macro_ComplexType(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ComplexType"
    _hx_constructs = ["TPath", "TFunction", "TAnonymous", "TParent", "TExtend", "TOptional", "TNamed", "TIntersection"]

    @staticmethod
    def TPath(p):
        return haxe_macro_ComplexType("TPath", 0, [p])

    @staticmethod
    def TFunction(args,ret):
        return haxe_macro_ComplexType("TFunction", 1, [args,ret])

    @staticmethod
    def TAnonymous(fields):
        return haxe_macro_ComplexType("TAnonymous", 2, [fields])

    @staticmethod
    def TParent(t):
        return haxe_macro_ComplexType("TParent", 3, [t])

    @staticmethod
    def TExtend(p,fields):
        return haxe_macro_ComplexType("TExtend", 4, [p,fields])

    @staticmethod
    def TOptional(t):
        return haxe_macro_ComplexType("TOptional", 5, [t])

    @staticmethod
    def TNamed(n,t):
        return haxe_macro_ComplexType("TNamed", 6, [n,t])

    @staticmethod
    def TIntersection(tl):
        return haxe_macro_ComplexType("TIntersection", 7, [tl])


class hx_strings__AnyAsString_AnyAsString_Impl_:
    _hx_class_name = "hx.strings._AnyAsString.AnyAsString_Impl_"
    __slots__ = ()
    _hx_statics = ["fromBool", "fromAny"]

    @staticmethod
    def fromBool(value):
        if value:
            return "true"
        else:
            return "false"

    @staticmethod
    def fromAny(value):
        return Std.string(value)


class hx_strings__Char_CharCaseMapper:
    _hx_class_name = "hx.strings._Char.CharCaseMapper"
    __slots__ = ("mapU2L", "mapL2U")
    _hx_fields = ["mapU2L", "mapL2U"]
    _hx_methods = ["_addCaseMapping", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase"]

    def __init__(self):
        self.mapL2U = haxe_ds_IntMap()
        self.mapU2L = haxe_ds_IntMap()
        self._addCaseMapping(97,65)
        self._addCaseMapping(98,66)
        self._addCaseMapping(99,67)
        self._addCaseMapping(100,68)
        self._addCaseMapping(101,69)
        self._addCaseMapping(102,70)
        self._addCaseMapping(103,71)
        self._addCaseMapping(104,72)
        self._addCaseMapping(105,73)
        self._addCaseMapping(106,74)
        self._addCaseMapping(107,75)
        self._addCaseMapping(108,76)
        self._addCaseMapping(109,77)
        self._addCaseMapping(110,78)
        self._addCaseMapping(111,79)
        self._addCaseMapping(112,80)
        self._addCaseMapping(113,81)
        self._addCaseMapping(114,82)
        self._addCaseMapping(115,83)
        self._addCaseMapping(116,84)
        self._addCaseMapping(117,85)
        self._addCaseMapping(118,86)
        self._addCaseMapping(119,87)
        self._addCaseMapping(120,88)
        self._addCaseMapping(121,89)
        self._addCaseMapping(122,90)
        self._addCaseMapping(224,192)
        self._addCaseMapping(225,193)
        self._addCaseMapping(226,194)
        self._addCaseMapping(227,195)
        self._addCaseMapping(228,196)
        self._addCaseMapping(229,197)
        self._addCaseMapping(230,198)
        self._addCaseMapping(231,199)
        self._addCaseMapping(232,200)
        self._addCaseMapping(233,201)
        self._addCaseMapping(234,202)
        self._addCaseMapping(235,203)
        self._addCaseMapping(236,204)
        self._addCaseMapping(237,205)
        self._addCaseMapping(238,206)
        self._addCaseMapping(239,207)
        self._addCaseMapping(240,208)
        self._addCaseMapping(241,209)
        self._addCaseMapping(242,210)
        self._addCaseMapping(243,211)
        self._addCaseMapping(244,212)
        self._addCaseMapping(245,213)
        self._addCaseMapping(246,214)
        self._addCaseMapping(248,216)
        self._addCaseMapping(249,217)
        self._addCaseMapping(250,218)
        self._addCaseMapping(251,219)
        self._addCaseMapping(252,220)
        self._addCaseMapping(253,221)
        self._addCaseMapping(254,222)
        self._addCaseMapping(255,376)
        self._addCaseMapping(257,256)
        self._addCaseMapping(259,258)
        self._addCaseMapping(261,260)
        self._addCaseMapping(263,262)
        self._addCaseMapping(265,264)
        self._addCaseMapping(267,266)
        self._addCaseMapping(269,268)
        self._addCaseMapping(271,270)
        self._addCaseMapping(273,272)
        self._addCaseMapping(275,274)
        self._addCaseMapping(277,276)
        self._addCaseMapping(279,278)
        self._addCaseMapping(281,280)
        self._addCaseMapping(283,282)
        self._addCaseMapping(285,284)
        self._addCaseMapping(287,286)
        self._addCaseMapping(289,288)
        self._addCaseMapping(291,290)
        self._addCaseMapping(293,292)
        self._addCaseMapping(295,294)
        self._addCaseMapping(297,296)
        self._addCaseMapping(299,298)
        self._addCaseMapping(301,300)
        self._addCaseMapping(303,302)
        self._addCaseMapping(305,73)
        self._addCaseMapping(307,306)
        self._addCaseMapping(309,308)
        self._addCaseMapping(311,310)
        self._addCaseMapping(314,313)
        self._addCaseMapping(316,315)
        self._addCaseMapping(318,317)
        self._addCaseMapping(320,319)
        self._addCaseMapping(322,321)
        self._addCaseMapping(324,323)
        self._addCaseMapping(326,325)
        self._addCaseMapping(328,327)
        self._addCaseMapping(331,330)
        self._addCaseMapping(333,332)
        self._addCaseMapping(335,334)
        self._addCaseMapping(337,336)
        self._addCaseMapping(339,338)
        self._addCaseMapping(341,340)
        self._addCaseMapping(343,342)
        self._addCaseMapping(345,344)
        self._addCaseMapping(347,346)
        self._addCaseMapping(349,348)
        self._addCaseMapping(351,350)
        self._addCaseMapping(353,352)
        self._addCaseMapping(355,354)
        self._addCaseMapping(357,356)
        self._addCaseMapping(359,358)
        self._addCaseMapping(361,360)
        self._addCaseMapping(363,362)
        self._addCaseMapping(365,364)
        self._addCaseMapping(367,366)
        self._addCaseMapping(369,368)
        self._addCaseMapping(371,370)
        self._addCaseMapping(373,372)
        self._addCaseMapping(375,374)
        self._addCaseMapping(378,377)
        self._addCaseMapping(380,379)
        self._addCaseMapping(382,381)
        self._addCaseMapping(387,386)
        self._addCaseMapping(389,388)
        self._addCaseMapping(392,391)
        self._addCaseMapping(396,395)
        self._addCaseMapping(402,401)
        self._addCaseMapping(409,408)
        self._addCaseMapping(417,416)
        self._addCaseMapping(419,418)
        self._addCaseMapping(421,420)
        self._addCaseMapping(424,423)
        self._addCaseMapping(429,428)
        self._addCaseMapping(432,431)
        self._addCaseMapping(436,435)
        self._addCaseMapping(438,437)
        self._addCaseMapping(441,440)
        self._addCaseMapping(445,444)
        self._addCaseMapping(454,452)
        self._addCaseMapping(457,455)
        self._addCaseMapping(460,458)
        self._addCaseMapping(462,461)
        self._addCaseMapping(464,463)
        self._addCaseMapping(466,465)
        self._addCaseMapping(468,467)
        self._addCaseMapping(470,469)
        self._addCaseMapping(472,471)
        self._addCaseMapping(474,473)
        self._addCaseMapping(476,475)
        self._addCaseMapping(479,478)
        self._addCaseMapping(481,480)
        self._addCaseMapping(483,482)
        self._addCaseMapping(485,484)
        self._addCaseMapping(487,486)
        self._addCaseMapping(489,488)
        self._addCaseMapping(491,490)
        self._addCaseMapping(493,492)
        self._addCaseMapping(495,494)
        self._addCaseMapping(499,497)
        self._addCaseMapping(501,500)
        self._addCaseMapping(507,506)
        self._addCaseMapping(509,508)
        self._addCaseMapping(511,510)
        self._addCaseMapping(513,512)
        self._addCaseMapping(515,514)
        self._addCaseMapping(517,516)
        self._addCaseMapping(519,518)
        self._addCaseMapping(521,520)
        self._addCaseMapping(523,522)
        self._addCaseMapping(525,524)
        self._addCaseMapping(527,526)
        self._addCaseMapping(529,528)
        self._addCaseMapping(531,530)
        self._addCaseMapping(533,532)
        self._addCaseMapping(535,534)
        self._addCaseMapping(595,385)
        self._addCaseMapping(596,390)
        self._addCaseMapping(599,394)
        self._addCaseMapping(600,398)
        self._addCaseMapping(601,399)
        self._addCaseMapping(603,400)
        self._addCaseMapping(608,403)
        self._addCaseMapping(611,404)
        self._addCaseMapping(616,407)
        self._addCaseMapping(617,406)
        self._addCaseMapping(623,412)
        self._addCaseMapping(626,413)
        self._addCaseMapping(629,415)
        self._addCaseMapping(643,425)
        self._addCaseMapping(648,430)
        self._addCaseMapping(650,433)
        self._addCaseMapping(651,434)
        self._addCaseMapping(658,439)
        self._addCaseMapping(924,181)
        self._addCaseMapping(940,902)
        self._addCaseMapping(941,904)
        self._addCaseMapping(942,905)
        self._addCaseMapping(943,906)
        self._addCaseMapping(945,913)
        self._addCaseMapping(946,914)
        self._addCaseMapping(947,915)
        self._addCaseMapping(948,916)
        self._addCaseMapping(949,917)
        self._addCaseMapping(950,918)
        self._addCaseMapping(951,919)
        self._addCaseMapping(952,920)
        self._addCaseMapping(953,921)
        self._addCaseMapping(954,922)
        self._addCaseMapping(955,923)
        self._addCaseMapping(956,924)
        self._addCaseMapping(957,925)
        self._addCaseMapping(958,926)
        self._addCaseMapping(959,927)
        self._addCaseMapping(960,928)
        self._addCaseMapping(961,929)
        self._addCaseMapping(963,931)
        self._addCaseMapping(964,932)
        self._addCaseMapping(965,933)
        self._addCaseMapping(966,934)
        self._addCaseMapping(967,935)
        self._addCaseMapping(968,936)
        self._addCaseMapping(969,937)
        self._addCaseMapping(970,938)
        self._addCaseMapping(971,939)
        self._addCaseMapping(972,908)
        self._addCaseMapping(973,910)
        self._addCaseMapping(974,911)
        self._addCaseMapping(995,994)
        self._addCaseMapping(997,996)
        self._addCaseMapping(999,998)
        self._addCaseMapping(1001,1000)
        self._addCaseMapping(1003,1002)
        self._addCaseMapping(1005,1004)
        self._addCaseMapping(1007,1006)
        self._addCaseMapping(1072,1040)
        self._addCaseMapping(1073,1041)
        self._addCaseMapping(1074,1042)
        self._addCaseMapping(1075,1043)
        self._addCaseMapping(1076,1044)
        self._addCaseMapping(1077,1045)
        self._addCaseMapping(1078,1046)
        self._addCaseMapping(1079,1047)
        self._addCaseMapping(1080,1048)
        self._addCaseMapping(1081,1049)
        self._addCaseMapping(1082,1050)
        self._addCaseMapping(1083,1051)
        self._addCaseMapping(1084,1052)
        self._addCaseMapping(1085,1053)
        self._addCaseMapping(1086,1054)
        self._addCaseMapping(1087,1055)
        self._addCaseMapping(1088,1056)
        self._addCaseMapping(1089,1057)
        self._addCaseMapping(1090,1058)
        self._addCaseMapping(1091,1059)
        self._addCaseMapping(1092,1060)
        self._addCaseMapping(1093,1061)
        self._addCaseMapping(1094,1062)
        self._addCaseMapping(1095,1063)
        self._addCaseMapping(1096,1064)
        self._addCaseMapping(1097,1065)
        self._addCaseMapping(1098,1066)
        self._addCaseMapping(1099,1067)
        self._addCaseMapping(1100,1068)
        self._addCaseMapping(1101,1069)
        self._addCaseMapping(1102,1070)
        self._addCaseMapping(1103,1071)
        self._addCaseMapping(1105,1025)
        self._addCaseMapping(1106,1026)
        self._addCaseMapping(1107,1027)
        self._addCaseMapping(1108,1028)
        self._addCaseMapping(1109,1029)
        self._addCaseMapping(1110,1030)
        self._addCaseMapping(1111,1031)
        self._addCaseMapping(1112,1032)
        self._addCaseMapping(1113,1033)
        self._addCaseMapping(1114,1034)
        self._addCaseMapping(1115,1035)
        self._addCaseMapping(1116,1036)
        self._addCaseMapping(1118,1038)
        self._addCaseMapping(1119,1039)
        self._addCaseMapping(1121,1120)
        self._addCaseMapping(1123,1122)
        self._addCaseMapping(1125,1124)
        self._addCaseMapping(1127,1126)
        self._addCaseMapping(1129,1128)
        self._addCaseMapping(1131,1130)
        self._addCaseMapping(1133,1132)
        self._addCaseMapping(1135,1134)
        self._addCaseMapping(1137,1136)
        self._addCaseMapping(1139,1138)
        self._addCaseMapping(1141,1140)
        self._addCaseMapping(1143,1142)
        self._addCaseMapping(1145,1144)
        self._addCaseMapping(1147,1146)
        self._addCaseMapping(1149,1148)
        self._addCaseMapping(1151,1150)
        self._addCaseMapping(1153,1152)
        self._addCaseMapping(1169,1168)
        self._addCaseMapping(1171,1170)
        self._addCaseMapping(1173,1172)
        self._addCaseMapping(1175,1174)
        self._addCaseMapping(1177,1176)
        self._addCaseMapping(1179,1178)
        self._addCaseMapping(1181,1180)
        self._addCaseMapping(1183,1182)
        self._addCaseMapping(1185,1184)
        self._addCaseMapping(1187,1186)
        self._addCaseMapping(1189,1188)
        self._addCaseMapping(1191,1190)
        self._addCaseMapping(1193,1192)
        self._addCaseMapping(1195,1194)
        self._addCaseMapping(1197,1196)
        self._addCaseMapping(1199,1198)
        self._addCaseMapping(1201,1200)
        self._addCaseMapping(1203,1202)
        self._addCaseMapping(1205,1204)
        self._addCaseMapping(1207,1206)
        self._addCaseMapping(1209,1208)
        self._addCaseMapping(1211,1210)
        self._addCaseMapping(1213,1212)
        self._addCaseMapping(1215,1214)
        self._addCaseMapping(1218,1217)
        self._addCaseMapping(1220,1219)
        self._addCaseMapping(1224,1223)
        self._addCaseMapping(1228,1227)
        self._addCaseMapping(1233,1232)
        self._addCaseMapping(1235,1234)
        self._addCaseMapping(1237,1236)
        self._addCaseMapping(1239,1238)
        self._addCaseMapping(1241,1240)
        self._addCaseMapping(1243,1242)
        self._addCaseMapping(1245,1244)
        self._addCaseMapping(1247,1246)
        self._addCaseMapping(1249,1248)
        self._addCaseMapping(1251,1250)
        self._addCaseMapping(1253,1252)
        self._addCaseMapping(1255,1254)
        self._addCaseMapping(1257,1256)
        self._addCaseMapping(1259,1258)
        self._addCaseMapping(1263,1262)
        self._addCaseMapping(1265,1264)
        self._addCaseMapping(1267,1266)
        self._addCaseMapping(1269,1268)
        self._addCaseMapping(1273,1272)
        self._addCaseMapping(1377,1329)
        self._addCaseMapping(1378,1330)
        self._addCaseMapping(1379,1331)
        self._addCaseMapping(1380,1332)
        self._addCaseMapping(1381,1333)
        self._addCaseMapping(1382,1334)
        self._addCaseMapping(1383,1335)
        self._addCaseMapping(1384,1336)
        self._addCaseMapping(1385,1337)
        self._addCaseMapping(1386,1338)
        self._addCaseMapping(1387,1339)
        self._addCaseMapping(1388,1340)
        self._addCaseMapping(1389,1341)
        self._addCaseMapping(1390,1342)
        self._addCaseMapping(1391,1343)
        self._addCaseMapping(1392,1344)
        self._addCaseMapping(1393,1345)
        self._addCaseMapping(1394,1346)
        self._addCaseMapping(1395,1347)
        self._addCaseMapping(1396,1348)
        self._addCaseMapping(1397,1349)
        self._addCaseMapping(1398,1350)
        self._addCaseMapping(1399,1351)
        self._addCaseMapping(1400,1352)
        self._addCaseMapping(1401,1353)
        self._addCaseMapping(1402,1354)
        self._addCaseMapping(1403,1355)
        self._addCaseMapping(1404,1356)
        self._addCaseMapping(1405,1357)
        self._addCaseMapping(1406,1358)
        self._addCaseMapping(1407,1359)
        self._addCaseMapping(1408,1360)
        self._addCaseMapping(1409,1361)
        self._addCaseMapping(1410,1362)
        self._addCaseMapping(1411,1363)
        self._addCaseMapping(1412,1364)
        self._addCaseMapping(1413,1365)
        self._addCaseMapping(1414,1366)
        self._addCaseMapping(4304,4256)
        self._addCaseMapping(4305,4257)
        self._addCaseMapping(4306,4258)
        self._addCaseMapping(4307,4259)
        self._addCaseMapping(4308,4260)
        self._addCaseMapping(4309,4261)
        self._addCaseMapping(4310,4262)
        self._addCaseMapping(4311,4263)
        self._addCaseMapping(4312,4264)
        self._addCaseMapping(4313,4265)
        self._addCaseMapping(4314,4266)
        self._addCaseMapping(4315,4267)
        self._addCaseMapping(4316,4268)
        self._addCaseMapping(4317,4269)
        self._addCaseMapping(4318,4270)
        self._addCaseMapping(4319,4271)
        self._addCaseMapping(4320,4272)
        self._addCaseMapping(4321,4273)
        self._addCaseMapping(4322,4274)
        self._addCaseMapping(4323,4275)
        self._addCaseMapping(4324,4276)
        self._addCaseMapping(4325,4277)
        self._addCaseMapping(4326,4278)
        self._addCaseMapping(4327,4279)
        self._addCaseMapping(4328,4280)
        self._addCaseMapping(4329,4281)
        self._addCaseMapping(4330,4282)
        self._addCaseMapping(4331,4283)
        self._addCaseMapping(4332,4284)
        self._addCaseMapping(4333,4285)
        self._addCaseMapping(4334,4286)
        self._addCaseMapping(4335,4287)
        self._addCaseMapping(4336,4288)
        self._addCaseMapping(4337,4289)
        self._addCaseMapping(4338,4290)
        self._addCaseMapping(4339,4291)
        self._addCaseMapping(4340,4292)
        self._addCaseMapping(4341,4293)
        self._addCaseMapping(7681,7680)
        self._addCaseMapping(7683,7682)
        self._addCaseMapping(7685,7684)
        self._addCaseMapping(7687,7686)
        self._addCaseMapping(7689,7688)
        self._addCaseMapping(7691,7690)
        self._addCaseMapping(7693,7692)
        self._addCaseMapping(7695,7694)
        self._addCaseMapping(7697,7696)
        self._addCaseMapping(7699,7698)
        self._addCaseMapping(7701,7700)
        self._addCaseMapping(7703,7702)
        self._addCaseMapping(7705,7704)
        self._addCaseMapping(7707,7706)
        self._addCaseMapping(7709,7708)
        self._addCaseMapping(7711,7710)
        self._addCaseMapping(7713,7712)
        self._addCaseMapping(7715,7714)
        self._addCaseMapping(7717,7716)
        self._addCaseMapping(7719,7718)
        self._addCaseMapping(7721,7720)
        self._addCaseMapping(7723,7722)
        self._addCaseMapping(7725,7724)
        self._addCaseMapping(7727,7726)
        self._addCaseMapping(7729,7728)
        self._addCaseMapping(7731,7730)
        self._addCaseMapping(7733,7732)
        self._addCaseMapping(7735,7734)
        self._addCaseMapping(7737,7736)
        self._addCaseMapping(7739,7738)
        self._addCaseMapping(7741,7740)
        self._addCaseMapping(7743,7742)
        self._addCaseMapping(7745,7744)
        self._addCaseMapping(7747,7746)
        self._addCaseMapping(7749,7748)
        self._addCaseMapping(7751,7750)
        self._addCaseMapping(7753,7752)
        self._addCaseMapping(7755,7754)
        self._addCaseMapping(7757,7756)
        self._addCaseMapping(7759,7758)
        self._addCaseMapping(7761,7760)
        self._addCaseMapping(7763,7762)
        self._addCaseMapping(7765,7764)
        self._addCaseMapping(7767,7766)
        self._addCaseMapping(7769,7768)
        self._addCaseMapping(7771,7770)
        self._addCaseMapping(7773,7772)
        self._addCaseMapping(7775,7774)
        self._addCaseMapping(7777,7776)
        self._addCaseMapping(7779,7778)
        self._addCaseMapping(7781,7780)
        self._addCaseMapping(7783,7782)
        self._addCaseMapping(7785,7784)
        self._addCaseMapping(7787,7786)
        self._addCaseMapping(7789,7788)
        self._addCaseMapping(7791,7790)
        self._addCaseMapping(7793,7792)
        self._addCaseMapping(7795,7794)
        self._addCaseMapping(7797,7796)
        self._addCaseMapping(7799,7798)
        self._addCaseMapping(7801,7800)
        self._addCaseMapping(7803,7802)
        self._addCaseMapping(7805,7804)
        self._addCaseMapping(7807,7806)
        self._addCaseMapping(7809,7808)
        self._addCaseMapping(7811,7810)
        self._addCaseMapping(7813,7812)
        self._addCaseMapping(7815,7814)
        self._addCaseMapping(7817,7816)
        self._addCaseMapping(7819,7818)
        self._addCaseMapping(7821,7820)
        self._addCaseMapping(7823,7822)
        self._addCaseMapping(7825,7824)
        self._addCaseMapping(7827,7826)
        self._addCaseMapping(7829,7828)
        self._addCaseMapping(7841,7840)
        self._addCaseMapping(7843,7842)
        self._addCaseMapping(7845,7844)
        self._addCaseMapping(7847,7846)
        self._addCaseMapping(7849,7848)
        self._addCaseMapping(7851,7850)
        self._addCaseMapping(7853,7852)
        self._addCaseMapping(7855,7854)
        self._addCaseMapping(7857,7856)
        self._addCaseMapping(7859,7858)
        self._addCaseMapping(7861,7860)
        self._addCaseMapping(7863,7862)
        self._addCaseMapping(7865,7864)
        self._addCaseMapping(7867,7866)
        self._addCaseMapping(7869,7868)
        self._addCaseMapping(7871,7870)
        self._addCaseMapping(7873,7872)
        self._addCaseMapping(7875,7874)
        self._addCaseMapping(7877,7876)
        self._addCaseMapping(7879,7878)
        self._addCaseMapping(7881,7880)
        self._addCaseMapping(7883,7882)
        self._addCaseMapping(7885,7884)
        self._addCaseMapping(7887,7886)
        self._addCaseMapping(7889,7888)
        self._addCaseMapping(7891,7890)
        self._addCaseMapping(7893,7892)
        self._addCaseMapping(7895,7894)
        self._addCaseMapping(7897,7896)
        self._addCaseMapping(7899,7898)
        self._addCaseMapping(7901,7900)
        self._addCaseMapping(7903,7902)
        self._addCaseMapping(7905,7904)
        self._addCaseMapping(7907,7906)
        self._addCaseMapping(7909,7908)
        self._addCaseMapping(7911,7910)
        self._addCaseMapping(7913,7912)
        self._addCaseMapping(7915,7914)
        self._addCaseMapping(7917,7916)
        self._addCaseMapping(7919,7918)
        self._addCaseMapping(7921,7920)
        self._addCaseMapping(7923,7922)
        self._addCaseMapping(7925,7924)
        self._addCaseMapping(7927,7926)
        self._addCaseMapping(7929,7928)
        self._addCaseMapping(7936,7944)
        self._addCaseMapping(7937,7945)
        self._addCaseMapping(7938,7946)
        self._addCaseMapping(7939,7947)
        self._addCaseMapping(7940,7948)
        self._addCaseMapping(7941,7949)
        self._addCaseMapping(7942,7950)
        self._addCaseMapping(7943,7951)
        self._addCaseMapping(7952,7960)
        self._addCaseMapping(7953,7961)
        self._addCaseMapping(7954,7962)
        self._addCaseMapping(7955,7963)
        self._addCaseMapping(7956,7964)
        self._addCaseMapping(7957,7965)
        self._addCaseMapping(7968,7976)
        self._addCaseMapping(7969,7977)
        self._addCaseMapping(7970,7978)
        self._addCaseMapping(7971,7979)
        self._addCaseMapping(7972,7980)
        self._addCaseMapping(7973,7981)
        self._addCaseMapping(7974,7982)
        self._addCaseMapping(7975,7983)
        self._addCaseMapping(7984,7992)
        self._addCaseMapping(7985,7993)
        self._addCaseMapping(7986,7994)
        self._addCaseMapping(7987,7995)
        self._addCaseMapping(7988,7996)
        self._addCaseMapping(7989,7997)
        self._addCaseMapping(7990,7998)
        self._addCaseMapping(7991,7999)
        self._addCaseMapping(8000,8008)
        self._addCaseMapping(8001,8009)
        self._addCaseMapping(8002,8010)
        self._addCaseMapping(8003,8011)
        self._addCaseMapping(8004,8012)
        self._addCaseMapping(8005,8013)
        self._addCaseMapping(8017,8025)
        self._addCaseMapping(8019,8027)
        self._addCaseMapping(8021,8029)
        self._addCaseMapping(8023,8031)
        self._addCaseMapping(8032,8040)
        self._addCaseMapping(8033,8041)
        self._addCaseMapping(8034,8042)
        self._addCaseMapping(8035,8043)
        self._addCaseMapping(8036,8044)
        self._addCaseMapping(8037,8045)
        self._addCaseMapping(8038,8046)
        self._addCaseMapping(8039,8047)
        self._addCaseMapping(8064,8072)
        self._addCaseMapping(8065,8073)
        self._addCaseMapping(8066,8074)
        self._addCaseMapping(8067,8075)
        self._addCaseMapping(8068,8076)
        self._addCaseMapping(8069,8077)
        self._addCaseMapping(8070,8078)
        self._addCaseMapping(8071,8079)
        self._addCaseMapping(8080,8088)
        self._addCaseMapping(8081,8089)
        self._addCaseMapping(8082,8090)
        self._addCaseMapping(8083,8091)
        self._addCaseMapping(8084,8092)
        self._addCaseMapping(8085,8093)
        self._addCaseMapping(8086,8094)
        self._addCaseMapping(8087,8095)
        self._addCaseMapping(8096,8104)
        self._addCaseMapping(8097,8105)
        self._addCaseMapping(8098,8106)
        self._addCaseMapping(8099,8107)
        self._addCaseMapping(8100,8108)
        self._addCaseMapping(8101,8109)
        self._addCaseMapping(8102,8110)
        self._addCaseMapping(8103,8111)
        self._addCaseMapping(8112,8120)
        self._addCaseMapping(8113,8121)
        self._addCaseMapping(8144,8152)
        self._addCaseMapping(8145,8153)
        self._addCaseMapping(8160,8168)
        self._addCaseMapping(8161,8169)
        self._addCaseMapping(9424,9398)
        self._addCaseMapping(9425,9399)
        self._addCaseMapping(9426,9400)
        self._addCaseMapping(9427,9401)
        self._addCaseMapping(9428,9402)
        self._addCaseMapping(9429,9403)
        self._addCaseMapping(9430,9404)
        self._addCaseMapping(9431,9405)
        self._addCaseMapping(9432,9406)
        self._addCaseMapping(9433,9407)
        self._addCaseMapping(9434,9408)
        self._addCaseMapping(9435,9409)
        self._addCaseMapping(9436,9410)
        self._addCaseMapping(9437,9411)
        self._addCaseMapping(9438,9412)
        self._addCaseMapping(9439,9413)
        self._addCaseMapping(9440,9414)
        self._addCaseMapping(9441,9415)
        self._addCaseMapping(9442,9416)
        self._addCaseMapping(9443,9417)
        self._addCaseMapping(9444,9418)
        self._addCaseMapping(9445,9419)
        self._addCaseMapping(9446,9420)
        self._addCaseMapping(9447,9421)
        self._addCaseMapping(9448,9422)
        self._addCaseMapping(9449,9423)
        self._addCaseMapping(65345,65313)
        self._addCaseMapping(65346,65314)
        self._addCaseMapping(65347,65315)
        self._addCaseMapping(65348,65316)
        self._addCaseMapping(65349,65317)
        self._addCaseMapping(65350,65318)
        self._addCaseMapping(65351,65319)
        self._addCaseMapping(65352,65320)
        self._addCaseMapping(65353,65321)
        self._addCaseMapping(65354,65322)
        self._addCaseMapping(65355,65323)
        self._addCaseMapping(65356,65324)
        self._addCaseMapping(65357,65325)
        self._addCaseMapping(65358,65326)
        self._addCaseMapping(65359,65327)
        self._addCaseMapping(65360,65328)
        self._addCaseMapping(65361,65329)
        self._addCaseMapping(65362,65330)
        self._addCaseMapping(65363,65331)
        self._addCaseMapping(65364,65332)
        self._addCaseMapping(65365,65333)
        self._addCaseMapping(65366,65334)
        self._addCaseMapping(65367,65335)
        self._addCaseMapping(65368,65336)
        self._addCaseMapping(65369,65337)
        self._addCaseMapping(65370,65338)

    def _addCaseMapping(self,lowerChar,upperChar):
        if (not (upperChar in self.mapU2L.h)):
            self.mapU2L.set(upperChar,lowerChar)
        if (not (lowerChar in self.mapL2U.h)):
            self.mapL2U.set(lowerChar,upperChar)

    def isLowerCase(self,ch):
        return (ch in self.mapL2U.h)

    def isUpperCase(self,ch):
        return (ch in self.mapU2L.h)

    def toLowerCase(self,ch):
        lowerChar = self.mapU2L.h.get(ch,None)
        if (lowerChar is None):
            return ch
        else:
            return lowerChar

    def toUpperCase(self,ch):
        upperChar = self.mapL2U.h.get(ch,None)
        if (upperChar is None):
            return ch
        else:
            return upperChar

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mapU2L = None
        _hx_o.mapL2U = None


class hx_strings__Char_Char_Impl_:
    _hx_class_name = "hx.strings._Char.Char_Impl_"
    __slots__ = ()
    _hx_statics = ["CHAR_CASE_MAPPER", "BACKSPACE", "TAB", "LF", "CR", "ESC", "SPACE", "EXCLAMATION_MARK", "DOUBLE_QUOTE", "HASH", "DOLLAR", "AMPERSAND", "SINGLE_QUOTE", "BRACKET_ROUND_LEFT", "BRACKET_ROUND_RIGHT", "ASTERISK", "PLUS", "COMMA", "MINUS", "DOT", "SLASH", "ZERO", "ONE", "TWO", "TRHEE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON", "LOWER_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "BRACKET_SQUARE_LEFT", "BACKSLASH", "BRACKET_SQUARE_RIGHT", "CARET", "UNDERSCORE", "BRACKET_CURLY_LEFT", "PIPE", "BRACKET_CURLY_RIGHT", "fromString", "of", "op_plus_string", "op_plus_string2", "op_plus", "isAscii", "isAsciiAlpha", "isAsciiAlphanumeric", "isAsciiControl", "isAsciiPrintable", "isDigit", "isEOF", "isSpace", "isUTF8", "isWhitespace", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase", "toInt", "toString"]

    @staticmethod
    def fromString(_hx_str):
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((strLen == 0) or ((0 >= strLen))):
            return -1
        else:
            return HxString.charCodeAt(_hx_str,0)

    @staticmethod
    def of(ch):
        return ch

    @staticmethod
    def op_plus_string(ch,other):
        return (HxOverrides.stringOrNull("".join(map(chr,[ch]))) + ("null" if other is None else other))

    @staticmethod
    def op_plus_string2(_hx_str,ch):
        return (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull("".join(map(chr,[ch]))))

    @staticmethod
    def op_plus(ch,other):
        return (ch + other)

    @staticmethod
    def isAscii(this1):
        if (this1 > -1):
            return (this1 < 128)
        else:
            return False

    @staticmethod
    def isAsciiAlpha(this1):
        if (not (((this1 > 64) and ((this1 < 91))))):
            if (this1 > 96):
                return (this1 < 123)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiAlphanumeric(this1):
        if (not ((((this1 > 64) and ((this1 < 91))) or (((this1 > 96) and ((this1 < 123))))))):
            if (this1 > 47):
                return (this1 < 58)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiControl(this1):
        if (not (((this1 > -1) and ((this1 < 32))))):
            return (this1 == 127)
        else:
            return True

    @staticmethod
    def isAsciiPrintable(this1):
        if (this1 > 31):
            return (this1 < 127)
        else:
            return False

    @staticmethod
    def isDigit(this1):
        if (this1 > 47):
            return (this1 < 58)
        else:
            return False

    @staticmethod
    def isEOF(this1):
        return (this1 == -1)

    @staticmethod
    def isSpace(this1):
        return (this1 == 32)

    @staticmethod
    def isUTF8(this1):
        if (this1 > -1):
            return (this1 < 1114112)
        else:
            return False

    @staticmethod
    def isWhitespace(this1):
        if (not (((this1 > 8) and ((this1 < 14))))):
            return (this1 == 32)
        else:
            return True

    @staticmethod
    def isLowerCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h)

    @staticmethod
    def isUpperCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)

    @staticmethod
    def toLowerCase(this1):
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        if (lowerChar is None):
            return this1
        else:
            return lowerChar

    @staticmethod
    def toUpperCase(this1):
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        if (upperChar is None):
            return this1
        else:
            return upperChar

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        return "".join(map(chr,[this1]))


class hx_strings_CharIterator:
    _hx_class_name = "hx.strings.CharIterator"
    __slots__ = ("index", "line", "col", "currChar", "usePrevBuffer", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx")
    _hx_fields = ["index", "line", "col", "currChar", "usePrevBuffer", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx"]
    _hx_methods = ["get_pos", "hasPrev", "prev", "hasNext", "next", "getChar", "isEOF"]
    _hx_statics = ["fromString", "fromArray", "fromInput", "fromIterator"]

    def __init__(self,prevBufferSize):
        self.prevBuffer = None
        self.usePrevBuffer = None
        self.prevBufferNextIdx = -1
        self.prevBufferPrevIdx = -1
        self.currChar = -1
        self.col = 0
        self.line = 0
        self.index = -1
        if (prevBufferSize > 0):
            self.usePrevBuffer = True
            this1 = hx_strings_internal__RingBuffer_RingBufferImpl((prevBufferSize + 1))
            self.prevBuffer = this1
        else:
            self.usePrevBuffer = False

    def get_pos(self):
        return hx_strings_CharPos(self.index,self.line,self.col)

    def hasPrev(self):
        return (self.prevBufferPrevIdx > -1)

    def prev(self):
        if self.isEOF():
            raise _HxException(haxe_io_Eof())
        prevChar = self.prevBuffer.get(self.prevBufferPrevIdx)
        self.currChar = prevChar.char
        self.index = prevChar.index
        self.line = prevChar.line
        self.col = prevChar.col
        self.prevBufferNextIdx = ((self.prevBufferPrevIdx + 1) if (((self.prevBufferPrevIdx + 1) < self.prevBuffer.length)) else -1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.prevBufferPrevIdx
        _hx_local_0.prevBufferPrevIdx = (_hx_local_1 - 1)
        _hx_local_1
        return self.currChar

    def hasNext(self):
        if (self.prevBufferNextIdx > -1):
            return True
        return (not self.isEOF())

    def next(self):
        if (self.prevBufferNextIdx > -1):
            prevChar = self.prevBuffer.get(self.prevBufferNextIdx)
            self.currChar = prevChar.char
            self.index = prevChar.index
            self.line = prevChar.line
            self.col = prevChar.col
            self.prevBufferPrevIdx = (self.prevBufferNextIdx - 1)
            self.prevBufferNextIdx = ((self.prevBufferNextIdx + 1) if (((self.prevBufferNextIdx + 1) < self.prevBuffer.length)) else -1)
            return self.currChar
        if self.isEOF():
            raise _HxException(haxe_io_Eof())
        if ((self.currChar == 10) or ((self.currChar < 0))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.line
            _hx_local_0.line = (_hx_local_1 + 1)
            _hx_local_1
            self.col = 0
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.index
        _hx_local_2.index = (_hx_local_3 + 1)
        _hx_local_3
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.col
        _hx_local_4.col = (_hx_local_5 + 1)
        _hx_local_5
        self.currChar = self.getChar()
        if self.usePrevBuffer:
            self.prevBuffer.add(hx_strings__CharIterator_CharWithPos(self.currChar,self.index,self.col,self.line))
            self.prevBufferPrevIdx = (self.prevBuffer.length - 2)
            self.prevBufferNextIdx = -1
        return self.currChar

    def getChar(self):
        raise _HxException("Not implemented")

    def isEOF(self):
        raise _HxException("Not implemented")

    @staticmethod
    def fromString(chars,prevBufferSize = 0):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_StringCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromArray(chars,prevBufferSize = 0):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_ArrayCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromInput(chars,prevBufferSize = 0):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_InputCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromIterator(chars,prevBufferSize = 0):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_IteratorCharIterator(chars,prevBufferSize)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None
        _hx_o.currChar = None
        _hx_o.usePrevBuffer = None
        _hx_o.prevBuffer = None
        _hx_o.prevBufferPrevIdx = None
        _hx_o.prevBufferNextIdx = None


class hx_strings_CharPos:
    _hx_class_name = "hx.strings.CharPos"
    __slots__ = ("index", "line", "col")
    _hx_fields = ["index", "line", "col"]

    def __init__(self,index,line,col):
        self.index = index
        self.line = line
        self.col = col

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None


class hx_strings__CharIterator_CharWithPos(hx_strings_CharPos):
    _hx_class_name = "hx.strings._CharIterator.CharWithPos"
    __slots__ = ("char",)
    _hx_fields = ["char"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharPos


    def __init__(self,char,index,line,col):
        self.char = None
        super().__init__(index,line,col)
        self.char = char

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.char = None


class hx_strings_internal__RingBuffer_RingBufferImpl:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferImpl"
    __slots__ = ("buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size")
    _hx_fields = ["buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size"]
    _hx_methods = ["add", "get", "iterator", "toArray"]

    def __init__(self,size):
        self.length = 0
        self.bufferEndIdx = -1
        self.bufferStartIdx = 0
        if (size < 1):
            raise _HxException("[size] must be > 0")
        this1 = [None]*size
        self.buffer = this1
        self.size = size
        self.bufferMaxIdx = (size - 1)

    def add(self,item):
        if (self.length == self.size):
            self.bufferEndIdx = self.bufferStartIdx
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bufferStartIdx
            _hx_local_0.bufferStartIdx = (_hx_local_1 + 1)
            _hx_local_1
            if (self.bufferStartIdx > self.bufferMaxIdx):
                self.bufferStartIdx = 0
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufferEndIdx
            _hx_local_2.bufferEndIdx = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.length
            _hx_local_4.length = (_hx_local_5 + 1)
            _hx_local_5
        self.buffer[self.bufferEndIdx] = item

    def get(self,index):
        if ((index < 0) or ((index > self.bufferMaxIdx))):
            raise _HxException((("[index] " + Std.string(index)) + " is out of bound"))
        realIdx = (self.bufferStartIdx + index)
        if (realIdx > self.bufferMaxIdx):
            realIdx = (realIdx - self.length)
        return self.buffer[realIdx]

    def iterator(self):
        return hx_strings_internal__RingBuffer_RingBufferIterator(self)

    def toArray(self):
        arr = list()
        i = self.iterator()
        while i.hasNext():
            i1 = i.next()
            arr.append(i1)
        return arr

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.bufferStartIdx = None
        _hx_o.bufferEndIdx = None
        _hx_o.bufferMaxIdx = None
        _hx_o.length = None
        _hx_o.size = None


class hx_strings__CharIterator_NullCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.NullCharIterator"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["isEOF"]
    _hx_statics = ["INSTANCE"]
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self):
        super().__init__(0)

    def isEOF(self):
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class hx_strings__CharIterator_ArrayCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.ArrayCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (len(chars) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return python_internal_ArrayImpl._get(self.chars, self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None


class hx_strings__CharIterator_IteratorCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.IteratorCharIterator"
    __slots__ = ("chars",)
    _hx_fields = ["chars"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars

    def isEOF(self):
        return (not self.chars.hasNext())

    def getChar(self):
        return self.chars.next()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None


class hx_strings__CharIterator_InputCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.InputCharIterator"
    __slots__ = ("byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable")
    _hx_fields = ["byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable"]
    _hx_methods = ["isEOF", "getChar", "readUtf8Char", "readUtf8MultiSequenceByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.nextChar = None
        self.input = None
        self.nextCharAvailable = None
        self.currCharIndex = -1
        self.byteIndex = 0
        super().__init__(prevBufferSize)
        self.input = chars

    def isEOF(self):
        if (self.nextCharAvailable == None):
            try:
                byte1 = self.input.readByte()
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.byteIndex
                _hx_local_0.byteIndex = (_hx_local_1 + 1)
                _hx_local_1
                tmp = None
                if (byte1 <= 127):
                    tmp = byte1
                else:
                    byte1 = (byte1 & -129)
                    byte1 = (byte1 & -65)
                    totalBytes = 2
                    isBit6Set = (1 == (((byte1 >> 5) & 1)))
                    isBit5Set = False
                    if isBit6Set:
                        byte1 = (byte1 & -33)
                        totalBytes = (totalBytes + 1)
                        isBit5Set = (1 == (((byte1 >> 4) & 1)))
                        if isBit5Set:
                            byte1 = (byte1 & -17)
                            totalBytes = (totalBytes + 1)
                            if (1 == (((byte1 >> 3) & 1))):
                                raise _HxException((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
                    result = (byte1 << ((6 * ((totalBytes - 1)))))
                    byte = self.input.readByte()
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.byteIndex
                    _hx_local_8.byteIndex = (_hx_local_9 + 1)
                    _hx_local_9
                    if (1 != (((byte >> 7) & 1))):
                        raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    if (1 == (((byte >> 6) & 1))):
                        raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    byte2 = (byte & -129)
                    result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
                    if isBit6Set:
                        byte3 = self.input.readByte()
                        _hx_local_11 = self
                        _hx_local_12 = _hx_local_11.byteIndex
                        _hx_local_11.byteIndex = (_hx_local_12 + 1)
                        _hx_local_12
                        if (1 != (((byte3 >> 7) & 1))):
                            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte3)) + "]!"))
                        if (1 == (((byte3 >> 6) & 1))):
                            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte3)) + "]!"))
                        byte31 = (byte3 & -129)
                        result = (result + ((byte31 << ((6 * ((totalBytes - 3)))))))
                        if isBit5Set:
                            byte4 = self.input.readByte()
                            _hx_local_14 = self
                            _hx_local_15 = _hx_local_14.byteIndex
                            _hx_local_14.byteIndex = (_hx_local_15 + 1)
                            _hx_local_15
                            if (1 != (((byte4 >> 7) & 1))):
                                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte4)) + "]!"))
                            if (1 == (((byte4 >> 6) & 1))):
                                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte4)) + "]!"))
                            byte41 = (byte4 & -129)
                            result = (result + ((byte41 << ((6 * ((totalBytes - 4)))))))
                    if ((self.index == 0) and ((result == 65279))):
                        byte11 = self.input.readByte()
                        _hx_local_17 = self
                        _hx_local_18 = _hx_local_17.byteIndex
                        _hx_local_17.byteIndex = (_hx_local_18 + 1)
                        _hx_local_18
                        if (byte11 <= 127):
                            tmp = byte11
                        else:
                            byte11 = (byte11 & -129)
                            byte11 = (byte11 & -65)
                            totalBytes1 = 2
                            isBit6Set1 = (1 == (((byte11 >> 5) & 1)))
                            isBit5Set1 = False
                            if isBit6Set1:
                                byte11 = (byte11 & -33)
                                totalBytes1 = (totalBytes1 + 1)
                                isBit5Set1 = (1 == (((byte11 >> 4) & 1)))
                                if isBit5Set1:
                                    byte11 = (byte11 & -17)
                                    totalBytes1 = (totalBytes1 + 1)
                                    if (1 == (((byte11 >> 3) & 1))):
                                        raise _HxException((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte11)) + "]!"))
                            result1 = (byte11 << ((6 * ((totalBytes1 - 1)))))
                            byte5 = self.input.readByte()
                            _hx_local_25 = self
                            _hx_local_26 = _hx_local_25.byteIndex
                            _hx_local_25.byteIndex = (_hx_local_26 + 1)
                            _hx_local_26
                            if (1 != (((byte5 >> 7) & 1))):
                                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte5)) + "]!"))
                            if (1 == (((byte5 >> 6) & 1))):
                                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte5)) + "]!"))
                            byte21 = (byte5 & -129)
                            result1 = (result1 + ((byte21 << ((6 * ((totalBytes1 - 2)))))))
                            if isBit6Set1:
                                byte6 = self.input.readByte()
                                _hx_local_28 = self
                                _hx_local_29 = _hx_local_28.byteIndex
                                _hx_local_28.byteIndex = (_hx_local_29 + 1)
                                _hx_local_29
                                if (1 != (((byte6 >> 7) & 1))):
                                    raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte6)) + "]!"))
                                if (1 == (((byte6 >> 6) & 1))):
                                    raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte6)) + "]!"))
                                byte32 = (byte6 & -129)
                                result1 = (result1 + ((byte32 << ((6 * ((totalBytes1 - 3)))))))
                                if isBit5Set1:
                                    byte7 = self.input.readByte()
                                    _hx_local_31 = self
                                    _hx_local_32 = _hx_local_31.byteIndex
                                    _hx_local_31.byteIndex = (_hx_local_32 + 1)
                                    _hx_local_32
                                    if (1 != (((byte7 >> 7) & 1))):
                                        raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte7)) + "]!"))
                                    if (1 == (((byte7 >> 6) & 1))):
                                        raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte7)) + "]!"))
                                    byte42 = (byte7 & -129)
                                    result1 = (result1 + ((byte42 << ((6 * ((totalBytes1 - 4)))))))
                            tmp = (self.readUtf8Char() if (((self.index == 0) and ((result1 == 65279)))) else result1)
                    else:
                        tmp = result
                self.nextChar = tmp
                self.nextCharAvailable = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                    ex = _hx_e1
                    self.nextCharAvailable = False
                else:
                    raise _hx_e
        return (self.nextCharAvailable != True)

    def getChar(self):
        if (self.index != self.currCharIndex):
            self.currCharIndex = self.index
            self.nextCharAvailable = None
            return self.nextChar
        return self.currChar

    def readUtf8Char(self):
        byte1 = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (byte1 <= 127):
            return byte1
        byte1 = (byte1 & -129)
        byte1 = (byte1 & -65)
        totalBytes = 2
        isBit6Set = (1 == (((byte1 >> 5) & 1)))
        isBit5Set = False
        if isBit6Set:
            byte1 = (byte1 & -33)
            totalBytes = (totalBytes + 1)
            isBit5Set = (1 == (((byte1 >> 4) & 1)))
            if isBit5Set:
                byte1 = (byte1 & -17)
                totalBytes = (totalBytes + 1)
                if (1 == (((byte1 >> 3) & 1))):
                    raise _HxException((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
        result = (byte1 << ((6 * ((totalBytes - 1)))))
        byte = self.input.readByte()
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.byteIndex
        _hx_local_8.byteIndex = (_hx_local_9 + 1)
        _hx_local_9
        if (1 != (((byte >> 7) & 1))):
            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        byte2 = (byte & -129)
        result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
        if isBit6Set:
            byte3 = self.input.readByte()
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.byteIndex
            _hx_local_11.byteIndex = (_hx_local_12 + 1)
            _hx_local_12
            if (1 != (((byte3 >> 7) & 1))):
                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte3)) + "]!"))
            if (1 == (((byte3 >> 6) & 1))):
                raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte3)) + "]!"))
            byte31 = (byte3 & -129)
            result = (result + ((byte31 << ((6 * ((totalBytes - 3)))))))
            if isBit5Set:
                byte4 = self.input.readByte()
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.byteIndex
                _hx_local_14.byteIndex = (_hx_local_15 + 1)
                _hx_local_15
                if (1 != (((byte4 >> 7) & 1))):
                    raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte4)) + "]!"))
                if (1 == (((byte4 >> 6) & 1))):
                    raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte4)) + "]!"))
                byte41 = (byte4 & -129)
                result = (result + ((byte41 << ((6 * ((totalBytes - 4)))))))
        if ((self.index == 0) and ((result == 65279))):
            return self.readUtf8Char()
        return result

    def readUtf8MultiSequenceByte(self):
        byte = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (1 != (((byte >> 7) & 1))):
            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise _HxException((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        return (byte & -129)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.byteIndex = None
        _hx_o.input = None
        _hx_o.currCharIndex = None
        _hx_o.nextChar = None
        _hx_o.nextCharAvailable = None


class hx_strings__CharIterator_StringCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.StringCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (((0 if ((chars is None)) else len(chars))) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return HxString.charCodeAt(self.chars,self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None


class hx_strings_Pattern:
    _hx_class_name = "hx.strings.Pattern"
    __slots__ = ("pattern", "options", "ereg")
    _hx_fields = ["pattern", "options", "ereg"]
    _hx_methods = ["matcher", "replace", "remove", "split"]
    _hx_statics = ["__meta__", "compile"]

    def __init__(self,pattern,options):
        self.pattern = pattern
        self.options = options
        self.ereg = EReg(pattern,options)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.options
        _hx_local_0.options = (("null" if _hx_local_1 is None else _hx_local_1) + "u")
        _hx_local_0.options

    def matcher(self,_hx_str):
        return hx_strings__Pattern_MatcherImpl(self.ereg,self.pattern,self.options,_hx_str)

    def replace(self,_hx_str,replaceWith):
        return self.ereg.replace(_hx_str,replaceWith)

    def remove(self,_hx_str):
        return self.ereg.replace(_hx_str,"")

    def split(self,_hx_str):
        return self.ereg.split(_hx_str)

    @staticmethod
    def compile(pattern,options = None):
        if (options is None):
            return hx_strings_Pattern(pattern,"")
        _g = options
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 0):
            _hx_str = _g.params[0]
            str1 = hx_strings_Strings.toLowerCase8(_hx_str)
            if ((str1 is None) or ((len(str1) == 0))):
                tmp = str1
            else:
                def _hx_local_0(ch):
                    return "".join(map(chr,[ch]))
                def _hx_local_1(ch1):
                    _this1 = None
                    strLen = len("i")
                    if (not ((ch1 == ((-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt("i",0)))))):
                        strLen1 = len("m")
                        _this1 = (ch1 == ((-1 if (((strLen1 == 0) or ((0 >= strLen1)))) else HxString.charCodeAt("m",0))))
                    else:
                        _this1 = True
                    if (not _this1):
                        strLen2 = len("g")
                        return (ch1 == ((-1 if (((strLen2 == 0) or ((0 >= strLen2)))) else HxString.charCodeAt("g",0))))
                    else:
                        return True
                _this = list(map(_hx_local_0,list(filter(_hx_local_1,hx_strings_Strings.toChars(str1)))))
                tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this])
        elif (tmp1 == 1):
            opt = _g.params[0]
            tmp = Std.string(opt)
        elif (tmp1 == 2):
            arr = _g.params[0]
            def _hx_local_2(m):
                return (m is not None)
            _this2 = list(filter(_hx_local_2,arr))
            tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this2])
        else:
            pass
        return hx_strings_Pattern(pattern,tmp)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.options = None
        _hx_o.ereg = None


class hx_strings_Matcher:
    _hx_class_name = "hx.strings.Matcher"
    __slots__ = ()
    _hx_methods = ["iterate", "map", "matched", "matchedPos", "matches", "matchesInRegion", "reset", "substringAfterMatch", "substringBeforeMatch"]
    _hx_statics = ["__meta__"]


class hx_strings__Pattern_MatcherImpl:
    _hx_class_name = "hx.strings._Pattern.MatcherImpl"
    __slots__ = ("isMatch", "ereg", "str")
    _hx_fields = ["isMatch", "ereg", "str"]
    _hx_methods = ["reset", "iterate", "map", "matched", "matches", "matchesInRegion", "matchedPos", "substringAfterMatch", "substringBeforeMatch", "_cloneEReg"]
    _hx_interfaces = [hx_strings_Matcher]

    def __init__(self,ereg,pattern,options,_hx_str):
        self.str = None
        self.ereg = None
        self.isMatch = None
        self.ereg = self._cloneEReg(ereg,pattern,options)
        self.str = _hx_str
        self.isMatch = None

    def reset(self,_hx_str):
        self.str = _hx_str
        self.isMatch = None
        return self

    def iterate(self,onMatch):
        startAt = 0
        while self.ereg.matchSub(self.str,startAt):
            self.isMatch = True
            _this = self.ereg
            matchedPos_pos = _this.matchObj.start()
            matchedPos_len = (_this.matchObj.end() - _this.matchObj.start())
            onMatch(self)
            startAt = (matchedPos_pos + matchedPos_len)
        self.isMatch = False

    def map(self,mapper):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(ereg):
                _gthis.isMatch = True
                return mapper(_gthis)
            return self.ereg.map(self.str,_hx_local_0)
        return _hx_local_1()

    def matched(self,n = 0):
        if (n is None):
            n = 0
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            raise _HxException("No string matched")
        result = self.ereg.matchObj.group(n)
        return result

    def matches(self):
        _this = self.ereg
        _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
        def _hx_local_1():
            def _hx_local_0():
                self.isMatch = (_this.matchObj is not None)
                return self.isMatch
            return _hx_local_0()
        return _hx_local_1()

    def matchesInRegion(self,pos,_hx_len = -1):
        if (_hx_len is None):
            _hx_len = -1
        def _hx_local_1():
            def _hx_local_0():
                self.isMatch = self.ereg.matchSub(self.str,pos,_hx_len)
                return self.isMatch
            return _hx_local_0()
        return _hx_local_1()

    def matchedPos(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            raise _HxException("No string matched")
        _this1 = self.ereg
        return _hx_AnonObject({'pos': _this1.matchObj.start(), 'len': (_this1.matchObj.end() - _this1.matchObj.start())})

    def substringAfterMatch(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            return ""
        _this1 = self.ereg
        return HxString.substr(_this1.matchObj.string,_this1.matchObj.end(),None)

    def substringBeforeMatch(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        if (not self.isMatch):
            return ""
        _this1 = self.ereg
        return HxString.substr(_this1.matchObj.string,0,_this1.matchObj.start())

    def _cloneEReg(self,_hx_from,pattern,options):
        clone = Type.createEmptyInstance(EReg)
        value = Reflect.field(_hx_from,"pattern")
        setattr(clone,(("_hx_" + "pattern") if (("pattern" in python_Boot.keywords)) else (("_hx_" + "pattern") if (((((len("pattern") > 2) and ((ord("pattern"[0]) == 95))) and ((ord("pattern"[1]) == 95))) and ((ord("pattern"[(len("pattern") - 1)]) != 95)))) else "pattern")),value)
        value1 = Reflect.field(_hx_from,"global")
        setattr(clone,(("_hx_" + "global") if (("global" in python_Boot.keywords)) else (("_hx_" + "global") if (((((len("global") > 2) and ((ord("global"[0]) == 95))) and ((ord("global"[1]) == 95))) and ((ord("global"[(len("global") - 1)]) != 95)))) else "global")),value1)
        return clone

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.isMatch = None
        _hx_o.ereg = None
        _hx_o.str = None


class hx_strings__String8_String8_Impl_:
    _hx_class_name = "hx.strings._String8.String8_Impl_"
    __slots__ = ()
    _hx_statics = ["get_length"]
    length = None

    @staticmethod
    def get_length(this1):
        if (this1 is None):
            return 0
        else:
            return len(this1)


class hx_strings_StringBuilder:
    _hx_class_name = "hx.strings.StringBuilder"
    __slots__ = ("sb", "pre", "len", "length")
    _hx_fields = ["sb", "pre", "len"]
    _hx_methods = ["get_length", "add", "addChar", "addAll", "clear", "isEmpty", "newLine", "insert", "insertChar", "insertAll", "asOutput", "toString"]

    def __init__(self,initialContent = None):
        self.length = None
        self.len = 0
        self.pre = None
        self.sb = StringBuf()
        if (initialContent is not None):
            _this = self.sb
            s = Std.string(initialContent)
            _this.b.write(s)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + (0 if ((initialContent is None)) else len(initialContent)))
            _hx_local_0.len

    def get_length(self):
        return self.len

    def add(self,item):
        _this = self.sb
        s = Std.string(item)
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
        _hx_local_0.len
        return self

    def addChar(self,ch):
        _this = self.sb
        s = "".join(map(chr,[ch]))
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def addAll(self,items):
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 + (0 if ((item is None)) else len(item)))
            _hx_local_1.len
        return self

    def clear(self):
        self.pre = None
        self.sb = StringBuf()
        self.len = 0
        return self

    def isEmpty(self):
        return (self.len == 0)

    def newLine(self):
        self.sb.b.write("\n")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def insert(self,pos,item):
        if (pos < 0):
            raise _HxException("[pos] must not be negative")
        if (pos > self.len):
            raise _HxException("[pos] must not be greater than this.length")
        if (pos == self.len):
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
            _hx_local_0.len
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            self.pre.insert(0, item)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.len
            _hx_local_2.len = (_hx_local_3 + (0 if ((item is None)) else len(item)))
            _hx_local_2.len
            return self
        pre_len = 0
        if (self.pre is not None):
            i = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i1] if i1 >= 0 and i1 < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    self.pre.insert((i1 + 1), item)
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + (0 if ((item is None)) else len(item)))
                    _hx_local_4.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i1] if i1 >= 0 and i1 < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i1, (preSplitted[0] if 0 < len(preSplitted) else None))
                    self.pre.insert((i1 + 1), item)
                    self.pre.insert((i1 + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_6 = self
                    _hx_local_7 = _hx_local_6.len
                    _hx_local_6.len = (_hx_local_7 + (0 if ((item is None)) else len(item)))
                    _hx_local_6.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            _this1 = self.sb
            s1 = Std.string(item)
            _this1.b.write(s1)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.len
            _hx_local_8.len = (_hx_local_9 + (0 if ((item is None)) else len(item)))
            _hx_local_8.len
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this2 = self.sb
        s2 = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this2.b.write(s2)
        _this3 = self.sb
        s3 = Std.string(item)
        _this3.b.write(s3)
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.len
        _hx_local_10.len = (_hx_local_11 + (0 if ((item is None)) else len(item)))
        _hx_local_10.len
        _this4 = self.sb
        s4 = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this4.b.write(s4)
        return self

    def insertChar(self,pos,ch):
        if (pos < 0):
            raise _HxException("[pos] must not be negative")
        if (pos > self.len):
            raise _HxException("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addChar(ch)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            _this = self.pre
            x = "".join(map(chr,[ch]))
            _this.insert(0, x)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + 1)
            _hx_local_1
            return self
        pre_len = 0
        if (self.pre is not None):
            i = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i1] if i1 >= 0 and i1 < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    _this1 = self.pre
                    x1 = "".join(map(chr,[ch]))
                    _this1.insert((i1 + 1), x1)
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.len
                    _hx_local_2.len = (_hx_local_3 + 1)
                    _hx_local_3
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i1] if i1 >= 0 and i1 < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i1, (preSplitted[0] if 0 < len(preSplitted) else None))
                    _this2 = self.pre
                    x2 = "".join(map(chr,[ch]))
                    _this2.insert((i1 + 1), x2)
                    self.pre.insert((i1 + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + 1)
                    _hx_local_5
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            self.addChar(ch)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this3 = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this3.b.write(s)
        self.addChar(ch)
        _this4 = self.sb
        s1 = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this4.b.write(s1)
        return self

    def insertAll(self,pos,items):
        if (pos < 0):
            raise _HxException("[pos] must not be negative")
        if (pos > self.len):
            raise _HxException("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addAll(items)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            i = len(items)
            while True:
                tmp = i
                i = (i - 1)
                if (not ((tmp > 0))):
                    break
                item = (items[i] if i >= 0 and i < len(items) else None)
                self.pre.insert(0, item)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.len
                _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
                _hx_local_0.len
            return self
        pre_len = 0
        if (self.pre is not None):
            i1 = len(self.pre)
            _g = 0
            _g1 = len(self.pre)
            while (_g < _g1):
                i2 = _g
                _g = (_g + 1)
                _hx_str = (self.pre[i2] if i2 >= 0 and i2 < len(self.pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    j = len(items)
                    while True:
                        tmp1 = j
                        j = (j - 1)
                        if (not ((tmp1 > 0))):
                            break
                        item1 = (items[j] if j >= 0 and j < len(items) else None)
                        self.pre.insert((i2 + 1), item1)
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.len
                        _hx_local_2.len = (_hx_local_3 + (0 if ((item1 is None)) else len(item1)))
                        _hx_local_2.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((self.pre[i2] if i2 >= 0 and i2 < len(self.pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(self.pre, i2, (preSplitted[0] if 0 < len(preSplitted) else None))
                    self.pre.insert((i2 + 1), (preSplitted[1] if 1 < len(preSplitted) else None))
                    j1 = len(items)
                    while True:
                        tmp2 = j1
                        j1 = (j1 - 1)
                        if (not ((tmp2 > 0))):
                            break
                        item2 = (items[j1] if j1 >= 0 and j1 < len(items) else None)
                        self.pre.insert((i2 + 1), item2)
                        _hx_local_4 = self
                        _hx_local_5 = _hx_local_4.len
                        _hx_local_4.len = (_hx_local_5 + (0 if ((item2 is None)) else len(item2)))
                        _hx_local_4.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            _g2 = 0
            while (_g2 < len(items)):
                item3 = (items[_g2] if _g2 >= 0 and _g2 < len(items) else None)
                _g2 = (_g2 + 1)
                _this = self.sb
                s = Std.string(item3)
                _this.b.write(s)
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.len
                _hx_local_7.len = (_hx_local_8 + (0 if ((item3 is None)) else len(item3)))
                _hx_local_7.len
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this1 = self.sb
        s1 = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this1.b.write(s1)
        _g3 = 0
        while (_g3 < len(items)):
            item4 = (items[_g3] if _g3 >= 0 and _g3 < len(items) else None)
            _g3 = (_g3 + 1)
            _this2 = self.sb
            s2 = Std.string(item4)
            _this2.b.write(s2)
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.len
            _hx_local_10.len = (_hx_local_11 + (0 if ((item4 is None)) else len(item4)))
            _hx_local_10.len
        _this3 = self.sb
        s3 = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this3.b.write(s3)
        return self

    def asOutput(self):
        return hx_strings__StringBuilder_OutputWrapper(self)

    def toString(self):
        if (self.pre is None):
            return self.sb.b.getvalue()
        _this = self.pre
        _hx_str = (HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _this])) + HxOverrides.stringOrNull(self.sb.b.getvalue()))
        self.clear()
        _this1 = self.sb
        s = Std.string(_hx_str)
        _this1.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + (0 if ((_hx_str is None)) else len(_hx_str)))
        _hx_local_0.len
        return _hx_str

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.pre = None
        _hx_o.len = None


class hx_strings__StringBuilder_OutputWrapper(haxe_io_Output):
    _hx_class_name = "hx.strings._StringBuilder.OutputWrapper"
    __slots__ = ("sb", "bo")
    _hx_fields = ["sb", "bo"]
    _hx_methods = ["flush", "writeByte", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,sb):
        self.bo = None
        self.sb = sb

    def flush(self):
        if ((self.bo is not None) and ((len(self.bo.b.b) > 0))):
            _this = self.sb
            item = self.bo.getBytes().toString()
            _this1 = _this.sb
            s = Std.string(item)
            _this1.b.write(s)
            _this.len = (_this.len + (0 if ((item is None)) else len(item)))

    def writeByte(self,c):
        if (self.bo is None):
            self.bo = haxe_io_BytesOutput()
        self.bo.writeByte(c)

    def writeString(self,_hx_str,encoding = None):
        self.flush()
        _this = self.sb
        _this1 = _this.sb
        s = Std.string(_hx_str)
        _this1.b.write(s)
        _this.len = (_this.len + (0 if ((_hx_str is None)) else len(_hx_str)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.bo = None


class hx_strings_internal_OS:
    _hx_class_name = "hx.strings.internal.OS"
    __slots__ = ()
    _hx_statics = ["isWindows"]


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "iterator", "keyValueIterator", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def iterator(s):
        return haxe_iterators_StringIterator(s)

    @staticmethod
    def keyValueIterator(s):
        return haxe_iterators_StringKeyValueIterator(s)

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                return list(o._hx_fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "iterator"):
                    return python_internal_MethodClosure(o,HxString.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,HxString.keyValueIterator)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name

class hx_strings_internal__Either3__Either3(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either3._Either3"
    _hx_constructs = ["a", "b", "c"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either3__Either3("a", 0, [v])

    @staticmethod
    def b(v):
        return hx_strings_internal__Either3__Either3("b", 1, [v])

    @staticmethod
    def c(v):
        return hx_strings_internal__Either3__Either3("c", 2, [v])


class hx_strings_Strings:
    _hx_class_name = "hx.strings.Strings"
    __slots__ = ()
    _hx_statics = ["REGEX_ANSI_ESC", "REGEX_HTML_UNESCAPE", "REGEX_SPLIT_LINES", "REGEX_REMOVE_XML_TAGS", "POS_NOT_FOUND", "NEW_LINE_NIX", "NEW_LINE_WIN", "NEW_LINE", "_getNotFoundDefault", "_charCodeAt8Unsafe", "_splitAsciiWordsUnsafe", "ansiToHtml", "appendIfMissing", "base64Encode", "base64Decode", "charAt8", "charCodeAt8", "compact", "contains", "containsOnly", "containsAll", "containsAllIgnoreCase", "containsAny", "containsAnyIgnoreCase", "containsNone", "containsNoneIgnoreCase", "containsWhitespaces", "countMatches", "countMatchesIgnoreCase", "compare", "compareIgnoreCase", "diff", "diffAt", "ellipsizeLeft", "ellipsizeMiddle", "ellipsizeRight", "endsWith", "endsWithAny", "endsWithAnyIgnoreCase", "endsWithIgnoreCase", "equals", "equalsIgnoreCase", "filter", "filterChars", "getFuzzyDistance", "getLevenshteinDistance", "getLongestCommonSubstring", "hashCode", "htmlDecode", "htmlEncode", "insertAt", "ifBlank", "ifEmpty", "ifNull", "indentLines", "indexOf8", "isBlank", "isDigits", "isEmpty", "isNotBlank", "isNotEmpty", "isLowerCase", "isUpperCase", "iterate", "iterateChars", "lastIndexOf8", "length8", "left", "lpad", "map", "prependIfMissing", "quoteDouble", "quoteSingle", "removeAfter", "removeAfterLast", "removeAfterIgnoreCase", "removeAfterLastIgnoreCase", "removeAt", "removeBefore", "removeBeforeLast", "removeBeforeIgnoreCase", "removeBeforeLastIgnoreCase", "removeAll", "removeFirst", "removeFirstIgnoreCase", "removeAnsi", "removeLeading", "removeTags", "removeTrailing", "repeat", "replaceAll", "replaceFirst", "replaceFirstIgnoreCase", "reverse", "right", "rpad", "split8", "splitAt", "splitEvery", "splitLines", "startsWith", "startsWithAny", "startsWithAnyIgnoreCase", "startsWithIgnoreCase", "substr8", "substring8", "substringAfter", "substringAfterIgnoreCase", "substringBetween", "substringBetweenIgnoreCase", "substringAfterLast", "substringAfterLastIgnoreCase", "substringBefore", "substringBeforeIgnoreCase", "substringBeforeLast", "substringBeforeLastIgnoreCase", "toBool", "toBytes", "toChar", "toCharIterator", "toChars", "toPattern", "toEReg", "toFloat", "toHex", "toInt", "toLowerCase8", "toLowerCaseFirstChar", "toLowerCamel", "toLowerHyphen", "toLowerUnderscore", "toTitle", "toUpperCamel", "toUpperUnderscore", "toString", "toUpperCase8", "toUpperCaseFirstChar", "trim", "trimRight", "trimLeft", "trimLines", "trimToNull", "trimToEmpty", "truncate", "urlDecode", "urlEncode", "wrap"]

    @staticmethod
    def _getNotFoundDefault(_hx_str,notFoundDefault):
        notFoundDefault1 = notFoundDefault
        if (notFoundDefault1 == 1):
            return None
        elif (notFoundDefault1 == 2):
            return ""
        elif (notFoundDefault1 == 3):
            return _hx_str
        else:
            pass

    @staticmethod
    def _charCodeAt8Unsafe(_hx_str,pos):
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def _splitAsciiWordsUnsafe(_hx_str):
        words = list()
        currentWord = hx_strings_StringBuilder()
        chars = hx_strings_Strings.toChars(_hx_str)
        _hx_len = len(chars)
        lastIndex = (_hx_len - 1)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = (chars[i] if i >= 0 and i < len(chars) else None)
            if (((ch > 64) and ((ch < 91))) or (((ch > 96) and ((ch < 123))))):
                chNext = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                currentWord.addChar(ch)
                if ((chNext > 47) and ((chNext < 58))):
                    x = currentWord.toString()
                    words.append(x)
                    currentWord.clear()
                elif (ch in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    if ((chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h) and ((len(chars) > ((i + 2))))):
                        if (not (python_internal_ArrayImpl._get(chars, (i + 2)) in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)):
                            x1 = currentWord.toString()
                            words.append(x1)
                            currentWord.clear()
                elif (chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    x2 = currentWord.toString()
                    words.append(x2)
                    currentWord.clear()
            elif ((ch > 47) and ((ch < 58))):
                currentWord.addChar(ch)
                chNext1 = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                if (not (((chNext1 > 47) and ((chNext1 < 58))))):
                    x3 = currentWord.toString()
                    words.append(x3)
                    currentWord.clear()
            elif (currentWord.len > 0):
                x4 = currentWord.toString()
                words.append(x4)
                currentWord.clear()
        if (currentWord.len > 0):
            x5 = currentWord.toString()
            words.append(x5)
        return words

    @staticmethod
    def ansiToHtml(_hx_str,renderMethod = None,initialState = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (renderMethod is None):
            renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
        styleOrClassAttribute = None
        styleOrClassAttribute1 = renderMethod.index
        if (styleOrClassAttribute1 == 0):
            styleOrClassAttribute = "style"
        elif (styleOrClassAttribute1 == 1):
            styleOrClassAttribute = "class"
        elif (styleOrClassAttribute1 == 2):
            cb = renderMethod.params[0]
            styleOrClassAttribute = "class"
        else:
            pass
        sb = hx_strings_StringBuilder()
        if ((initialState is not None) and initialState.isActive()):
            item = (("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")
            _this = sb.sb
            s = Std.string(item)
            _this.b.write(s)
            sb.len = (sb.len + (0 if ((item is None)) else len(item)))
            _this1 = sb
            item1 = initialState.toCSS(renderMethod)
            _this2 = _this1.sb
            s1 = Std.string(item1)
            _this2.b.write(s1)
            _this1.len = (_this1.len + (0 if ((item1 is None)) else len(item1)))
            _this3 = _this1
            _this3.sb.b.write("\">")
            _this3.len = (_this3.len + len("\">"))
        effectiveState = hx_strings_AnsiState(initialState)
        strLenMinus1 = (((0 if ((_hx_str is None)) else len(_hx_str))) - 1)
        i = -1
        lookAhead = hx_strings_StringBuilder()
        while (i < strLenMinus1):
            i = (i + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            if (((ch == 27) and ((i < strLenMinus1))) and (HxString.charCodeAt(_hx_str,(i + 1)) == 91)):
                lookAhead.clear()
                currentState = hx_strings_AnsiState(effectiveState)
                currentGraphicModeParam = 0
                isValidEscapeSequence = False
                i = (i + 1)
                while (i < strLenMinus1):
                    i = (i + 1)
                    ch2 = HxString.charCodeAt(_hx_str,i)
                    lookAhead.addChar(ch2)
                    ch21 = ch2
                    if (ch21 == 48):
                        currentGraphicModeParam = (currentGraphicModeParam * 10)
                    elif (ch21 == 49):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 1)
                    elif (ch21 == 50):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 2)
                    elif (ch21 == 51):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 3)
                    elif (ch21 == 52):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 4)
                    elif (ch21 == 53):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 5)
                    elif (ch21 == 54):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 6)
                    elif (ch21 == 55):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 7)
                    elif (ch21 == 56):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 8)
                    elif (ch21 == 57):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 9)
                    elif (ch21 == 59):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        currentGraphicModeParam = 0
                    elif (ch21 == 109):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        if effectiveState.isActive():
                            sb.sb.b.write("</span>")
                            sb.len = (sb.len + len("</span>"))
                        if currentState.isActive():
                            item2 = (("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")
                            _this4 = sb.sb
                            s2 = Std.string(item2)
                            _this4.b.write(s2)
                            sb.len = (sb.len + (0 if ((item2 is None)) else len(item2)))
                            _this5 = sb
                            item3 = currentState.toCSS(renderMethod)
                            _this6 = _this5.sb
                            s3 = Std.string(item3)
                            _this6.b.write(s3)
                            _this5.len = (_this5.len + (0 if ((item3 is None)) else len(item3)))
                            _this7 = _this5
                            _this7.sb.b.write("\">")
                            _this7.len = (_this7.len + len("\">"))
                        effectiveState = currentState
                        isValidEscapeSequence = True
                        break
                    else:
                        break
                if (not isValidEscapeSequence):
                    _this8 = sb.addChar(27)
                    _this8.sb.b.write("[")
                    _this8.len = (_this8.len + len("["))
                    _this9 = _this8
                    item4 = Std.string(lookAhead)
                    _this10 = _this9.sb
                    s4 = Std.string(item4)
                    _this10.b.write(s4)
                    _this9.len = (_this9.len + (0 if ((item4 is None)) else len(item4)))
            else:
                sb.addChar(ch)
        if effectiveState.isActive():
            sb.sb.b.write("</span>")
            sb.len = (sb.len + len("</span>"))
        return sb.toString()

    @staticmethod
    def appendIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (("null" if _hx_str is None else _hx_str) + ("null" if suffix is None else suffix))
        if (False if (((_hx_str is None) or ((suffix is None)))) else _hx_str.endswith(suffix)):
            return _hx_str
        return (("null" if _hx_str is None else _hx_str) + ("null" if suffix is None else suffix))

    @staticmethod
    def base64Encode(plain):
        if (plain is None):
            return None
        return haxe_crypto_Base64.encode((None if ((plain is None)) else haxe_io_Bytes.ofString(plain)))

    @staticmethod
    def base64Decode(encoded):
        if (encoded is None):
            return None
        return haxe_crypto_Base64.decode(encoded).toString()

    @staticmethod
    def charAt8(_hx_str,pos,resultIfOutOfBound = ""):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = ""
        if ((((_hx_str is None) or ((len(_hx_str) == 0))) or ((pos < 0))) or ((pos >= ((0 if ((_hx_str is None)) else len(_hx_str)))))):
            return resultIfOutOfBound
        if ((pos < 0) or ((pos >= len(_hx_str)))):
            return ""
        else:
            return _hx_str[pos]

    @staticmethod
    def charCodeAt8(_hx_str,pos,resultIfOutOfBound = -1):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (((strLen == 0) or ((pos < 0))) or ((pos >= strLen))):
            return resultIfOutOfBound
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def compact(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        needWhiteSpace = False
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            char = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((char > 8) and ((char < 14))) or (char == 32)):
                if (sb.len != 0):
                    needWhiteSpace = True
                continue
            elif needWhiteSpace:
                sb.addChar(32)
                needWhiteSpace = False
            sb.addChar(char)
        return sb.toString()

    @staticmethod
    def contains(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if (searchFor == ""):
            return True
        return (searchIn.find(searchFor) > -1)

    @staticmethod
    def containsOnly(searchIn,allowedChars):
        if ((searchIn is None) or ((len(searchIn) == 0))):
            return True
        if (allowedChars is None):
            return False
        allowedCharsArray = None
        _g = allowedChars
        allowedCharsArray1 = _g.index
        if (allowedCharsArray1 == 0):
            _hx_str = _g.params[0]
            allowedCharsArray = hx_strings_Strings.toChars(_hx_str)
        elif (allowedCharsArray1 == 1):
            chars = _g.params[0]
            allowedCharsArray = chars
        else:
            pass
        _g3 = 0
        _g4 = hx_strings_Strings.toChars(searchIn)
        while (_g3 < len(_g4)):
            ch = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
            _g3 = (_g3 + 1)
            if (python_internal_ArrayImpl.indexOf(allowedCharsArray,ch,None) < 0):
                return False
        return True

    @staticmethod
    def containsAll(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if (not ((False if (((searchIn is None) or ((candidate is None)))) else (True if ((candidate == "")) else (searchIn.find(candidate) > -1))))):
                return False
        return True

    @staticmethod
    def containsAllIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            if (not ((False if (((searchIn is None) or ((searchFor1 is None)))) else (True if ((searchFor1 == "")) else (searchIn.find(searchFor1) > -1))))):
                return False
        return True

    @staticmethod
    def containsAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if (False if (((searchIn is None) or ((candidate is None)))) else (True if ((candidate == "")) else (searchIn.find(candidate) > -1))):
                return True
        return False

    @staticmethod
    def containsAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            if (False if (((searchIn is None) or ((searchFor1 is None)))) else (True if ((searchFor1 == "")) else (searchIn.find(searchFor1) > -1))):
                return True
        return False

    @staticmethod
    def containsNone(searchIn,searchFor):
        return (not hx_strings_Strings.containsAny(searchIn,searchFor))

    @staticmethod
    def containsNoneIgnoreCase(searchIn,searchFor):
        return (not hx_strings_Strings.containsAnyIgnoreCase(searchIn,searchFor))

    @staticmethod
    def containsWhitespaces(searchIn):
        if (searchIn is None):
            return False
        _g = 0
        _g1 = hx_strings_Strings.toChars(searchIn)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or (ch == 32)):
                return True
        return False

    @staticmethod
    def countMatches(searchIn,searchFor,startAt = 0):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else searchIn.find(searchFor, startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def countMatchesIgnoreCase(searchIn,searchFor,startAt = 0):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        searchIn = searchIn.lower()
        searchFor = searchFor.lower()
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else searchIn.find(searchFor, startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def compare(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        return haxe_Utf8.compare(_hx_str,other)

    @staticmethod
    def compareIgnoreCase(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        _hx_str = hx_strings_Strings.toLowerCase8(_hx_str)
        other = hx_strings_Strings.toLowerCase8(other)
        return haxe_Utf8.compare(_hx_str,other)

    @staticmethod
    def diff(left,right):
        diff = hx_strings_StringDiff()
        diff.at = hx_strings_Strings.diffAt(left,right)
        diff.left = hx_strings_Strings.substr8(left,diff.at)
        diff.right = hx_strings_Strings.substr8(right,diff.at)
        return diff

    @staticmethod
    def diffAt(_hx_str,other):
        if (_hx_str == other):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        otherLen = (0 if ((other is None)) else len(other))
        if ((strLen == 0) or ((otherLen == 0))):
            return 0
        checkLen = (otherLen if ((strLen > otherLen)) else strLen)
        _g = 0
        _g1 = checkLen
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxString.charCodeAt(_hx_str,i) != HxString.charCodeAt(other,i)):
                return i
        return checkLen

    @staticmethod
    def ellipsizeLeft(_hx_str,maxLength,ellipsis = "..."):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise _HxException(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        return (("null" if ellipsis is None else ellipsis) + HxOverrides.stringOrNull(hx_strings_Strings.right(_hx_str,(maxLength - ellipsisLen))))

    @staticmethod
    def ellipsizeMiddle(_hx_str,maxLength,ellipsis = "..."):
        if (ellipsis is None):
            ellipsis = "..."
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise _HxException(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        maxStrLen = (maxLength - ellipsisLen)
        leftLen = Math.floor(((maxStrLen / 2) + 0.5))
        rightLen = (maxStrLen - leftLen)
        return ((HxOverrides.stringOrNull(((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= leftLen)) else hx_strings_Strings.substring8(_hx_str,0,leftLen)))) + ("null" if ellipsis is None else ellipsis)) + HxOverrides.stringOrNull(hx_strings_Strings.right(_hx_str,rightLen)))

    @staticmethod
    def ellipsizeRight(_hx_str,maxLength,ellipsis = "..."):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise _HxException(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        _hx_len = (maxLength - ellipsisLen)
        return (HxOverrides.stringOrNull(((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len)) else hx_strings_Strings.substring8(_hx_str,0,_hx_len)))) + ("null" if ellipsis is None else ellipsis))

    @staticmethod
    def endsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        return searchIn.endswith(searchFor)

    @staticmethod
    def endsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and searchIn.endswith(candidate)):
                return True
        return False

    @staticmethod
    def endsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if (candidate is not None):
                end = hx_strings_Strings.toLowerCase8(candidate)
                tmp = searchIn.endswith(end)
            else:
                tmp = False
            if tmp:
                return True
        return False

    @staticmethod
    def endsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        s = searchIn.lower()
        end = searchFor.lower()
        return s.endswith(end)

    @staticmethod
    def equals(_hx_str,other):
        return (_hx_str == other)

    @staticmethod
    def equalsIgnoreCase(_hx_str,other):
        return (hx_strings_Strings.toLowerCase8(_hx_str) == hx_strings_Strings.toLowerCase8(other))

    @staticmethod
    def filter(_hx_str,_hx_filter,separator = ""):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = list(filter(_hx_filter,hx_strings_Strings.split8(_hx_str,[separator])))
        return separator.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def filterChars(_hx_str,_hx_filter):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(ch):
            return "".join(map(chr,[ch]))
        _this = list(map(_hx_local_0,list(filter(_hx_filter,hx_strings_Strings.toChars(_hx_str)))))
        return "".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def getFuzzyDistance(left,right):
        if (((left is None) or ((len(left) == 0))) or (((right is None) or ((len(right) == 0))))):
            return 0
        left = hx_strings_Strings.toLowerCase8(left)
        right = hx_strings_Strings.toLowerCase8(right)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftLastMatchAt = -100
        rightLastMatchAt = -100
        score = 0
        _g = 0
        _g1 = len(leftChars)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            leftChar = (leftChars[leftIdx] if leftIdx >= 0 and leftIdx < len(leftChars) else None)
            _g2 = ((rightLastMatchAt + 1) if ((rightLastMatchAt > -1)) else 0)
            _g11 = len(rightChars)
            while (_g2 < _g11):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                rightChar = (rightChars[rightIdx] if rightIdx >= 0 and rightIdx < len(rightChars) else None)
                if (leftChar == rightChar):
                    score = (score + 1)
                    if ((leftLastMatchAt == ((leftIdx - 1))) and ((rightLastMatchAt == ((rightIdx - 1))))):
                        score = (score + 2)
                    leftLastMatchAt = leftIdx
                    rightLastMatchAt = rightIdx
                    break
        return score

    @staticmethod
    def getLevenshteinDistance(left,right):
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if (leftLen == 0):
            return rightLen
        if (rightLen == 0):
            return leftLen
        if (leftLen > rightLen):
            tmp = left
            left = right
            right = tmp
            tmpLen = leftLen
            leftLen = rightLen
            rightLen = tmpLen
        prevCosts = list()
        costs = list()
        _g = 0
        _g1 = (leftLen + 1)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            prevCosts.append(leftIdx)
            costs.append(0)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        def _hx_local_0(a,b):
            if (a > b):
                return b
            else:
                return a
        _hx_min = _hx_local_0
        _g2 = 1
        _g3 = (rightLen + 1)
        while (_g2 < _g3):
            rightIdx = _g2
            _g2 = (_g2 + 1)
            rightChar = python_internal_ArrayImpl._get(rightChars, (rightIdx - 1))
            python_internal_ArrayImpl._set(costs, 0, rightIdx)
            _g21 = 1
            _g31 = (leftLen + 1)
            while (_g21 < _g31):
                leftIdx1 = _g21
                _g21 = (_g21 + 1)
                leftIdxMinus1 = (leftIdx1 - 1)
                cost = (0 if (((leftChars[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(leftChars) else None) == rightChar)) else 1)
                python_internal_ArrayImpl._set(costs, leftIdx1, _hx_min(_hx_min(((costs[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(costs) else None) + 1),((prevCosts[leftIdx1] if leftIdx1 >= 0 and leftIdx1 < len(prevCosts) else None) + 1)),((prevCosts[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(prevCosts) else None) + cost)))
            tmp1 = prevCosts
            prevCosts = costs
            costs = tmp1
        return (prevCosts[leftLen] if leftLen >= 0 and leftLen < len(prevCosts) else None)

    @staticmethod
    def getLongestCommonSubstring(left,right):
        if ((left is None) or ((right is None))):
            return None
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if ((leftLen == 0) or ((rightLen == 0))):
            return ""
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftSubStartAt = 0
        leftSubLen = 0
        _g = 0
        _g1 = leftLen
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = rightLen
            while (_g2 < _g11):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                currLen = 0
                while (python_internal_ArrayImpl._get(leftChars, (leftIdx + currLen)) == python_internal_ArrayImpl._get(rightChars, (rightIdx + currLen))):
                    currLen = (currLen + 1)
                    if (((leftIdx + currLen) >= leftLen) or (((rightIdx + currLen) >= rightLen))):
                        break
                if (currLen > leftSubLen):
                    leftSubLen = currLen
                    leftSubStartAt = leftIdx
        return hx_strings_Strings.substr8(left,leftSubStartAt,leftSubLen)

    @staticmethod
    def hashCode(_hx_str,algo = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return 0
        if (algo is None):
            algo = hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC
        if (algo is None):
            return hash(_hx_str)
        else:
            tmp = algo.index
            if (tmp == 1):
                return haxe_crypto_Adler32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 2):
                return haxe_crypto_Crc32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 3):
                hc = 5381
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = (((((((((((hc << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) ^ ch)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            elif (tmp == 4):
                hc1 = 0
                _g2 = 0
                _g11 = hx_strings_Strings.toChars(_hx_str)
                while (_g2 < len(_g11)):
                    ch1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    hc1 = ((((((((((hc1 << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc1) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch1) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc1
            elif (tmp == 5):
                hc2 = 0
                _g3 = 0
                _g12 = hx_strings_Strings.toChars(_hx_str)
                while (_g3 < len(_g12)):
                    ch2 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                    _g3 = (_g3 + 1)
                    hc2 = (((((((((((((hc2 << 6)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (((((hc2 << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc2) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch2) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc2
            else:
                return hash(_hx_str)

    @staticmethod
    def htmlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = hx_strings_Strings.REGEX_HTML_UNESCAPE
        def _hx_local_2():
            def _hx_local_1(m):
                match = m.matched()
                match1 = match
                _hx_local_0 = len(match1)
                if (_hx_local_0 == 5):
                    if (match1 == "&amp;"):
                        return "&"
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                elif (_hx_local_0 == 4):
                    if (match1 == "&gt;"):
                        return ">"
                    elif (match1 == "&lt;"):
                        return "<"
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                elif (_hx_local_0 == 6):
                    if (match1 == "&apos;"):
                        return "'"
                    elif (match1 == "&nbsp;"):
                        return " "
                    elif (match1 == "&quot;"):
                        return "\""
                    else:
                        this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        return "".join(map(chr,[this1]))
                else:
                    this1 = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                    return "".join(map(chr,[this1]))
            return hx_strings__Pattern_MatcherImpl(_this.ereg,_this.pattern,_this.options,_hx_str).map(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def htmlEncode(_hx_str,escapeQuotes = False):
        if (escapeQuotes is None):
            escapeQuotes = False
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        isFirstSpace = True
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            ch1 = ch
            if (ch1 == 32):
                if isFirstSpace:
                    sb.sb.b.write(" ")
                    sb.len = (sb.len + len(" "))
                    isFirstSpace = False
                else:
                    sb.sb.b.write("&nbsp;")
                    sb.len = (sb.len + len("&nbsp;"))
            elif (ch1 == 34):
                item = ("&quot;" if escapeQuotes else "\"")
                _this = sb.sb
                s = Std.string(item)
                _this.b.write(s)
                sb.len = (sb.len + (0 if ((item is None)) else len(item)))
            elif (ch1 == 38):
                sb.sb.b.write("&amp;")
                sb.len = (sb.len + len("&amp;"))
            elif (ch1 == 39):
                item1 = ("&#039;" if escapeQuotes else "'")
                _this1 = sb.sb
                s1 = Std.string(item1)
                _this1.b.write(s1)
                sb.len = (sb.len + (0 if ((item1 is None)) else len(item1)))
            elif (ch1 == 60):
                sb.sb.b.write("&lt;")
                sb.len = (sb.len + len("&lt;"))
            elif (ch1 == 62):
                sb.sb.b.write("&gt;")
                sb.len = (sb.len + len("&gt;"))
            elif (ch > 127):
                item2 = (("&#" + Std.string(ch)) + ";")
                _this2 = sb.sb
                s2 = Std.string(item2)
                _this2.b.write(s2)
                sb.len = (sb.len + (0 if ((item2 is None)) else len(item2)))
            else:
                sb.addChar(ch)
            if (ch != 32):
                isFirstSpace = True
        return sb.toString()

    @staticmethod
    def insertAt(_hx_str,pos,insertion):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        pos = ((strLen + pos) if ((pos < 0)) else pos)
        if ((pos < 0) or ((pos > strLen))):
            raise _HxException("Absolute value of [pos] must be <= str.length")
        if ((insertion is None) or ((len(insertion) == 0))):
            return _hx_str
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,0,pos)) + Std.string(insertion)) + HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,pos)))

    @staticmethod
    def ifBlank(_hx_str,fallback):
        if (True if ((_hx_str is None)) else (len(StringTools.trim(_hx_str)) == 0)):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifEmpty(_hx_str,fallback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifNull(_hx_str,fallback):
        if (_hx_str is None):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def indentLines(_hx_str,indentWith):
        if (_hx_str is None):
            return None
        if ((len(_hx_str) == 0) or (((indentWith is None) or ((len(indentWith) == 0))))):
            return _hx_str
        isFirstLine = True
        sb = hx_strings_StringBuilder()
        _g = 0
        _g1 = hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if isFirstLine:
                isFirstLine = False
            else:
                sb.sb.b.write("\n")
                sb.len = (sb.len + 1)
            _this = sb.sb
            s = Std.string(indentWith)
            _this.b.write(s)
            sb.len = (sb.len + (0 if ((indentWith is None)) else len(indentWith)))
            _this1 = sb.sb
            s1 = Std.string(line)
            _this1.b.write(s1)
            sb.len = (sb.len + (0 if ((line is None)) else len(line)))
        return sb.toString()

    @staticmethod
    def indexOf8(_hx_str,searchFor,startAt = 0):
        if (startAt is None):
            startAt = 0
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt < 0):
            startAt = 0
        if (searchForLen == 0):
            if (startAt == 0):
                return 0
            if ((startAt > 0) and ((startAt < strLen))):
                return startAt
            return strLen
        if (startAt >= strLen):
            return -1
        return (_hx_str.find(searchFor) if ((startAt is None)) else _hx_str.find(searchFor, startAt))

    @staticmethod
    def isBlank(_hx_str):
        if (_hx_str is None):
            return True
        else:
            return (len(StringTools.trim(_hx_str)) == 0)

    @staticmethod
    def isDigits(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = HxString.charCodeAt(_hx_str,i)
            if (not (((this1 > 47) and ((this1 < 58))))):
                return False
        return True

    @staticmethod
    def isEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) == 0)
        else:
            return True

    @staticmethod
    def isNotBlank(_hx_str):
        if (_hx_str is not None):
            return (len(StringTools.trim(_hx_str)) > 0)
        else:
            return False

    @staticmethod
    def isNotEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) > 0)
        else:
            return False

    @staticmethod
    def isLowerCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toLowerCase8(_hx_str))

    @staticmethod
    def isUpperCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toUpperCase8(_hx_str))

    @staticmethod
    def iterate(_hx_str,callback,separator = ""):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = hx_strings_Strings.split8(_hx_str,[separator])
        while (_g < len(_g1)):
            sub = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            callback(sub)

    @staticmethod
    def iterateChars(_hx_str,callback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            callback(HxString.charCodeAt(_hx_str,i))

    @staticmethod
    def lastIndexOf8(_hx_str,searchFor,startAt = None):
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt is None):
            startAt = strLen
        if (searchForLen == 0):
            if (startAt < 0):
                return 0
            if (startAt > strLen):
                return strLen
            return startAt
        if (startAt < 0):
            return -1
        elif (startAt >= strLen):
            startAt = (strLen - 1)
        strNeedsUTF8Workaround = (len(_hx_str) != strLen)
        searchForNeedsUTF8Workaround = (len(searchFor) != searchForLen)
        if (searchForNeedsUTF8Workaround and (not strNeedsUTF8Workaround)):
            return -1
        searchForChars = hx_strings_Strings.toChars(searchFor)
        startAt = (startAt + ((searchForLen - 1)))
        searchForPosToCheck = (searchForLen - 1)
        strPos = strLen
        while True:
            tmp = strPos
            strPos = (strPos - 1)
            if (not ((tmp > 0))):
                break
            if (strPos > startAt):
                continue
            strCh = HxString.charCodeAt(_hx_str,strPos)
            if (strCh == (searchForChars[searchForPosToCheck] if searchForPosToCheck >= 0 and searchForPosToCheck < len(searchForChars) else None)):
                if (searchForPosToCheck == 0):
                    return strPos
                searchForPosToCheck = (searchForPosToCheck - 1)
            else:
                searchForPosToCheck = (searchForLen - 1)
        return -1

    @staticmethod
    def length8(_hx_str):
        if (_hx_str is None):
            return 0
        return len(_hx_str)

    @staticmethod
    def left(_hx_str,_hx_len):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,0,_hx_len)

    @staticmethod
    def lpad(_hx_str,targetLength,padStr = " ",canOverflow = True):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        sb = [_hx_str]
        padLen = (0 if ((padStr is None)) else len(padStr))
        while (strLen < targetLength):
            sb.insert(0, padStr)
            strLen = (strLen + padLen)
        if canOverflow:
            return "".join([python_Boot.toString1(x1,'') for x1 in sb])
        return hx_strings_Strings.right("".join([python_Boot.toString1(x1,'') for x1 in sb]),targetLength)

    @staticmethod
    def map(_hx_str,mapper,separator = ""):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (separator is None):
            raise _HxException("[seperator] must not be null")
        return list(map(mapper,hx_strings_Strings.split8(_hx_str,[separator])))

    @staticmethod
    def prependIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (("null" if suffix is None else suffix) + ("null" if _hx_str is None else _hx_str))
        if hx_strings_Strings.startsWith(_hx_str,suffix):
            return _hx_str
        return (("null" if suffix is None else suffix) + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def quoteDouble(_hx_str):
        if (_hx_str is None):
            return _hx_str
        if (len(_hx_str) == 0):
            return "\"\""
        if (not ((False if ((_hx_str is None)) else (_hx_str.find("\"") > -1)))):
            return (("\"" + ("null" if _hx_str is None else _hx_str)) + "\"")
        return (("\"" + HxOverrides.stringOrNull(hx_strings_Strings.replaceAll(_hx_str,"\"","\\\""))) + "\"")

    @staticmethod
    def quoteSingle(_hx_str):
        if (_hx_str is None):
            return _hx_str
        if (len(_hx_str) == 0):
            return "''"
        if (not ((False if ((_hx_str is None)) else (_hx_str.find("'") > -1)))):
            return (("'" + ("null" if _hx_str is None else _hx_str)) + "'")
        return (("'" + HxOverrides.stringOrNull(hx_strings_Strings.replaceAll(_hx_str,"'","\\'"))) + "'")

    @staticmethod
    def removeAfter(_hx_str,searchFor):
        return hx_strings_Strings.substringBefore(_hx_str,searchFor)

    @staticmethod
    def removeAfterLast(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLast(_hx_str,searchFor)

    @staticmethod
    def removeAfterIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAfterLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAt(_hx_str,pos,length):
        if (((_hx_str is None) or ((len(_hx_str) == 0))) or ((length < 1))):
            return _hx_str
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        pos = ((strLen + pos) if ((pos < 0)) else pos)
        if (pos < 0):
            raise _HxException("[pos] must be smaller than -1 * str.length")
        if ((pos + length) >= strLen):
            return hx_strings_Strings.substring8(_hx_str,0,pos)
        return (HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,0,pos)) + HxOverrides.stringOrNull(hx_strings_Strings.substring8(_hx_str,(pos + length))))

    @staticmethod
    def removeBefore(_hx_str,searchFor):
        return hx_strings_Strings.substringAfter(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLast(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLast(_hx_str,searchFor)

    @staticmethod
    def removeBeforeIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAll(searchIn,searchFor):
        return hx_strings_Strings.replaceAll(searchIn,searchFor,"")

    @staticmethod
    def removeFirst(searchIn,searchFor):
        return hx_strings_Strings.replaceFirst(searchIn,searchFor,"")

    @staticmethod
    def removeFirstIgnoreCase(searchIn,searchFor):
        return hx_strings_Strings.replaceFirstIgnoreCase(searchIn,searchFor,"")

    @staticmethod
    def removeAnsi(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.REGEX_ANSI_ESC.ereg.replace(_hx_str,"")

    @staticmethod
    def removeLeading(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while hx_strings_Strings.startsWith(searchIn,searchFor):
            searchIn = HxString.substring(searchIn,len(searchFor),len(searchIn))
        return searchIn

    @staticmethod
    def removeTags(xml):
        if ((xml is None) or ((len(xml) == 0))):
            return xml
        return hx_strings_Strings.REGEX_REMOVE_XML_TAGS.ereg.replace(xml,"")

    @staticmethod
    def removeTrailing(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while (False if (((searchIn is None) or ((searchFor is None)))) else searchIn.endswith(searchFor)):
            searchIn = HxString.substring(searchIn,0,(len(searchIn) - len(searchFor)))
        return searchIn

    @staticmethod
    def repeat(_hx_str,count,separator = ""):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (count < 1):
            return ""
        if (count == 1):
            return _hx_str
        _g = []
        _g1 = 0
        _g2 = count
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(_hx_str)
        return separator.join([python_Boot.toString1(x1,'') for x1 in _g])

    @staticmethod
    def replaceAll(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        return StringTools.replace(searchIn,searchFor,replaceWith)

    @staticmethod
    def replaceFirst(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn,searchFor)
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def replaceFirstIgnoreCase(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        searchFor = searchFor.lower()
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn.lower(),searchFor)
        return ((HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + HxOverrides.stringOrNull(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def reverse(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        chars = hx_strings_Strings.split8(_hx_str,[""])
        chars.reverse()
        return "".join([python_Boot.toString1(x1,'') for x1 in chars])

    @staticmethod
    def right(_hx_str,_hx_len):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - _hx_len))

    @staticmethod
    def rpad(_hx_str,targetLength,padStr = " ",canOverflow = True):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        padLen = (0 if ((padStr is None)) else len(padStr))
        sb = hx_strings_StringBuilder(_hx_str)
        while (strLen < targetLength):
            _this = sb.sb
            s = Std.string(padStr)
            _this.b.write(s)
            sb.len = (sb.len + (0 if ((padStr is None)) else len(padStr)))
            strLen = (strLen + padLen)
        if canOverflow:
            return sb.toString()
        str1 = sb.toString()
        if (((0 if ((str1 is None)) else len(str1))) <= targetLength):
            return str1
        else:
            return hx_strings_Strings.substring8(str1,0,targetLength)

    @staticmethod
    def split8(_hx_str,separator,maxParts = 0):
        if (maxParts is None):
            maxParts = 0
        if ((_hx_str is None) or ((separator is None))):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        def _hx_local_0(s):
            return (s is not None)
        separators = list(filter(_hx_local_0,separator))
        if (len(separators) == 0):
            return None
        if ((maxParts <= 0) and ((len(separators) == 1))):
            delimiter = (separators[0] if 0 < len(separators) else None)
            if (delimiter == ""):
                return list(_hx_str)
            else:
                return _hx_str.split(delimiter)
        if (python_internal_ArrayImpl.indexOf(separators,"",None) > -1):
            if (maxParts <= 0):
                _g = []
                _g1 = 0
                _g2 = strLen
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = HxString.substr(_hx_str,i,1)
                    _g.append(x)
                return _g
            if (maxParts > strLen):
                maxParts = strLen
            maxParts = (maxParts - 1)
            _g3 = []
            _g11 = 0
            _g21 = maxParts
            while (_g11 < _g21):
                i1 = _g11
                _g11 = (_g11 + 1)
                x1 = HxString.substr(_hx_str,i1,1)
                _g3.append(x1)
            result = _g3
            x2 = HxString.substr(_hx_str,maxParts,(strLen - maxParts))
            result.append(x2)
            return result
        _g4 = []
        _g12 = 0
        while (_g12 < len(separators)):
            sep = (separators[_g12] if _g12 >= 0 and _g12 < len(separators) else None)
            _g12 = (_g12 + 1)
            x3 = (0 if ((sep is None)) else len(sep))
            _g4.append(x3)
        separatorsLengths = _g4
        lastFoundAt = 0
        result1 = []
        resultCount = 0
        while True:
            separatorLen = 0
            foundAt = -1
            _g22 = 0
            _g31 = len(separators)
            while (_g22 < _g31):
                i2 = _g22
                _g22 = (_g22 + 1)
                sepFoundAt = hx_strings_Strings.indexOf8(_hx_str,(separators[i2] if i2 >= 0 and i2 < len(separators) else None),lastFoundAt)
                if (sepFoundAt != -1):
                    if ((foundAt == -1) or ((sepFoundAt < foundAt))):
                        foundAt = sepFoundAt
                        separatorLen = (separatorsLengths[i2] if i2 >= 0 and i2 < len(separatorsLengths) else None)
            resultCount = (resultCount + 1)
            if ((foundAt == -1) or ((resultCount == maxParts))):
                x4 = HxString.substr(_hx_str,lastFoundAt,(strLen - lastFoundAt))
                result1.append(x4)
                break
            x5 = HxString.substr(_hx_str,lastFoundAt,(foundAt - lastFoundAt))
            result1.append(x5)
            lastFoundAt = (foundAt + separatorLen)
        return result1

    @staticmethod
    def splitAt(_hx_str,splitPos):
        if (_hx_str is None):
            return None
        if ((splitPos is None) or ((len(splitPos) == 0))):
            return [_hx_str]
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return [_hx_str]
        pos = list()
        p = python_HaxeIterator(splitPos.__iter__())
        while p.hasNext():
            p1 = p.next()
            if (p1 < 0):
                p1 = (strLen + p1)
            if ((p1 < 0) or ((p1 >= strLen))):
                continue
            if (python_internal_ArrayImpl.indexOf(pos,p1,None) > -1):
                continue
            pos.append(p1)
        def _hx_local_0(a,b):
            if (a < b):
                return -1
            elif (a > b):
                return 1
            else:
                return 0
        pos.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        result = list()
        lastPos = 0
        _g = 0
        while (_g < len(pos)):
            p2 = (pos[_g] if _g >= 0 and _g < len(pos) else None)
            _g = (_g + 1)
            chunk = hx_strings_Strings.substring8(_hx_str,lastPos,p2)
            if ((chunk is not None) and ((len(chunk) > 0))):
                result.append(chunk)
            lastPos = p2
        chunk1 = hx_strings_Strings.substring8(_hx_str,lastPos)
        if ((chunk1 is not None) and ((len(chunk1) > 0))):
            result.append(chunk1)
        return result

    @staticmethod
    def splitEvery(_hx_str,count):
        if (_hx_str is None):
            return None
        if (count < 1):
            raise _HxException("[count] must be greater than 0")
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((strLen == 0) or ((count >= strLen))):
            return [_hx_str]
        result = list()
        pos = 0
        while True:
            chunk = hx_strings_Strings.substr8(_hx_str,pos,count)
            pos = (pos + count)
            if ((chunk is None) or ((len(chunk) == 0))):
                break
            result.append(chunk)
        return result

    @staticmethod
    def splitLines(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return []
        return hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)

    @staticmethod
    def startsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if ((searchFor is None) or ((len(searchFor) == 0))):
            return True
        return searchIn.startswith(searchFor)

    @staticmethod
    def startsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and searchIn.startswith(candidate)):
                return True
        return False

    @staticmethod
    def startsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if (candidate is not None):
                start = hx_strings_Strings.toLowerCase8(candidate)
                tmp = searchIn.startswith(start)
            else:
                tmp = False
            if tmp:
                return True
        return False

    @staticmethod
    def startsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if ((searchFor is None) or ((len(searchFor) == 0))):
            return True
        s = searchIn.lower()
        start = searchFor.lower()
        return s.startswith(start)

    @staticmethod
    def substr8(_hx_str,startAt,_hx_len = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (_hx_len is None):
            _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        if (_hx_len <= 0):
            return ""
        if (startAt < 0):
            startAt = (startAt + (0 if ((_hx_str is None)) else len(_hx_str)))
            if (startAt < 0):
                startAt = 0
        return HxString.substr(_hx_str,startAt,_hx_len)

    @staticmethod
    def substring8(_hx_str,startAt,endAt = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (endAt is None):
            endAt = (0 if ((_hx_str is None)) else len(_hx_str))
        return HxString.substring(_hx_str,startAt,endAt)

    @staticmethod
    def substringAfter(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        foundAt = _hx_str.find(searchFor)
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterIgnoreCase(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        foundAt = _this.find(searchFor)
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBetween(_hx_str,after,before = None,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if (((_hx_str == "") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        foundAfterAt = _hx_str.find(after)
        if (foundAfterAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        startIndex = (foundAfterAt + len(after))
        foundBeforeAt = (_hx_str.find(before) if ((startIndex is None)) else _hx_str.find(before, startIndex))
        if (foundBeforeAt == -1):
            notFoundDefault3 = notFoundDefault
            if (notFoundDefault3 == 1):
                return None
            elif (notFoundDefault3 == 2):
                return ""
            elif (notFoundDefault3 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAfterAt + len(after)),foundBeforeAt)

    @staticmethod
    def substringBetweenIgnoreCase(_hx_str,after,before = None,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if (((_hx_str == "") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        strLower = hx_strings_Strings.toLowerCase8(_hx_str)
        after = hx_strings_Strings.toLowerCase8(after)
        before = hx_strings_Strings.toLowerCase8(before)
        foundAfterAt = strLower.find(after)
        if (foundAfterAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        startIndex = (foundAfterAt + len(after))
        foundBeforeAt = (strLower.find(before) if ((startIndex is None)) else strLower.find(before, startIndex))
        if (foundBeforeAt == -1):
            notFoundDefault3 = notFoundDefault
            if (notFoundDefault3 == 1):
                return None
            elif (notFoundDefault3 == 2):
                return ""
            elif (notFoundDefault3 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAfterAt + len(after)),foundBeforeAt)

    @staticmethod
    def substringAfterLast(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterLastIgnoreCase(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        foundAt = _this.rfind(searchFor, 0, len(_this))
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBefore(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        foundAt = _hx_str.find(searchFor)
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeIgnoreCase(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        foundAt = _this.find(searchFor)
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLast(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLastIgnoreCase(_hx_str,searchFor,notFoundDefault = 2):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if ((_hx_str == "") or (((searchFor is None) or ((len(searchFor) == 0))))):
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                return None
            elif (notFoundDefault1 == 2):
                return ""
            elif (notFoundDefault1 == 3):
                return _hx_str
            else:
                pass
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        foundAt = _this.rfind(searchFor, 0, len(_this))
        if (foundAt == -1):
            notFoundDefault2 = notFoundDefault
            if (notFoundDefault2 == 1):
                return None
            elif (notFoundDefault2 == 2):
                return ""
            elif (notFoundDefault2 == 3):
                return _hx_str
            else:
                pass
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def toBool(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = _hx_str.lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 1):
            if (_g == "0"):
                return False
            else:
                return True
        elif (_hx_local_0 == 5):
            if (_g == "false"):
                return False
            else:
                return True
        elif (_hx_local_0 == 2):
            if (_g == "no"):
                return False
            else:
                return True
        else:
            return True

    @staticmethod
    def toBytes(_hx_str):
        if (_hx_str is None):
            return None
        return haxe_io_Bytes.ofString(_hx_str)

    @staticmethod
    def toChar(charCode):
        return charCode

    @staticmethod
    def toCharIterator(_hx_str):
        if (_hx_str is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        else:
            return hx_strings__CharIterator_StringCharIterator(_hx_str,0)

    @staticmethod
    def toChars(_hx_str):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        _g = []
        _g1 = 0
        _g2 = strLen
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = HxString.charCodeAt(_hx_str,i)
            _g.append(x)
        return _g

    @staticmethod
    def toPattern(_hx_str,options = None):
        if (_hx_str is None):
            return None
        return hx_strings_Pattern.compile(_hx_str,options)

    @staticmethod
    def toEReg(_hx_str,opt = ""):
        if (opt is None):
            opt = ""
        if (_hx_str is None):
            return None
        return EReg(_hx_str,opt)

    @staticmethod
    def toFloat(_hx_str,ifUnparseable = None):
        result = Std.parseFloat(_hx_str)
        if python_lib_Math.isnan(result):
            return ifUnparseable
        return result

    @staticmethod
    def toHex(num,minDigits = 0,upperCase = True):
        if (minDigits is None):
            minDigits = 0
        if (upperCase is None):
            upperCase = True
        hexed = StringTools.hex(num,0)
        if (not upperCase):
            return hexed.lower()
        if (len(hexed) >= minDigits):
            return hexed
        return hx_strings_Strings.lpad(hexed,minDigits,"0")

    @staticmethod
    def toInt(_hx_str,ifUnparseable = None):
        result = Std.parseInt(_hx_str)
        if (result is None):
            return ifUnparseable
        return result

    @staticmethod
    def toLowerCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.lower()

    @staticmethod
    def toLowerCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        firstChar = (this1 if ((lowerChar is None)) else lowerChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def toLowerCamel(_hx_str,keepUppercasedWords = True):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                item = hx_strings_Strings.toUpperCaseFirstChar(word)
                _this = sb.sb
                s = Std.string(item)
                _this.b.write(s)
                sb.len = (sb.len + (0 if ((item is None)) else len(item)))
        else:
            _g2 = 0
            _g11 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g2 < len(_g11)):
                word1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                item1 = hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word1))
                _this1 = sb.sb
                s1 = Std.string(item1)
                _this1.b.write(s1)
                sb.len = (sb.len + (0 if ((item1 is None)) else len(item1)))
        return hx_strings_Strings.toLowerCaseFirstChar(sb.toString())

    @staticmethod
    def toLowerHyphen(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "-".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toLowerUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toTitle(_hx_str,keepUppercasedWords = True):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if keepUppercasedWords:
            def _hx_local_0(s):
                if (hx_strings_Strings.toUpperCase8(s) == s):
                    return s
                else:
                    return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s))
            _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
            return " ".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_1(s1):
            return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s1))
        _this1 = list(map(_hx_local_1,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this1])

    @staticmethod
    def toUpperCamel(_hx_str,keepUppercasedWords = True):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                item = hx_strings_Strings.toUpperCaseFirstChar(word)
                _this = sb.sb
                s = Std.string(item)
                _this.b.write(s)
                sb.len = (sb.len + (0 if ((item is None)) else len(item)))
        else:
            _g2 = 0
            _g11 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g2 < len(_g11)):
                word1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                item1 = hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word1))
                _this1 = sb.sb
                s1 = Std.string(item1)
                _this1.b.write(s1)
                sb.len = (sb.len + (0 if ((item1 is None)) else len(item1)))
        return sb.toString()

    @staticmethod
    def toUpperUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toUpperCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toString(_hx_str):
        if (_hx_str is None):
            return "null"
        else:
            return _hx_str

    @staticmethod
    def toUpperCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.upper()

    @staticmethod
    def toUpperCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        firstChar = (this1 if ((upperChar is None)) else upperChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def trim(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.trim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        this1 = hx_strings_internal__Either2__Either2.b(removableChars)
        this2 = hx_strings_internal__Either2__Either2.b(removableChars)
        return hx_strings_Strings.trimLeft(hx_strings_Strings.trimRight(_hx_str,this1),this2)

    @staticmethod
    def trimRight(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.rtrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = (_hx_len - 1)
        while True:
            tmp = None
            if (i > -1):
                str2 = hx_strings_Strings.charAt8(_hx_str,i)
                strLen = (0 if ((str2 is None)) else len(str2))
                tmp = (python_internal_ArrayImpl.indexOf(removableChars,(-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt(str2,0)),None) > -1)
            else:
                tmp = False
            if (not tmp):
                break
            i = (i - 1)
        if (i < ((_hx_len - 1))):
            return hx_strings_Strings.substring8(_hx_str,0,(i + 1))
        return _hx_str

    @staticmethod
    def trimLeft(_hx_str,charsToRemove = None):
        if (_hx_str is None):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.ltrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = 0
        while True:
            tmp = None
            if (i < _hx_len):
                str2 = hx_strings_Strings.charAt8(_hx_str,i)
                strLen = (0 if ((str2 is None)) else len(str2))
                tmp = (python_internal_ArrayImpl.indexOf(removableChars,(-1 if (((strLen == 0) or ((0 >= strLen)))) else HxString.charCodeAt(str2,0)),None) > -1)
            else:
                tmp = False
            if (not tmp):
                break
            i = (i + 1)
        if (i > 0):
            return hx_strings_Strings.substring8(_hx_str,i,_hx_len)
        return _hx_str

    @staticmethod
    def trimLines(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(line):
            return hx_strings_Strings.trim(line,charsToRemove)
        _this = list(map(_hx_local_0,hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)))
        return "\n".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def trimToNull(_hx_str):
        if (_hx_str is None):
            return None
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return None
        return trimmed

    @staticmethod
    def trimToEmpty(_hx_str):
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return ""
        return trimmed

    @staticmethod
    def truncate(_hx_str,maxLength):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        else:
            return hx_strings_Strings.substring8(_hx_str,0,maxLength)

    @staticmethod
    def urlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.unquote(_hx_str)

    @staticmethod
    def urlEncode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.quote(_hx_str,"")

    @staticmethod
    def wrap(_hx_str,maxLineLength,splitLongWords = True,newLineSeparator = "\n"):
        if (splitLongWords is None):
            splitLongWords = True
        if (newLineSeparator is None):
            newLineSeparator = "\n"
        if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLineLength) or ((maxLineLength < 1))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        wordChars = []
        currLineLength = 0
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or (ch == 32)):
                if (len(wordChars) > 0):
                    _g2 = 0
                    while (_g2 < len(wordChars)):
                        wordCh = (wordChars[_g2] if _g2 >= 0 and _g2 < len(wordChars) else None)
                        _g2 = (_g2 + 1)
                        if ((currLineLength == maxLineLength) and splitLongWords):
                            _this = sb.sb
                            s = Std.string(newLineSeparator)
                            _this.b.write(s)
                            sb.len = (sb.len + (0 if ((newLineSeparator is None)) else len(newLineSeparator)))
                            currLineLength = 0
                        currLineLength = (currLineLength + 1)
                        sb.addChar(wordCh)
                    wordChars = []
                if (currLineLength >= maxLineLength):
                    _this1 = sb.sb
                    s1 = Std.string(newLineSeparator)
                    _this1.b.write(s1)
                    sb.len = (sb.len + (0 if ((newLineSeparator is None)) else len(newLineSeparator)))
                    currLineLength = 0
                sb.addChar(ch)
                currLineLength = (currLineLength + 1)
            else:
                wordChars.append(ch)
        if (len(wordChars) > 0):
            _g21 = 0
            while (_g21 < len(wordChars)):
                wordCh1 = (wordChars[_g21] if _g21 >= 0 and _g21 < len(wordChars) else None)
                _g21 = (_g21 + 1)
                if ((currLineLength == maxLineLength) and splitLongWords):
                    _this2 = sb.sb
                    s2 = Std.string(newLineSeparator)
                    _this2.b.write(s2)
                    sb.len = (sb.len + (0 if ((newLineSeparator is None)) else len(newLineSeparator)))
                    currLineLength = 0
                currLineLength = (currLineLength + 1)
                sb.addChar(wordCh1)
        return sb.toString()


class hx_strings_StringDiff:
    _hx_class_name = "hx.strings.StringDiff"
    __slots__ = ("at", "left", "right")
    _hx_fields = ["at", "left", "right"]

    def __init__(self):
        self.right = None
        self.left = None
        self.at = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.at = None
        _hx_o.left = None
        _hx_o.right = None

class hx_strings_HashCodeAlgorithm(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.HashCodeAlgorithm"
    _hx_constructs = ["PLATFORM_SPECIFIC", "ADLER32", "CRC32B", "DJB2A", "JAVA", "SDBM"]
hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC = hx_strings_HashCodeAlgorithm("PLATFORM_SPECIFIC", 0, list())
hx_strings_HashCodeAlgorithm.ADLER32 = hx_strings_HashCodeAlgorithm("ADLER32", 1, list())
hx_strings_HashCodeAlgorithm.CRC32B = hx_strings_HashCodeAlgorithm("CRC32B", 2, list())
hx_strings_HashCodeAlgorithm.DJB2A = hx_strings_HashCodeAlgorithm("DJB2A", 3, list())
hx_strings_HashCodeAlgorithm.JAVA = hx_strings_HashCodeAlgorithm("JAVA", 4, list())
hx_strings_HashCodeAlgorithm.SDBM = hx_strings_HashCodeAlgorithm("SDBM", 5, list())

class hx_strings_AnsiToHtmlRenderMethod(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.AnsiToHtmlRenderMethod"
    _hx_constructs = ["StyleAttributes", "CssClasses", "CssClassesCallback"]

    @staticmethod
    def CssClassesCallback(func):
        return hx_strings_AnsiToHtmlRenderMethod("CssClassesCallback", 2, [func])
hx_strings_AnsiToHtmlRenderMethod.StyleAttributes = hx_strings_AnsiToHtmlRenderMethod("StyleAttributes", 0, list())
hx_strings_AnsiToHtmlRenderMethod.CssClasses = hx_strings_AnsiToHtmlRenderMethod("CssClasses", 1, list())


class hx_strings_AnsiState:
    _hx_class_name = "hx.strings.AnsiState"
    __slots__ = ("bgcolor", "blink", "bold", "fgcolor", "underline")
    _hx_fields = ["bgcolor", "blink", "bold", "fgcolor", "underline"]
    _hx_methods = ["isActive", "reset", "copyFrom", "setGraphicModeParameter", "toCSS"]
    _hx_statics = ["defaultCssClassesCallback"]

    def __init__(self,copyFrom = None):
        self.underline = None
        self.fgcolor = None
        self.bold = None
        self.blink = None
        self.bgcolor = None
        if (copyFrom is None):
            self.reset()
        else:
            self.copyFrom(copyFrom)

    def isActive(self):
        if (not (((((self.fgcolor is not None) or ((self.bgcolor is not None))) or self.bold) or self.underline))):
            return self.blink
        else:
            return True

    def reset(self):
        self.fgcolor = None
        self.bgcolor = None
        self.bold = False
        self.underline = False
        self.blink = False

    def copyFrom(self,other):
        self.fgcolor = other.fgcolor
        self.bgcolor = other.bgcolor
        self.bold = other.bold
        self.underline = other.underline
        self.blink = other.blink

    def setGraphicModeParameter(self,param):
        param1 = param
        if (param1 == 0):
            self.reset()
        elif (param1 == 1):
            self.bold = True
        elif (param1 == 4):
            self.underline = True
        elif (param1 == 5):
            self.blink = True
        elif (param1 == 30):
            self.fgcolor = "black"
        elif (param1 == 31):
            self.fgcolor = "red"
        elif (param1 == 32):
            self.fgcolor = "green"
        elif (param1 == 33):
            self.fgcolor = "yellow"
        elif (param1 == 34):
            self.fgcolor = "blue"
        elif (param1 == 35):
            self.fgcolor = "magenta"
        elif (param1 == 36):
            self.fgcolor = "cyan"
        elif (param1 == 37):
            self.fgcolor = "white"
        elif (param1 == 40):
            self.bgcolor = "black"
        elif (param1 == 41):
            self.bgcolor = "red"
        elif (param1 == 42):
            self.bgcolor = "green"
        elif (param1 == 43):
            self.bgcolor = "yellow"
        elif (param1 == 44):
            self.bgcolor = "blue"
        elif (param1 == 45):
            self.bgcolor = "magenta"
        elif (param1 == 46):
            self.bgcolor = "cyan"
        elif (param1 == 47):
            self.bgcolor = "white"
        else:
            pass

    def toCSS(self,renderMethod):
        if self.isActive():
            sb = hx_strings_StringBuilder()
            if (renderMethod is None):
                renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
            tmp = renderMethod.index
            if (tmp == 0):
                if (self.fgcolor is not None):
                    sb.sb.b.write("color:")
                    sb.len = (sb.len + len("color:"))
                    _this = sb
                    item = self.fgcolor
                    _this1 = _this.sb
                    s = Std.string(item)
                    _this1.b.write(s)
                    _this.len = (_this.len + (0 if ((item is None)) else len(item)))
                    _this2 = _this
                    _this2.sb.b.write(";")
                    _this2.len = (_this2.len + len(";"))
                if (self.bgcolor is not None):
                    sb.sb.b.write("background-color:")
                    sb.len = (sb.len + len("background-color:"))
                    _this3 = sb
                    item1 = self.bgcolor
                    _this4 = _this3.sb
                    s1 = Std.string(item1)
                    _this4.b.write(s1)
                    _this3.len = (_this3.len + (0 if ((item1 is None)) else len(item1)))
                    _this5 = _this3
                    _this5.sb.b.write(";")
                    _this5.len = (_this5.len + len(";"))
                if self.bold:
                    sb.sb.b.write("font-weight:bold;")
                    sb.len = (sb.len + len("font-weight:bold;"))
                if self.underline:
                    sb.sb.b.write("text-decoration:underline;")
                    sb.len = (sb.len + len("text-decoration:underline;"))
                if self.blink:
                    sb.sb.b.write("text-decoration:blink;")
                    sb.len = (sb.len + len("text-decoration:blink;"))
            elif (tmp == 1):
                item2 = hx_strings_AnsiState.defaultCssClassesCallback(self)
                _this6 = sb.sb
                s2 = Std.string(item2)
                _this6.b.write(s2)
                sb.len = (sb.len + (0 if ((item2 is None)) else len(item2)))
            elif (tmp == 2):
                func = renderMethod.params[0]
                item3 = func(self)
                _this7 = sb.sb
                s3 = Std.string(item3)
                _this7.b.write(s3)
                sb.len = (sb.len + (0 if ((item3 is None)) else len(item3)))
            else:
                pass
            return sb.toString()
        return ""

    @staticmethod
    def defaultCssClassesCallback(state):
        classes = []
        if (state.fgcolor is not None):
            x = ("ansi_fg_" + HxOverrides.stringOrNull(state.fgcolor))
            classes.append(x)
        if (state.bgcolor is not None):
            x1 = ("ansi_bg_" + HxOverrides.stringOrNull(state.bgcolor))
            classes.append(x1)
        if state.bold:
            classes.append("ansi_bold")
        if state.underline:
            classes.append("ansi_underline")
        if state.blink:
            classes.append("ansi_blink")
        return " ".join([python_Boot.toString1(x1,'') for x1 in classes])

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bgcolor = None
        _hx_o.blink = None
        _hx_o.bold = None
        _hx_o.fgcolor = None
        _hx_o.underline = None


class hx_strings_ansi_Ansi:
    _hx_class_name = "hx.strings.ansi.Ansi"
    __slots__ = ()
    _hx_statics = ["ESC", "attr", "bg", "cursor", "clearScreen", "clearLine", "fg", "writer"]

    @staticmethod
    def attr(attr):
        return (("\x1B[" + Std.string(attr)) + "m")

    @staticmethod
    def bg(color):
        return ((("\x1B[" + "4") + Std.string(color)) + "m")

    @staticmethod
    def cursor(cmd):
        tmp = cmd.index
        if (tmp == 0):
            return ("\x1B[" + "H")
        elif (tmp == 1):
            column = cmd.params[1]
            line = cmd.params[0]
            return (((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H")
        elif (tmp == 2):
            lines = cmd.params[0]
            return (("\x1B[" + Std.string(lines)) + "A")
        elif (tmp == 3):
            lines1 = cmd.params[0]
            return (("\x1B[" + Std.string(lines1)) + "B")
        elif (tmp == 4):
            columns = cmd.params[0]
            return (("\x1B[" + Std.string(columns)) + "C")
        elif (tmp == 5):
            columns1 = cmd.params[0]
            return (("\x1B[" + Std.string(columns1)) + "D")
        elif (tmp == 6):
            return ("\x1B[" + "s")
        elif (tmp == 7):
            return ("\x1B[" + "s")
        else:
            pass

    @staticmethod
    def clearScreen():
        return ("\x1B[" + "2J")

    @staticmethod
    def clearLine():
        return ("\x1B[" + "K")

    @staticmethod
    def fg(color):
        return ((("\x1B[" + "3") + Std.string(color)) + "m")

    @staticmethod
    def writer(out):
        return hx_strings_ansi_AnsiWriter(out)

class hx_strings_ansi_AnsiCursor(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.ansi.AnsiCursor"
    _hx_constructs = ["GoToHome", "GoToPos", "MoveUp", "MoveDown", "MoveRight", "MoveLeft", "SavePos", "RestorePos"]

    @staticmethod
    def GoToPos(line,column):
        return hx_strings_ansi_AnsiCursor("GoToPos", 1, [line,column])

    @staticmethod
    def MoveUp(lines):
        return hx_strings_ansi_AnsiCursor("MoveUp", 2, [lines])

    @staticmethod
    def MoveDown(lines):
        return hx_strings_ansi_AnsiCursor("MoveDown", 3, [lines])

    @staticmethod
    def MoveRight(columns):
        return hx_strings_ansi_AnsiCursor("MoveRight", 4, [columns])

    @staticmethod
    def MoveLeft(columns):
        return hx_strings_ansi_AnsiCursor("MoveLeft", 5, [columns])
hx_strings_ansi_AnsiCursor.GoToHome = hx_strings_ansi_AnsiCursor("GoToHome", 0, list())
hx_strings_ansi_AnsiCursor.SavePos = hx_strings_ansi_AnsiCursor("SavePos", 6, list())
hx_strings_ansi_AnsiCursor.RestorePos = hx_strings_ansi_AnsiCursor("RestorePos", 7, list())


class hx_strings_ansi__AnsiWriter_StringBuf_StringBuilder_or_Output_Impl_:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBuf_StringBuilder_or_Output_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "fromStringBuilder", "fromStringBuf", "fromOutput"]

    @staticmethod
    def _new(writer):
        this1 = writer
        return this1

    @staticmethod
    def fromStringBuilder(out):
        this1 = hx_strings_ansi__AnsiWriter_StringBuilderStringWriter(out)
        return this1

    @staticmethod
    def fromStringBuf(out):
        this1 = hx_strings_ansi__AnsiWriter_StringBufStringWriter(out)
        return this1

    @staticmethod
    def fromOutput(out):
        this1 = hx_strings_ansi__AnsiWriter_OutputStringWriter(out)
        return this1


class hx_strings_ansi__AnsiWriter_StringBufStringWriter(hx_strings_ansi__AnsiWriter_AbstractStringWriter):
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBufStringWriter"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_ansi__AnsiWriter_AbstractStringWriter


    def __init__(self,out):
        self.out = out

    def write(self,_hx_str):
        _this = self.out
        s = Std.string(_hx_str)
        _this.b.write(s)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class hx_strings_ansi__AnsiWriter_StringBuilderStringWriter(hx_strings_ansi__AnsiWriter_AbstractStringWriter):
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBuilderStringWriter"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["write"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_ansi__AnsiWriter_AbstractStringWriter


    def __init__(self,out):
        self.out = out

    def write(self,_hx_str):
        _this = self.out
        _this1 = _this.sb
        s = Std.string(_hx_str)
        _this1.b.write(s)
        _this.len = (_this.len + (0 if ((_hx_str is None)) else len(_hx_str)))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class hx_strings_internal_Bits:
    _hx_class_name = "hx.strings.internal.Bits"
    __slots__ = ()
    _hx_statics = ["clearBit", "setBit", "toggleBit", "getBit"]

    @staticmethod
    def clearBit(num,bitPos):
        return (num & ~((1 << ((bitPos - 1)))))

    @staticmethod
    def setBit(num,bitPos):
        return (num | ((1 << ((bitPos - 1)))))

    @staticmethod
    def toggleBit(num,bitPos):
        return (num ^ ((1 << ((bitPos - 1)))))

    @staticmethod
    def getBit(num,bitPos):
        return (1 == (((num >> ((bitPos - 1))) & 1)))


class hx_strings_internal__Either2_Either2_Impl_:
    _hx_class_name = "hx.strings.internal._Either2.Either2_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB"]
    value = None

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        this1 = hx_strings_internal__Either2__Either2.a(value)
        return this1

    @staticmethod
    def fromB(value):
        this1 = hx_strings_internal__Either2__Either2.b(value)
        return this1

class hx_strings_internal__Either2__Either2(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either2._Either2"
    _hx_constructs = ["a", "b"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either2__Either2("a", 0, [v])

    @staticmethod
    def b(v):
        return hx_strings_internal__Either2__Either2("b", 1, [v])


class hx_strings_internal__Either3_Either3_Impl_:
    _hx_class_name = "hx.strings.internal._Either3.Either3_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB", "fromC"]
    value = None

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        this1 = hx_strings_internal__Either3__Either3.a(value)
        return this1

    @staticmethod
    def fromB(value):
        this1 = hx_strings_internal__Either3__Either3.b(value)
        return this1

    @staticmethod
    def fromC(value):
        this1 = hx_strings_internal__Either3__Either3.c(value)
        return this1


class hx_strings_internal__OneOrMany_OneOrMany_Impl_:
    _hx_class_name = "hx.strings.internal._OneOrMany.OneOrMany_Impl_"
    __slots__ = ()
    _hx_statics = ["fromSingle"]

    @staticmethod
    def fromSingle(value):
        return [value]


class hx_strings_internal__RingBuffer_RingBuffer_Impl_:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBuffer_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get"]

    @staticmethod
    def _new(size):
        this1 = hx_strings_internal__RingBuffer_RingBufferImpl(size)
        return this1

    @staticmethod
    def get(this1,index):
        return this1.get(index)


class hx_strings_internal__RingBuffer_RingBufferIterator:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferIterator"
    __slots__ = ("buff", "idx")
    _hx_fields = ["buff", "idx"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,buff):
        self.idx = -1
        self.buff = buff

    def hasNext(self):
        return ((self.idx + 1) < self.buff.length)

    def next(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.idx
        _hx_local_0.idx = (_hx_local_1 + 1)
        _hx_local_1
        return self.buff.get(self.idx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buff = None
        _hx_o.idx = None


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["printString"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift", "modf", "mod"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        return float('nan') if (b == 0.0) else a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mod(a,b):
        return a % b if a >= 0 else -(-a % b)


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["read", "write"]

    @staticmethod
    def read(path,binary = True):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def write(path,binary = True):
        if (binary is None):
            binary = True
        mode = ("wb" if binary else "w")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

Main.text_line = 0
forGL_ForGL_ui.system_name = ""
forGL_ForGL_ui.error_count_ui = 0
forGL_ForGL_ui.error_msgs_ui = ""
forGL_ForGL_ui.warning_count_ui = 0
forGL_ForGL_ui.warning_msgs_ui = ""
forGL_ForGL_ui.out_buffers = list()
forGL_ForGL_ui.COMMENT_COLOR = 3
forGL_ForGL_ui.DATA_COLOR = 1
forGL_ForGL_ui.NOUN_COLOR = 6
forGL_ForGL_ui.OP_COLOR = 2
forGL_ForGL_ui.VERB_COLOR = 4
forGL_ForGL_ui.VERB_BI_COLOR = 5
forGL_ForGL_ui.DEFAULT_COLOR = 7
forGL_ForGL_ui.current_line = 0
forGL_ForGL_ui.current_column = 0
forGL_ForGL_ui.blanks78 = "                                                                              "
forGL_ForGL_ui.stdin = Sys.stdin()
forGL_ForGL_ui.stdout = Sys.stdout()
def _hx_init_forGL_ForGL_ui_writer():
    def _hx_local_0():
        this1 = hx_strings_ansi__AnsiWriter_OutputStringWriter(forGL_ForGL_ui.stdout)
        return hx_strings_ansi_AnsiWriter(this1)
    return _hx_local_0()
forGL_ForGL_ui.writer = _hx_init_forGL_ForGL_ui_writer()
forGL_ForGL_ui.msg_call_count = 0
forGL_ForGL_ui.status_msgs = ""
forGL_ForGL_ui.enterYourVerb_return = 0
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER = hx_strings__Char_CharCaseMapper()
hx_strings__Char_Char_Impl_.BACKSPACE = 8
hx_strings__Char_Char_Impl_.TAB = 9
hx_strings__Char_Char_Impl_.LF = 10
hx_strings__Char_Char_Impl_.CR = 13
hx_strings__Char_Char_Impl_.ESC = 27
hx_strings__Char_Char_Impl_.SPACE = 32
hx_strings__Char_Char_Impl_.EXCLAMATION_MARK = 33
hx_strings__Char_Char_Impl_.DOUBLE_QUOTE = 34
hx_strings__Char_Char_Impl_.HASH = 35
hx_strings__Char_Char_Impl_.DOLLAR = 36
hx_strings__Char_Char_Impl_.AMPERSAND = 38
hx_strings__Char_Char_Impl_.SINGLE_QUOTE = 39
hx_strings__Char_Char_Impl_.BRACKET_ROUND_LEFT = 40
hx_strings__Char_Char_Impl_.BRACKET_ROUND_RIGHT = 41
hx_strings__Char_Char_Impl_.ASTERISK = 42
hx_strings__Char_Char_Impl_.PLUS = 43
hx_strings__Char_Char_Impl_.COMMA = 44
hx_strings__Char_Char_Impl_.MINUS = 45
hx_strings__Char_Char_Impl_.DOT = 46
hx_strings__Char_Char_Impl_.SLASH = 47
hx_strings__Char_Char_Impl_.ZERO = 48
hx_strings__Char_Char_Impl_.ONE = 49
hx_strings__Char_Char_Impl_.TWO = 50
hx_strings__Char_Char_Impl_.TRHEE = 51
hx_strings__Char_Char_Impl_.FOUR = 52
hx_strings__Char_Char_Impl_.FIVE = 53
hx_strings__Char_Char_Impl_.SIX = 54
hx_strings__Char_Char_Impl_.SEVEN = 55
hx_strings__Char_Char_Impl_.EIGHT = 56
hx_strings__Char_Char_Impl_.NINE = 57
hx_strings__Char_Char_Impl_.COLON = 58
hx_strings__Char_Char_Impl_.SEMICOLON = 59
hx_strings__Char_Char_Impl_.LOWER_THAN = 60
hx_strings__Char_Char_Impl_.EQUALS = 61
hx_strings__Char_Char_Impl_.GREATER_THAN = 62
hx_strings__Char_Char_Impl_.QUESTION_MARK = 63
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_LEFT = 91
hx_strings__Char_Char_Impl_.BACKSLASH = 92
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_RIGHT = 93
hx_strings__Char_Char_Impl_.CARET = 94
hx_strings__Char_Char_Impl_.UNDERSCORE = 95
hx_strings__Char_Char_Impl_.BRACKET_CURLY_LEFT = 123
hx_strings__Char_Char_Impl_.PIPE = 124
hx_strings__Char_Char_Impl_.BRACKET_CURLY_RIGHT = 125
hx_strings__CharIterator_NullCharIterator.INSTANCE = hx_strings__CharIterator_NullCharIterator()
hx_strings_Pattern.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'immutable': None, 'threadSafe': None})})
hx_strings_Matcher.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'notThreadSafe': None})})
def _hx_init_hx_strings_internal_OS_isWindows():
    def _hx_local_0():
        os = Sys.systemName()
        _this = EReg("win","i")
        _this.matchObj = python_lib_Re.search(_this.pattern,os)
        return (_this.matchObj is not None)
    return _hx_local_0()
hx_strings_internal_OS.isWindows = _hx_init_hx_strings_internal_OS_isWindows()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
def _hx_init_hx_strings_Strings_REGEX_ANSI_ESC():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile((HxOverrides.stringOrNull("".join(map(chr,[27]))) + "\\[[;\\d]*m"),this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_ANSI_ESC = _hx_init_hx_strings_Strings_REGEX_ANSI_ESC()
def _hx_init_hx_strings_Strings_REGEX_HTML_UNESCAPE():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("&(#\\d+|amp|nbsp|apos|lt|gt|quot);",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_HTML_UNESCAPE = _hx_init_hx_strings_Strings_REGEX_HTML_UNESCAPE()
def _hx_init_hx_strings_Strings_REGEX_SPLIT_LINES():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("\\r?\\n",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_SPLIT_LINES = _hx_init_hx_strings_Strings_REGEX_SPLIT_LINES()
def _hx_init_hx_strings_Strings_REGEX_REMOVE_XML_TAGS():
    def _hx_local_0():
        this1 = hx_strings_internal__Either3__Either3.b("g")
        return hx_strings_Pattern.compile("<[!a-zA-Z\\/][^>]*>",this1)
    return _hx_local_0()
hx_strings_Strings.REGEX_REMOVE_XML_TAGS = _hx_init_hx_strings_Strings_REGEX_REMOVE_XML_TAGS()
hx_strings_Strings.POS_NOT_FOUND = -1
hx_strings_Strings.NEW_LINE_NIX = "\n"
hx_strings_Strings.NEW_LINE_WIN = "\r\n"
hx_strings_Strings.NEW_LINE = ("\r\n" if (hx_strings_internal_OS.isWindows) else "\n")
hx_strings_ansi_Ansi.ESC = "\x1B["

Main.main()
