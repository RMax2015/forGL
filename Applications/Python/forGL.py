# Generated by Haxe 4.3.2
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import re as python_lib_Re
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import os as python_lib_Os
import random as python_lib_Random
try:
    import termios as python_lib_Termios
except:
    pass
import time as python_lib_Time
import traceback as python_lib_Traceback
try:
    import tty as python_lib_Tty
except:
    pass
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None

class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "split", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x = HxString.substr(s,lastEnd,None)
            ret.append(x)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]

    def replace(self,s,by):
        _this = by.split("$$")
        by = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this])
            _this = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None


class Main:
    _hx_class_name = "Main"
    __slots__ = ()
    _hx_statics = ["forGLRun", "text_line", "main", "initRunForGL"]
    forGLRun = None

    @staticmethod
    def main():
        start_dir = ""
        forGL_ForGL_ui.system_name = "Unknown_system_name"
        forGL_ForGL_ui.system_name = Sys.systemName()
        start_dir = Sys.getCwd()
        stdout = Sys.stdout()
        writer = hx_strings_ansi_AnsiWriter(hx_strings_ansi__AnsiWriter_OutputStringWriter(stdout))
        try:
            tmp = ("Windows" == forGL_ForGL_ui.system_name)
            writer._out.write(((("\x1B[" + "3") + Std.string(2)) + "m"))
            _this = writer
            _this._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
            _this1 = _this
            _this1._out.write((("\x1B[" + Std.string(1)) + "m"))
            _this = _this1
            _this._out.write(("\x1B[" + "2J"))
            _this1 = _this
            _this1._out.flush()
            version = "forGL v0.0.3 Prototype in "
            forGL_ForGL_ui.msg(version)
            forGL_ForGL_ui.msg("Python\n")
            Main.text_line = 2
            Main.initRunForGL()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nException in main(): " + Std.string(e)) + " \n"))
        Sys.setCwd(start_dir)
        writer._out.write(((("\x1B[" + "3") + Std.string(6)) + "m"))
        _this = writer
        _this._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
        _this1 = _this
        _this1._out.write((("\x1B[" + Std.string(1)) + "m"))
        _this = _this1
        _this._out.flush()

    @staticmethod
    def initRunForGL():
        ret_val = 0
        init_lines = 0
        Main.forGLRun = forGL_ForGL_Run()
        init_result = 0
        err_str = ""
        debug_path_file = "C:/Randy/Programming/Haxe/Projects/AST_4GL_Proto/forGL_Dictionary_Prototype.toml"
        init_result = Main.forGLRun.init(debug_path_file,init_lines)
        def _hx_local_1():
            _hx_local_0 = init_result
            if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        _hx_local_2 = Main
        _hx_local_3 = _hx_local_2.text_line
        _hx_local_2.text_line = (_hx_local_3 + Math.floor(Reflect.field(Math,"fabs")(_hx_local_1())))
        _hx_local_2.text_line
        _hx_local_4 = Main
        _hx_local_5 = _hx_local_4.text_line
        _hx_local_4.text_line = (_hx_local_5 + 1)
        _hx_local_5
        def _hx_local_7():
            _hx_local_6 = init_result
            if (Std.isOfType(_hx_local_6,Int) or ((_hx_local_6 is None))):
                _hx_local_6
            else:
                raise "Class cast error"
            return _hx_local_6
        if (_hx_local_7() < 0):
            forGL_ForGL_ui.error(((("\n    SEVERE ERROR  " + Std.string(forGL_MeansWhat.returnMeanAsStr(init_result))) + ("null" if err_str is None else err_str)) + " trying to Initialize the Runtime service.  Stopping."))
            return init_result
        _hx_local_8 = Main
        _hx_local_9 = _hx_local_8.text_line
        _hx_local_8.text_line = (_hx_local_9 + 1)
        _hx_local_9
        _hx_local_10 = Main
        _hx_local_11 = _hx_local_10.text_line
        _hx_local_10.text_line = (_hx_local_11 + 1)
        _hx_local_11
        Main.forGLRun.run_text_line = Main.text_line
        Main.forGLRun.run()
        if (0 < len(Main.forGLRun.export_as_code_log)):
            export_file = "./forGL_Export_Log.txt"
            file = sys_io_File.append(export_file,False)
            temp = ""
            i = 0
            while (i < len(Main.forGLRun.export_as_code_log)):
                temp = ""
                temp = forGL_NLTypeAs.nlTypeAsStr(python_internal_ArrayImpl._get(Main.forGLRun.export_as_code_log, i).token_type)
                file.writeString((("null" if temp is None else temp) + " "))
                temp = python_internal_ArrayImpl._get(Main.forGLRun.export_as_code_log, i).token_name
                file.writeString((("null" if temp is None else temp) + "\r\n"))
                i = (i + 1)
            file.close()
        Main.forGLRun.cleanUp()
        return ret_val


class TestUI:
    _hx_class_name = "TestUI"
    __slots__ = ()
    _hx_statics = ["simple"]

    @staticmethod
    def simple():
        haxe_Log.trace("Hello ",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 782, 'className': "TestUI", 'methodName': "simple"}))
        forGL_ForGL_ui.msg("forGL ?\n")
        f = 0.0
        txt = "\n"
        while (f < 2.0):
            txt = (Std.string(f) + "\n")
            forGL_ForGL_ui.msg(txt)
            f = (f + 1)
        _hx_str = "Veränderung"
        forGL_ForGL_ui.msg((Std.string(_hx_str) + "\n"))
        str_len = (0 if ((_hx_str is None)) else len(_hx_str))
        haxe_Log.trace(str_len,None)
        if (str_len != 11):
            forGL_ForGL_ui.msg(" WRONG string length")
        forGL_ForGL_ui.msg("\n")
        str2 = "はいはい"
        forGL_ForGL_ui.msg((("\n" + Std.string(str2)) + "\n"))
        str2_len = (0 if ((str2 is None)) else len(str2))
        haxe_Log.trace(str2_len,None)
        if (str2_len != 4):
            forGL_ForGL_ui.msg(" WRONG string length")
        forGL_ForGL_ui.msg("\n")
        stdout = Sys.stdout()
        stdout.writeString(((("\x1B[" + "3") + Std.string(1)) + "m"))
        stdout.writeString(((("\x1B[" + "4") + Std.string(7)) + "m"))
        stdout.writeString((("\x1B[" + Std.string(1)) + "m"))
        stdout.writeString((("\x1B[" + Std.string(0)) + "m"))
        stdout.writeString(hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.MoveUp(2)))
        writer = hx_strings_ansi_AnsiWriter(hx_strings_ansi__AnsiWriter_OutputStringWriter(stdout))
        _hx_str = hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.GoToPos(20,10))
        writer._out.write(_hx_str)
        _this = writer
        _this._out.write(((("\x1B[" + "3") + Std.string(2)) + "m"))
        _this1 = _this
        _this1._out.write(((("\x1B[" + "4") + Std.string(0)) + "m"))
        _this = _this1
        _this._out.write((("\x1B[" + Std.string(3)) + "m"))
        _this1 = _this
        _this1._out.write("How are you?")
        _this = _this1
        _this._out.write((("\x1B[" + Std.string(0)) + "m"))
        _this1 = _this
        _hx_str = hx_strings_ansi_Ansi.cursor(hx_strings_ansi_AnsiCursor.MoveDown(2))
        _this1._out.write(_hx_str)
        _this = _this1
        _this._out.write(((("\x1B[" + "3") + Std.string(1)) + "m"))
        _this1 = _this
        _this1._out.write(((("\x1B[" + "4") + Std.string(7)) + "m"))
        _this = _this1
        _this._out.write((("\x1B[" + Std.string(4)) + "m"))
        _this1 = _this
        _this1._out.write("Hello World! (in color?)")
        _this = _this1
        _this._out.write((("\x1B[" + Std.string(24)) + "m"))
        _this1 = _this
        _this1._out.flush()


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        _hx_len = len(x)
        index = 0
        while (index < _hx_len):
            if (not (x[index] in " \n\r\t\x0B\x0C")):
                break
            index = (index + 1)
        isNegative = None
        if (index < _hx_len):
            sign = x[index]
            if ((sign == "-") or ((sign == "+"))):
                index = (index + 1)
            isNegative = (sign == "-")
        else:
            isNegative = False
        isHexadecimal = None
        if ((index + 1) < _hx_len):
            cur = x[index]
            next = x[(index + 1)]
            isHexadecimal = ((cur == "0") and (((next == "x") or ((next == "X")))))
        else:
            isHexadecimal = False
        if isHexadecimal:
            index = (index + 2)
        cur = index
        if isHexadecimal:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789abcdefABCDEF")):
                    break
                cur = (cur + 1)
        else:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789")):
                    break
                cur = (cur + 1)
        firstInvalidIndex = cur
        if (index == firstInvalidIndex):
            return None
        result = int(HxString.substring(x,index,firstInvalidIndex),(16 if isHexadecimal else 10))
        if isNegative:
            return -result
        else:
            return result

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except BaseException as _g:
            None
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim", "replace", "hex"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def replace(s,sub,by):
        _this = (list(s) if ((sub == "")) else s.split(sub))
        return by.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "rename", "isDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def rename(path,newPath):
        python_lib_Os.rename(path,newPath)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["sleep", "getCwd", "setCwd", "systemName", "getChar", "stdin", "stdout"]

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def getCwd():
        return haxe_io_Path.addTrailingSlash(python_lib_Os.getcwd())

    @staticmethod
    def setCwd(s):
        python_lib_Os.chdir(s)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except BaseException as _g1:
                    None
                    e = haxe_Exception.caught(_g1).unwrap()
                    restore()
                    raise haxe_Exception.thrown(e)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getwch(),0)
            else:
                x = _g
                raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        else:
            x = _g
            raise haxe_Exception.thrown((("platform " + ("null" if x is None else x)) + " not supported"))
        if echo:
            python_Lib.printString(Std.string("".join(map(chr,[ch]))))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

    @staticmethod
    def stdout():
        return python_io_IoTools.createFileOutputFromText(python_lib_Sys.stdout)


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getSuperClass", "createEmptyInstance"]

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl):
            sc = Type.getSuperClass(cl)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl,"_hx_empty_init"):
                cl._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i


class forGL_Comments:
    _hx_class_name = "forGL.Comments"
    __slots__ = ()
    _hx_statics = ["extract", "extractNoPadding"]

    @staticmethod
    def extract(e):
        _g = e.expr
        if (_g.index == 0):
            _g1 = _g.params[0]
            if (_g1.index == 2):
                _g = _g1.params[1]
                v = _g1.params[0]
                temp = v
                if (len(temp) < 80):
                    str80 = "                                                                                "
                    temp = (("null" if temp is None else temp) + HxOverrides.stringOrNull(HxString.substr(str80,0,(len(str80) - len(temp)))))
                return temp
            else:
                return "not a proper Comment"
        else:
            return "not a proper Comment"

    @staticmethod
    def extractNoPadding(e):
        _g = e.expr
        if (_g.index == 0):
            _g1 = _g.params[0]
            if (_g1.index == 2):
                _g = _g1.params[1]
                v = _g1.params[0]
                temp = v
                return temp
            else:
                return "not a proper Comment 2"
        else:
            return "not a proper Comment 2"


class forGL_NLDictionary:
    _hx_class_name = "forGL.NLDictionary"
    __slots__ = ("path_dictionary_file", "use_Built_In_Dictionary", "unique_Dictionary_Words", "words_added_by_init", "addWord_msg")
    _hx_fields = ["path_dictionary_file", "use_Built_In_Dictionary", "unique_Dictionary_Words", "words_added_by_init", "addWord_msg"]
    _hx_methods = ["init", "showDictionaryWords", "findWord", "levenshteinDistance", "findCommonPrefix", "findCommonSuffix", "findSimilar", "addWord", "sortDictionary", "getCustomWords", "cleanUp"]

    def __init__(self):
        self.addWord_msg = ""
        self.words_added_by_init = 0
        self.unique_Dictionary_Words = list()
        self.use_Built_In_Dictionary = False
        self.path_dictionary_file = ""

    def init(self,path_dict_file):
        result = 0
        self.path_dictionary_file = path_dict_file
        self.use_Built_In_Dictionary = False
        i = 1
        def _hx_local_1():
            _hx_local_0 = 65
            if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        limit = _hx_local_1()
        name_internal = ""
        op_means = 0
        add_result = 0
        while (i <= limit):
            def _hx_local_3():
                _hx_local_2 = i
                if (Std.isOfType(_hx_local_2,Int) or ((_hx_local_2 is None))):
                    _hx_local_2
                else:
                    raise "Class cast error"
                return _hx_local_2
            op_means = _hx_local_3()
            name_internal = forGL_MeansWhat.opMeanAsStr(op_means,True)
            if (0 < ((0 if ((name_internal is None)) else len(name_internal)))):
                add_result = self.addWord(name_internal,2,name_internal,op_means)
            i = (i + 1)
        self.addWord("into",2,"=:",33)
        self.addWord("from",2,":=",34)
        add_result = self.addWord("if",13,"if")
        add_result = self.addWord("else",13,"else")
        add_result = self.addWord("while",13,"while")
        add_result = self.addWord("for",13,"for")
        add_result = self.addWord("switch",13,"switch")
        add_result = self.addWord("case",13,"case")
        add_result = self.addWord("default",13,"default")
        add_result = self.addWord("break",13,"break")
        add_result = self.addWord("continue",13,"continue")
        add_result = self.addWord("return",13,"return")
        add_result = self.addWord("repeat",3,"repeat")
        add_result = self.addWord("show",3,"show")
        add_result = self.addWord("view",3,"view")
        self.words_added_by_init = self.sortDictionary()
        return result

    def showDictionaryWords(self,skip_operators = None,wait = None):
        if (skip_operators is None):
            skip_operators = True
        if (wait is None):
            wait = True
        lines_added = 1
        if (0 == len(self.unique_Dictionary_Words)):
            return 0
        forGL_ForGL_ui.msg("    Show Dictionary (y/n) ? ",2,False)
        char_code = Sys.getChar(True)
        forGL_ForGL_ui.msg("\n")
        forGL_ForGL_ui.eraseToLineEnd(0)
        if ((89 != char_code) and ((121 != char_code))):
            return 1
        message = ((" has " + Std.string(len(self.unique_Dictionary_Words))) + " Words")
        if (self.words_added_by_init == len(self.unique_Dictionary_Words)):
            message = ("Dictionary (built in)" + ("null" if message is None else message))
        else:
            message = (HxOverrides.stringOrNull(self.path_dictionary_file) + ("null" if message is None else message))
        if skip_operators:
            message = (("null" if message is None else message) + ", skipping Operators")
        message = (("null" if message is None else message) + "\n")
        lines_added = (lines_added + 1)
        message = (("null" if message is None else message) + "Visible ------- Internal ------ Meaning ---------------\n")
        lines_added = (lines_added + 1)
        forGL_ForGL_ui.msg(message,2)
        color = 7
        word_type = 0
        visible_word = ""
        internal_word = ""
        string_data = ""
        j = 0
        while (j < len(self.unique_Dictionary_Words)):
            if (skip_operators and ((2 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_type))):
                j = (j + 1)
                continue
            word_type = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_type
            visible_word = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).visible_token
            internal_word = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).internal_token
            color = forGL_ForGL_ui.getTypeColor(word_type)
            if (6 == word_type):
                color = 1
            if (7 < ((0 if ((visible_word is None)) else len(visible_word)))):
                forGL_ForGL_ui.msg((Std.string(visible_word) + "\t"),color)
            else:
                forGL_ForGL_ui.msg((Std.string(visible_word) + "\t\t"),color)
            if (7 < ((0 if ((internal_word is None)) else len(internal_word)))):
                forGL_ForGL_ui.msg((Std.string(internal_word) + "\t"),color)
            else:
                forGL_ForGL_ui.msg((Std.string(internal_word) + "\t\t"),color)
            if (2 == word_type):
                forGL_ForGL_ui.msg((Std.string(forGL_MeansWhat.opMeanAsStr((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_op_means)) + "\n"),color)
            else:
                forGL_ForGL_ui.msg((HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type)) + "\t"),color)
                string_data = (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_str
                if (6 == word_type):
                    if (8 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string(string_data) + "\n"),color)
                    elif (10 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        if (1 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_int):
                            forGL_ForGL_ui.msg("true\n",color)
                        else:
                            forGL_ForGL_ui.msg("false\n",color)
                    elif (9 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_int) + "\n"),color)
                    elif (11 == (self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_noun_data):
                        forGL_ForGL_ui.msg((Std.string((self.unique_Dictionary_Words[j] if j >= 0 and j < len(self.unique_Dictionary_Words) else None).token_float) + "\n"),color)
                elif (4 == word_type):
                    nl_Parse = forGL_Parse()
                    show_dict_tokens = nl_Parse.parse(string_data,forGL_ParseStyle.PARSE_LEFT_TO_RIGHT,False)
                    if (0 == len(show_dict_tokens)):
                        forGL_ForGL_ui.msg((Std.string(string_data) + "\n"),color)
                    else:
                        verb_tokens = list()
                        text_line_count = nl_Parse.resolveTokens(show_dict_tokens,self,verb_tokens,False)
                        token_color = 7
                        k = 0
                        while (k < len(verb_tokens)):
                            verb_token_visible_word = (verb_tokens[k] if k >= 0 and k < len(verb_tokens) else None).visible_token
                            idx = self.findWord(verb_token_visible_word)
                            if (idx < 0):
                                token_color = forGL_ForGL_ui.getTypeColor(7)
                            else:
                                verb_token_type = (self.unique_Dictionary_Words[idx] if idx >= 0 and idx < len(self.unique_Dictionary_Words) else None).token_type
                                verb_token_visible_word = (self.unique_Dictionary_Words[idx] if idx >= 0 and idx < len(self.unique_Dictionary_Words) else None).visible_token
                                verb_token_internal_word = (self.unique_Dictionary_Words[idx] if idx >= 0 and idx < len(self.unique_Dictionary_Words) else None).internal_token
                                if (6 == verb_token_type):
                                    token_color = 1
                                else:
                                    token_color = forGL_ForGL_ui.getTypeColor(verb_token_type)
                            forGL_ForGL_ui.msg((Std.string(verb_token_visible_word) + " "),token_color)
                            k = (k + 1)
                        forGL_ForGL_ui.msg("\n")
                elif (3 == word_type):
                    forGL_ForGL_ui.msg("\n")
                elif (13 == word_type):
                    forGL_ForGL_ui.msg("\n")
            lines_added = (lines_added + 1)
            j = (j + 1)
        if wait:
            forGL_ForGL_ui.msg("    Hit a key when ready.\r",2,False)
            char_code = Sys.getChar(False)
            forGL_ForGL_ui.eraseToLineEnd(0)
        return lines_added

    def inspectRuntime(self, variable_name=None):
        if variable_name:
            # Inspect a specific variable
            value = self.runtime_context.get(variable_name, None)
            if value is not None:
                print(f"{variable_name} ({type(value).__name__}): {value}")
            else:
                print(f"Variable '{variable_name}' not found.")
        else:
            # Inspect all variables
            print("Current Runtime Variables:")
            for name, value in self.runtime_context.items():
                print(f"  {name} ({type(value).__name__}): {value}")

    """
    builds a dictionary (word_index) that maps each unique word's visible token (in lowercase)
    to its corresponding index in the unique_Dictionary_Words list for efficient lookups
    """
    def buildWordIndex(self):
        self.word_index = {word.visible_token.lower(): idx for idx, word in enumerate(self.unique_Dictionary_Words)}


    #use a dictionary for efficient lookups / finds the index of a given word in the word_index dictionary.
    def findWord(self, word_name):
        if not word_name:
            return -2
        if not hasattr(self, 'word_index') or not self.word_index:
            self.buildWordIndex()
        return self.word_index.get(word_name.lower(), -1)

    #Optimize for space using a single row:
    def levenshteinDistance(self, s1, s2):
        if len(s1) < len(s2):
            s1, s2 = s2, s1
        previous_row = range(len(s2) + 1)
        for i, c1 in enumerate(s1):
            current_row = [i + 1]
            for j, c2 in enumerate(s2):
                insertions = previous_row[j + 1] + 1
                deletions = current_row[j] + 1
                substitutions = previous_row[j] + (c1 != c2)
                current_row.append(min(insertions, deletions, substitutions))
            previous_row = current_row
        return previous_row[-1]
    
    def findCommonPrefix(self,_hx_str,str2):
        prefixNew = ""
        count = (0 if ((_hx_str is None)) else len(_hx_str))
        if (count > ((0 if ((str2 is None)) else len(str2)))):
            count = (0 if ((str2 is None)) else len(str2))
        i = 0
        while (i < count):
            if (hx_strings_Strings.charAt8(_hx_str,i) == hx_strings_Strings.charAt8(str2,i)):
                prefixNew = hx_strings_Strings.insertAt(prefixNew,(0 if ((prefixNew is None)) else len(prefixNew)),Std.string(hx_strings_Strings.charAt8(_hx_str,i)))
            else:
                break
            i = (i + 1)
        return prefixNew

    def findCommonSuffix(self,_hx_str,str2):
        suffixNew = ""
        size = (0 if ((_hx_str is None)) else len(_hx_str))
        size2 = (0 if ((str2 is None)) else len(str2))
        count = size
        if (count > size2):
            count = size2
        if (0 == count):
            return suffixNew
        index = (size - 1)
        index2 = (size2 - 1)
        i = 0
        while (i < count):
            if (hx_strings_Strings.charAt8(_hx_str,index) == hx_strings_Strings.charAt8(str2,index2)):
                suffixNew = hx_strings_Strings.insertAt(suffixNew,0,Std.string(hx_strings_Strings.charAt8(_hx_str,index)))
                index = (index - 1)
                index2 = (index2 - 1)
            else:
                break
            i = (i + 1)
        return suffixNew

    def findSimilar(self,word_internal_name):
        if (((0 if ((word_internal_name is None)) else len(word_internal_name))) <= 1):
            return ""
        apply_cost = False
        cost = 999999999
        prev_cost = -1
        prev_similar = ""
        _hx_str = ""
        str2 = ""
        preFix = ""
        i = 0
        while (i < len(self.unique_Dictionary_Words)):
            str1 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            if (((0 if ((str1 is None)) else len(str1))) <= 1):
                i = (i + 1)
                continue
            if (word_internal_name == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token):
                return word_internal_name
            _hx_str = word_internal_name
            str2 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            if (hx_strings_Strings.charAt8(_hx_str,0) == hx_strings_Strings.charAt8(str2,0)):
                prefix = self.findCommonPrefix(_hx_str,str2)
                _hx_str = hx_strings_Strings.removeLeading(_hx_str,preFix)
                str2 = hx_strings_Strings.removeLeading(str2,preFix)
            if (((0 if ((_hx_str is None)) else len(_hx_str))) == 0):
                cost = (0 if ((str2 is None)) else len(str2))
            elif (((0 if ((str2 is None)) else len(str2))) == 0):
                cost = (0 if ((_hx_str is None)) else len(_hx_str))
            else:
                if (hx_strings_Strings.charAt8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - 1)) == hx_strings_Strings.charAt8(str2,(((0 if ((str2 is None)) else len(str2))) - 1))):
                    suffix = self.findCommonSuffix(_hx_str,str2)
                    _hx_str = hx_strings_Strings.removeTrailing(_hx_str,suffix)
                    str2 = hx_strings_Strings.removeTrailing(str2,suffix)
                if (((0 if ((_hx_str is None)) else len(_hx_str))) == 0):
                    cost = (0 if ((str2 is None)) else len(str2))
                elif (((0 if ((str2 is None)) else len(str2))) == 0):
                    cost = (0 if ((_hx_str is None)) else len(_hx_str))
                else:
                    cost = self.levenshteinDistance(_hx_str,str2)
            apply_cost = False
            if (0 <= prev_cost):
                if (cost < prev_cost):
                    apply_cost = True
            else:
                apply_cost = True
            if apply_cost:
                prev_cost = cost
                prev_similar = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token
            i = (i + 1)
        return prev_similar

    def addWord(self,word_name,word_type = None,name_internal = None,op_means = None,data_str = None,data_float = None,data_int = None,noun_data = None,replaceIdx = None):
        if (word_type is None):
            word_type = 0
        if (name_internal is None):
            name_internal = ""
        if (op_means is None):
            op_means = 0
        if (data_str is None):
            data_str = ""
        if (data_float is None):
            data_float = 0.0
        if (data_int is None):
            data_int = 0
        if (noun_data is None):
            noun_data = 0
        if (replaceIdx is None):
            replaceIdx = -1
        ret_val = 0
        self.addWord_msg = ""
        if ((((((0 == ((0 if ((word_name is None)) else len(word_name)))) or ((0 == ((0 if ((name_internal is None)) else len(name_internal)))))) or ((0 == word_type))) or (((2 == word_type) and ((0 == op_means))))) or (((6 == word_type) and ((0 == noun_data))))) or (((4 == word_type) and (("" == data_str))))):
            forGL_ForGL_ui.status("")
            self.addWord_msg = (((((("ERROR: Invalid: " + Std.string(word_name)) + " ") + Std.string(name_internal)) + " ") + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type))) + " ")
            if (2 == word_type):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.addWord_msg
                _hx_local_0.addWord_msg = (("null" if _hx_local_1 is None else _hx_local_1) + Std.string(forGL_MeansWhat.opMeanAsStr(op_means)))
                _hx_local_0.addWord_msg
            elif (6 == word_type):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.addWord_msg
                _hx_local_2.addWord_msg = (("null" if _hx_local_3 is None else _hx_local_3) + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(word_type)))
                _hx_local_2.addWord_msg
            elif (4 == word_type):
                if (0 == ((0 if ((data_str is None)) else len(data_str)))):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.addWord_msg
                    _hx_local_4.addWord_msg = (("null" if _hx_local_5 is None else _hx_local_5) + "without any Value")
                    _hx_local_4.addWord_msg
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.addWord_msg
            _hx_local_6.addWord_msg = (("null" if _hx_local_7 is None else _hx_local_7) + "\n")
            _hx_local_6.addWord_msg
            forGL_ForGL_ui.error(self.addWord_msg,1)
        name_internal = hx_strings_Strings.toLowerCase8(name_internal)
        verbose_phrase = word_name
        if (0 <= replaceIdx):
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).internal_token = name_internal
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).visible_token = word_name
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).verbose_phrase = verbose_phrase
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_str = data_str
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_float = data_float
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_type = word_type
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_noun_data = noun_data
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_int = data_int
            (self.unique_Dictionary_Words[replaceIdx] if replaceIdx >= 0 and replaceIdx < len(self.unique_Dictionary_Words) else None).token_op_means = op_means
        else:
            find_idx = self.findWord(word_name)
            if (0 <= find_idx):
                self.addWord_msg = (("ERROR: Word " + Std.string(word_name)) + " already in Dictionary")
                return -3
            _this = self.unique_Dictionary_Words
            x = forGL_NLToken(name_internal,word_name,verbose_phrase,data_str,data_float,word_type,noun_data,data_int,op_means)
            _this.append(x)
        return ret_val

    def sortDictionary(self):
        if (1 < len(self.unique_Dictionary_Words)):
            def _hx_local_0(a,b):
                return hx_strings_Strings.compareIgnoreCase(a.visible_token,b.visible_token)
            self.unique_Dictionary_Words.sort(key= python_lib_Functools.cmp_to_key(_hx_local_0))
        return len(self.unique_Dictionary_Words)

    def getCustomWords(self):
        custom_words = list()
        i = 0
        while (i < len(self.unique_Dictionary_Words)):
            if ((6 == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).token_type) or ((4 == (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).token_type))):
                x = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token
                custom_words.append(x)
            elif ((self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token != (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).internal_token):
                x1 = (self.unique_Dictionary_Words[i] if i >= 0 and i < len(self.unique_Dictionary_Words) else None).visible_token
                custom_words.append(x1)
            i = (i + 1)
        return custom_words

    def cleanUp(self):
        ret_val = 0
        self.unique_Dictionary_Words = [forGL_NLToken(".",".",".","",0.0,0,0,0,0)]
        _this = self.unique_Dictionary_Words
        if (len(_this) != 0):
            _this.pop()
        return ret_val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path_dictionary_file = None
        _hx_o.use_Built_In_Dictionary = None
        _hx_o.unique_Dictionary_Words = None
        _hx_o.words_added_by_init = None
        _hx_o.addWord_msg = None


class forGL_NLExport:
    _hx_class_name = "forGL.NLExport"
    __slots__ = ("exportWords_msgs", "exportWords_replaced", "exportWords_added")
    _hx_fields = ["exportWords_msgs", "exportWords_replaced", "exportWords_added"]
    _hx_methods = ["init", "cleanUp", "exportWords"]

    def __init__(self):
        self.exportWords_added = 0
        self.exportWords_replaced = 0
        self.exportWords_msgs = ""

    def init(self):
        pass

    def cleanUp(self):
        pass

    def exportWords(self,_hx_dict,dict_path_file,data,export_type = None):
        if (export_type is None):
            export_type = 1
        result = 0
        self.exportWords_msgs = ""
        self.exportWords_replaced = 0
        self.exportWords_added = 0
        words_replaced = list()
        words_added = list()
        imported_words = data.getListOfWords(False)
        out_words = _hx_dict.getCustomWords()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.exportWords_msgs
        _hx_local_0.exportWords_msgs = (Std.string(_hx_local_1) + ((("Information: " + Std.string(len(out_words))) + " words to Export.\n")))
        _hx_local_0.exportWords_msgs
        if (0 == len(out_words)):
            return 0
        if (0 == len(imported_words)):
            return -10
        _hx_str = _hx_dict.path_dictionary_file
        if (0 == ((0 if ((_hx_str is None)) else len(_hx_str)))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.exportWords_msgs
            _hx_local_2.exportWords_msgs = (Std.string(_hx_local_3) + "INTERNAL ERROR: Export: No physical Dictionary file available to rename.\n")
            _hx_local_2.exportWords_msgs
            return -11
        _hx_str = (("Words to Export are: " + Std.string(out_words)) + "\n")
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.exportWords_msgs
        _hx_local_4.exportWords_msgs = (Std.string(_hx_local_5) + ("null" if _hx_str is None else _hx_str))
        _hx_local_4.exportWords_msgs
        new_file_name = _hx_dict.path_dictionary_file
        extension = HxString.substr(new_file_name,(len(new_file_name) - 5),5)
        backup_name = HxString.substr(new_file_name,0,(len(new_file_name) - ((0 if ((extension is None)) else len(extension)))))
        now_date = Date.now()
        date_raw = now_date.toString()
        date_str = ""
        i = 0
        while (i < len(date_raw)):
            char = ("" if (((i < 0) or ((i >= len(date_raw))))) else date_raw[i])
            if (("-" == char) or ((":" == char))):
                date_str = (("null" if date_str is None else date_str) + "_")
            elif (" " == char):
                date_str = (("null" if date_str is None else date_str) + "__")
            else:
                date_str = (("null" if date_str is None else date_str) + ("null" if char is None else char))
            i = (i + 1)
        backup_name = (("null" if backup_name is None else backup_name) + HxOverrides.stringOrNull(((("_Backup_" + ("null" if date_str is None else date_str)) + ("null" if extension is None else extension)))))
        data.renameFile(_hx_dict.path_dictionary_file,backup_name)
        rInfo = forGL_ResolveInfo()
        dict_idx = -1
        i = 0
        while (i < len(out_words)):
            dict_idx = _hx_dict.findWord((out_words[i] if i >= 0 and i < len(out_words) else None))
            if (dict_idx < 0):
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.exportWords_msgs
                _hx_local_11.exportWords_msgs = (Std.string(_hx_local_12) + HxOverrides.stringOrNull(((("INTERNAL ERROR: findWord of " + Std.string((out_words[i] if i >= 0 and i < len(out_words) else None))) + " was not found. Skipping to next word.\n"))))
                _hx_local_11.exportWords_msgs
                i = (i + 1)
                continue
            dict_word = (_hx_dict.unique_Dictionary_Words[dict_idx] if dict_idx >= 0 and dict_idx < len(_hx_dict.unique_Dictionary_Words) else None)
            rInfo.resolve_str = dict_word.token_str
            rInfo.resolve_float = dict_word.token_float
            rInfo.resolve_int = dict_word.token_int
            rInfo.resolve_op_meaning = dict_word.token_op_means
            rInfo.resolve_token_noun_data = dict_word.token_noun_data
            rInfo.resolve_out_token = dict_word.internal_token
            replaceOrAdd_result = data.replaceOrAddWord(dict_word.visible_token,dict_word.token_type,rInfo)
            def _hx_local_15():
                _hx_local_14 = replaceOrAdd_result
                if (Std.isOfType(_hx_local_14,Int) or ((_hx_local_14 is None))):
                    _hx_local_14
                else:
                    raise "Class cast error"
                return _hx_local_14
            if (0 == _hx_local_15()):
                if data.replaceOrAddWord_replaced:
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.exportWords_replaced
                    _hx_local_16.exportWords_replaced = (_hx_local_17 + 1)
                    _hx_local_17
                    words_added.append(0)
                    words_replaced.append(1)
                else:
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.exportWords_added
                    _hx_local_18.exportWords_added = (_hx_local_19 + 1)
                    _hx_local_19
                    words_added.append(1)
                    words_replaced.append(0)
            else:
                result = replaceOrAdd_result
                words_added.append(0)
                words_replaced.append(0)
            i = (i + 1)
        save_result = data.saveToFile(_hx_dict.path_dictionary_file)
        def _hx_local_22():
            _hx_local_21 = save_result
            if (Std.isOfType(_hx_local_21,Int) or ((_hx_local_21 is None))):
                _hx_local_21
            else:
                raise "Class cast error"
            return _hx_local_21
        if (0 != _hx_local_22()):
            if (0 == result):
                result = save_result
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.exportWords_msgs = None
        _hx_o.exportWords_replaced = None
        _hx_o.exportWords_added = None


class forGL_NLExportAs:
    _hx_class_name = "forGL.NLExportAs"
    __slots__ = ("exportAsCode_msgs", "verbCount", "exportWords_replaced", "exportWords_added")
    _hx_fields = ["exportAsCode_msgs", "verbCount", "exportWords_replaced", "exportWords_added"]
    _hx_methods = ["init", "cleanUp", "exportAsCode"]

    def __init__(self):
        self.exportWords_added = 0
        self.exportWords_replaced = 0
        self.verbCount = 0
        self.exportAsCode_msgs = ""

    def init(self,expRunMsgs):
        retVal = 0
        return retVal

    def cleanUp(self):
        pass

    def exportAsCode(self,_hx_dict,dict_path_file,data,export_lang = None):
        if (export_lang is None):
            export_lang = 1
        result = 0
        self.exportAsCode_msgs = ""
        words_replaced = list()
        words_added = list()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.exportAsCode_msgs
        _hx_local_0.exportAsCode_msgs = (Std.string(_hx_local_1) + ((("Information: " + Std.string(self.verbCount)) + " Verbs to Export as .\n")))
        _hx_local_0.exportAsCode_msgs
        if (0 == self.verbCount):
            return 0
        imported_words = data.getListOfWords(False)
        if (0 == len(imported_words)):
            return -10
        _hx_str = _hx_dict.path_dictionary_file
        if (0 == ((0 if ((_hx_str is None)) else len(_hx_str)))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.exportAsCode_msgs
            _hx_local_2.exportAsCode_msgs = (Std.string(_hx_local_3) + "INTERNAL ERROR: Export: No physical Dictionary file available to rename.\n")
            _hx_local_2.exportAsCode_msgs
            return -11
        out_words = _hx_dict.getCustomWords()
        _hx_str = (("Verbs to Export as Code are: " + Std.string(out_words)) + "\n")
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.exportAsCode_msgs
        _hx_local_4.exportAsCode_msgs = (Std.string(_hx_local_5) + ("null" if _hx_str is None else _hx_str))
        _hx_local_4.exportAsCode_msgs
        new_file_name = _hx_dict.path_dictionary_file
        extension = HxString.substr(new_file_name,(len(new_file_name) - 5),5)
        backup_name = HxString.substr(new_file_name,0,(len(new_file_name) - ((0 if ((extension is None)) else len(extension)))))
        now_date = Date.now()
        date_raw = now_date.toString()
        date_str = ""
        i = 0
        while (i < len(date_raw)):
            char = ("" if (((i < 0) or ((i >= len(date_raw))))) else date_raw[i])
            if (("-" == char) or ((":" == char))):
                date_str = (("null" if date_str is None else date_str) + "_")
            elif (" " == char):
                date_str = (("null" if date_str is None else date_str) + "__")
            else:
                date_str = (("null" if date_str is None else date_str) + ("null" if char is None else char))
            i = (i + 1)
        backup_name = (("null" if backup_name is None else backup_name) + HxOverrides.stringOrNull(((("_Backup_" + ("null" if date_str is None else date_str)) + ("null" if extension is None else extension)))))
        data.renameFile(_hx_dict.path_dictionary_file,backup_name)
        rInfo = forGL_ResolveInfo()
        dict_idx = -1
        i = 0
        while (i < len(out_words)):
            dict_idx = _hx_dict.findWord((out_words[i] if i >= 0 and i < len(out_words) else None))
            if (dict_idx < 0):
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.exportAsCode_msgs
                _hx_local_11.exportAsCode_msgs = (Std.string(_hx_local_12) + HxOverrides.stringOrNull(((("INTERNAL ERROR: findWord of " + Std.string((out_words[i] if i >= 0 and i < len(out_words) else None))) + " was not found. Skipping to next word.\n"))))
                _hx_local_11.exportAsCode_msgs
                i = (i + 1)
                continue
            dict_word = (_hx_dict.unique_Dictionary_Words[dict_idx] if dict_idx >= 0 and dict_idx < len(_hx_dict.unique_Dictionary_Words) else None)
            rInfo.resolve_str = dict_word.token_str
            rInfo.resolve_float = dict_word.token_float
            rInfo.resolve_int = dict_word.token_int
            rInfo.resolve_op_meaning = dict_word.token_op_means
            rInfo.resolve_token_noun_data = dict_word.token_noun_data
            rInfo.resolve_out_token = dict_word.internal_token
            replaceOrAdd_result = data.replaceOrAddWord(dict_word.visible_token,dict_word.token_type,rInfo)
            def _hx_local_15():
                _hx_local_14 = replaceOrAdd_result
                if (Std.isOfType(_hx_local_14,Int) or ((_hx_local_14 is None))):
                    _hx_local_14
                else:
                    raise "Class cast error"
                return _hx_local_14
            if (0 == _hx_local_15()):
                if data.replaceOrAddWord_replaced:
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.exportWords_replaced
                    _hx_local_16.exportWords_replaced = (_hx_local_17 + 1)
                    _hx_local_17
                    words_added.append(0)
                    words_replaced.append(1)
                else:
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.exportWords_added
                    _hx_local_18.exportWords_added = (_hx_local_19 + 1)
                    _hx_local_19
                    words_added.append(1)
                    words_replaced.append(0)
            else:
                result = replaceOrAdd_result
                words_added.append(0)
                words_replaced.append(0)
            i = (i + 1)
        save_result = data.saveToFile(_hx_dict.path_dictionary_file)
        def _hx_local_22():
            _hx_local_21 = save_result
            if (Std.isOfType(_hx_local_21,Int) or ((_hx_local_21 is None))):
                _hx_local_21
            else:
                raise "Class cast error"
            return _hx_local_21
        if (0 != _hx_local_22()):
            if (0 == result):
                result = save_result
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.exportAsCode_msgs = None
        _hx_o.verbCount = None
        _hx_o.exportWords_replaced = None
        _hx_o.exportWords_added = None


class forGL_MeansWhat:
    _hx_class_name = "forGL.MeansWhat"
    __slots__ = ()
    _hx_statics = ["opMeanAsStr", "returnMeanAsStr"]

    @staticmethod
    def opMeanAsStr(op_meaning,ret_internal = None):
        if (ret_internal is None):
            ret_internal = False
        ret_str = ""
        op_meaning1 = op_meaning
        if (op_meaning1 == 0):
            if ret_internal:
                ret_str = ""
            else:
                ret_str = "Unknown"
        elif (op_meaning1 == 1):
            if ret_internal:
                ret_str = "+"
            else:
                ret_str = "Plus"
        elif (op_meaning1 == 2):
            if ret_internal:
                ret_str = "-"
            else:
                ret_str = "Minus"
        elif (op_meaning1 == 3):
            if ret_internal:
                ret_str = "*"
            else:
                ret_str = "Multiply by"
        elif (op_meaning1 == 4):
            if ret_internal:
                ret_str = "/"
            else:
                ret_str = "Divide by"
        elif (op_meaning1 == 5):
            if ret_internal:
                ret_str = "%"
            else:
                ret_str = "Modulo"
        elif (op_meaning1 == 6):
            if ret_internal:
                ret_str = "min"
            else:
                ret_str = "Minimum"
        elif (op_meaning1 == 7):
            if ret_internal:
                ret_str = "max"
            else:
                ret_str = "Maximum"
        elif (op_meaning1 == 8):
            if ret_internal:
                ret_str = "atan2"
            else:
                ret_str = "ArcTan2"
        elif (op_meaning1 == 9):
            if ret_internal:
                ret_str = "pow"
            else:
                ret_str = "to Power of"
        elif (op_meaning1 == 10):
            if ret_internal:
                ret_str = "=="
            else:
                ret_str = "Is Equal?"
        elif (op_meaning1 == 11):
            if ret_internal:
                ret_str = "!="
            else:
                ret_str = "Is Not Equal?"
        elif (op_meaning1 == 12):
            if ret_internal:
                ret_str = "<"
            else:
                ret_str = "Is Less Than?"
        elif (op_meaning1 == 13):
            if ret_internal:
                ret_str = "<="
            else:
                ret_str = "Is Less or Equal?"
        elif (op_meaning1 == 14):
            if ret_internal:
                ret_str = ">"
            else:
                ret_str = "Is Greater Than?"
        elif (op_meaning1 == 15):
            if ret_internal:
                ret_str = ">="
            else:
                ret_str = "Is Greater or Equal?"
        elif (op_meaning1 == 16):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "Left Paren"
        elif (op_meaning1 == 17):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "Right Paren"
        elif (op_meaning1 == 18):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "Expression start"
        elif (op_meaning1 == 19):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "Expression end"
        elif (op_meaning1 == 20):
            if ret_internal:
                ret_str = "["
            else:
                ret_str = "Left Square Bracket"
        elif (op_meaning1 == 21):
            if ret_internal:
                ret_str = "]"
            else:
                ret_str = "Right Square Bracket"
        elif (op_meaning1 == 22):
            if ret_internal:
                ret_str = "("
            else:
                ret_str = "List start"
        elif (op_meaning1 == 23):
            if ret_internal:
                ret_str = ")"
            else:
                ret_str = "List end"
        elif (op_meaning1 == 24):
            if ret_internal:
                ret_str = "{"
            else:
                ret_str = "Left Curly Brace"
        elif (op_meaning1 == 25):
            if ret_internal:
                ret_str = "}"
            else:
                ret_str = "Right Curly Brace"
        elif (op_meaning1 == 26):
            if ret_internal:
                ret_str = "{"
            else:
                ret_str = "Block start"
        elif (op_meaning1 == 27):
            if ret_internal:
                ret_str = "}"
            else:
                ret_str = "BLock end"
        elif (op_meaning1 == 28):
            if ret_internal:
                ret_str = "concat"
            else:
                ret_str = "Concatenate"
        elif (op_meaning1 == 29):
            if ret_internal:
                ret_str = "unconcat"
            else:
                ret_str = "Un Concatenate"
        elif (op_meaning1 == 30):
            if ret_internal:
                ret_str = "pi"
            else:
                ret_str = "Pi"
        elif (op_meaning1 == 31):
            if ret_internal:
                ret_str = "random"
            else:
                ret_str = "Random"
        elif (op_meaning1 == 32):
            if ret_internal:
                ret_str = "="
            else:
                ret_str = "Assignment"
        elif (op_meaning1 == 33):
            if ret_internal:
                ret_str = "=:"
            else:
                ret_str = "Assign into"
        elif (op_meaning1 == 34):
            if ret_internal:
                ret_str = ":="
            else:
                ret_str = "Assign from"
        elif (op_meaning1 == 35):
            if ret_internal:
                ret_str = "--"
            else:
                ret_str = "Decrease by 1"
        elif (op_meaning1 == 36):
            if ret_internal:
                ret_str = "++"
            else:
                ret_str = "Increase by 1"
        elif (op_meaning1 == 45):
            if ret_internal:
                ret_str = "."
            else:
                ret_str = "Period"
        elif (op_meaning1 == 46):
            if ret_internal:
                ret_str = ","
            else:
                ret_str = "Comma"
        elif (op_meaning1 == 47):
            if ret_internal:
                ret_str = ":"
            else:
                ret_str = "Colon"
        elif (op_meaning1 == 48):
            if ret_internal:
                ret_str = ";"
            else:
                ret_str = "Semicolon"
        elif (op_meaning1 == 49):
            if ret_internal:
                ret_str = "."
            else:
                ret_str = "Punctuation"
        elif (op_meaning1 == 50):
            if ret_internal:
                ret_str = "abs"
            else:
                ret_str = "Absolute value"
        elif (op_meaning1 == 51):
            if ret_internal:
                ret_str = "degrees"
            else:
                ret_str = "to Degrees"
        elif (op_meaning1 == 52):
            if ret_internal:
                ret_str = "radians"
            else:
                ret_str = "to Radians"
        elif (op_meaning1 == 53):
            if ret_internal:
                ret_str = "sin"
            else:
                ret_str = "Sine"
        elif (op_meaning1 == 54):
            if ret_internal:
                ret_str = "cos"
            else:
                ret_str = "Cosine"
        elif (op_meaning1 == 55):
            if ret_internal:
                ret_str = "tan"
            else:
                ret_str = "Tangent"
        elif (op_meaning1 == 56):
            if ret_internal:
                ret_str = "asin"
            else:
                ret_str = "ArcSine"
        elif (op_meaning1 == 57):
            if ret_internal:
                ret_str = "acos"
            else:
                ret_str = "ArcCosine"
        elif (op_meaning1 == 58):
            if ret_internal:
                ret_str = "atan"
            else:
                ret_str = "ArcTangent"
        elif (op_meaning1 == 59):
            if ret_internal:
                ret_str = "exp"
            else:
                ret_str = "e to the power of"
        elif (op_meaning1 == 60):
            if ret_internal:
                ret_str = "ln"
            else:
                ret_str = "natural Logarithm"
        elif (op_meaning1 == 61):
            if ret_internal:
                ret_str = "log"
            else:
                ret_str = "base 10 Logarithm"
        elif (op_meaning1 == 62):
            if ret_internal:
                ret_str = "sqrt"
            else:
                ret_str = "SquareRoot"
        elif (op_meaning1 == 63):
            if ret_internal:
                ret_str = "round"
            else:
                ret_str = "Round"
        elif (op_meaning1 == 64):
            if ret_internal:
                ret_str = "floor"
            else:
                ret_str = "Floor"
        elif (op_meaning1 == 65):
            if ret_internal:
                ret_str = "ceil"
            else:
                ret_str = "Ceiling"
        else:
            pass
        return ret_str

    @staticmethod
    def returnMeanAsStr(ret_meaning):
        ret_str = ""
        ret_meaning1 = ret_meaning
        if (ret_meaning1 == -11):
            ret_str = "INTERNAL ERROR found"
        elif (ret_meaning1 == -10):
            ret_str = "INTERNAL ERROR: is NOT IMPLEMENTED"
        elif (ret_meaning1 == -9):
            ret_str = "ERROR: File not found"
        elif (ret_meaning1 == -8):
            ret_str = "ERROR: File path not found"
        elif (ret_meaning1 == -5):
            ret_str = "User code has a Logical error"
        elif (ret_meaning1 == -4):
            ret_str = "User code has a Syntax error"
        elif (ret_meaning1 == -3):
            ret_str = "Data type or value given is not appropriate"
        elif (ret_meaning1 == -2):
            ret_str = "User code has an error"
        elif (ret_meaning1 == -1):
            ret_str = "User wanted to Stop"
        elif (ret_meaning1 == 0):
            ret_str = "OK, normal result"
        elif (ret_meaning1 == 1):
            ret_str = "Not enough Data now, trying next words"
        elif (ret_meaning1 == 2):
            ret_str = "Not enough Nouns now, trying next words"
        elif (ret_meaning1 == 3):
            ret_str = "No punctuation yet, trying next words"
        else:
            pass
        return ret_str


class forGL_NLImport:
    _hx_class_name = "forGL.NLImport"
    __slots__ = ("importWords_msgs",)
    _hx_fields = ["importWords_msgs"]
    _hx_methods = ["init", "cleanUp", "importWords"]

    def __init__(self):
        self.importWords_msgs = ""

    def init(self):
        pass

    def cleanUp(self):
        pass

    def importWords(self,data,_hx_dict,dict_path_file):
        result = 0
        self.importWords_msgs = ""
        words = data.getListOfWords()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.importWords_msgs
        _hx_local_0.importWords_msgs = (Std.string(_hx_local_1) + ((("Information: " + Std.string(len(words))) + " words to import.\n")))
        _hx_local_0.importWords_msgs
        if (0 == len(words)):
            return 0
        next_word = ""
        words_str = (words[0] if 0 < len(words) else None)
        i = 0
        line_len = 0
        while (i < len(words)):
            next_word = (words[i] if i >= 0 and i < len(words) else None)
            i = (i + 1)
            if ((line_len + ((0 if ((next_word is None)) else len(next_word)))) > 77):
                words_str = (Std.string(words_str) + HxOverrides.stringOrNull(((", \n" + Std.string(next_word)))))
                line_len = (0 if ((next_word is None)) else len(next_word))
            else:
                words_str = (Std.string(words_str) + HxOverrides.stringOrNull(((", " + Std.string(next_word)))))
                line_len = (line_len + ((2 + ((0 if ((next_word is None)) else len(next_word))))))
        _hx_str = (("Words to Import are:\n" + Std.string(words_str)) + "\n")
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.importWords_msgs
        _hx_local_6.importWords_msgs = (Std.string(_hx_local_7) + ("null" if _hx_str is None else _hx_str))
        _hx_local_6.importWords_msgs
        rInfo = forGL_ResolveInfo()
        rOtherInfo = forGL_ResolveInfo()
        find_result = 0
        i = 0
        while (i < len(words)):
            find_result = data.findWordDef((words[i] if i >= 0 and i < len(words) else None),rInfo)
            if (0 != find_result):
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.importWords_msgs
                _hx_local_8.importWords_msgs = (Std.string(_hx_local_9) + HxOverrides.stringOrNull(((((("INTERNAL ERROR: findWordDef of " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " has unexpected result of ") + Std.string(forGL_MeansWhat.returnMeanAsStr(find_result))) + ". Skipping to next word.\n"))))
                _hx_local_8.importWords_msgs
                i = (i + 1)
                continue
            _hx_str = rInfo.resolve_out_token
            if (0 == ((0 if ((_hx_str is None)) else len(_hx_str)))):
                rInfo.resolve_out_token = hx_strings_Strings.toLowerCase8((words[i] if i >= 0 and i < len(words) else None))
            rInfo.resolve_use_out = True
            dictIdx = _hx_dict.findWord((words[i] if i >= 0 and i < len(words) else None))
            if ((2 == data.findWordDef_type) and ((0 == rInfo.resolve_op_meaning))):
                resolve_result = forGL_NLTypeAs.resolveType(rInfo.resolve_out_token,rOtherInfo,False,False)
                if (2 == resolve_result):
                    rInfo.resolve_op_meaning = rOtherInfo.resolve_op_meaning
                    rInfo.resolve_out_token = rOtherInfo.resolve_out_token
                elif (3 == resolve_result):
                    rInfo.resolve_op_meaning = rOtherInfo.resolve_op_meaning
                    rInfo.resolve_out_token = rOtherInfo.resolve_out_token
                    data.findWordDef_type = 3
                else:
                    err_msg = (("INTERNAL ERROR: Word " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " unable to resolve details of Operator type. Skipping to next word.\n")
                    _hx_local_11 = self
                    _hx_local_12 = _hx_local_11.importWords_msgs
                    _hx_local_11.importWords_msgs = (Std.string(_hx_local_12) + ("null" if err_msg is None else err_msg))
                    _hx_local_11.importWords_msgs
                    forGL_ForGL_ui.error(err_msg)
                    i = (i + 1)
                    continue
            if (2 == data.findWordDef_type):
                built_in_op_str = forGL_MeansWhat.opMeanAsStr(rInfo.resolve_op_meaning,True)
                rInfo.resolve_out_token = built_in_op_str
            if (6 == data.findWordDef_type):
                rInfo.resolve_op_meaning = 0
                if (8 == rInfo.resolve_token_noun_data):
                    rInfo.resolve_float = 0.0
                    rInfo.resolve_int = 0
                    resolve_result1 = forGL_NLTypeAs.resolveType(rInfo.resolve_str,rOtherInfo,False,True)
                    if ((0 != resolve_result1) and ((8 != resolve_result1))):
                        rInfo.resolve_token_noun_data = resolve_result1
                        rInfo.resolve_str = ""
                        resolve_result2 = resolve_result1
                        if (resolve_result2 == 9):
                            rInfo.resolve_int = rOtherInfo.resolve_int
                        elif (resolve_result2 == 10):
                            rInfo.resolve_int = rOtherInfo.resolve_int
                        elif (resolve_result2 == 11):
                            rInfo.resolve_float = rOtherInfo.resolve_float
                        else:
                            err_msg1 = (("INTERNAL ERROR: importWords " + Std.string((words[i] if i >= 0 and i < len(words) else None))) + " Unexpected resolve result. Skipping to next Word.\n")
                            _hx_local_14 = self
                            _hx_local_15 = _hx_local_14.importWords_msgs
                            _hx_local_14.importWords_msgs = (Std.string(_hx_local_15) + ("null" if err_msg1 is None else err_msg1))
                            _hx_local_14.importWords_msgs
                            forGL_ForGL_ui.error(err_msg1,1)
                            i = (i + 1)
                            continue
            if (4 == data.findWordDef_type):
                rInfo.resolve_token_noun_data = 0
                rInfo.resolve_op_meaning = 0
                rInfo.resolve_float = 0.0
                rInfo.resolve_int = 0
            if (0 <= dictIdx):
                replace_result = _hx_dict.addWord((words[i] if i >= 0 and i < len(words) else None),data.findWordDef_type,rInfo.resolve_out_token,rInfo.resolve_op_meaning,rInfo.resolve_str,rInfo.resolve_float,rInfo.resolve_int,rInfo.resolve_token_noun_data,dictIdx)
                def _hx_local_18():
                    _hx_local_17 = replace_result
                    if (Std.isOfType(_hx_local_17,Int) or ((_hx_local_17 is None))):
                        _hx_local_17
                    else:
                        raise "Class cast error"
                    return _hx_local_17
                if ((0 != _hx_local_18()) or ((0 < len(_hx_dict.addWord_msg)))):
                    forGL_ForGL_ui.status(Std.string(rInfo))
                    forGL_ForGL_ui.status(_hx_dict.addWord_msg)
                result = replace_result
            else:
                add_result = _hx_dict.addWord((words[i] if i >= 0 and i < len(words) else None),data.findWordDef_type,rInfo.resolve_out_token,rInfo.resolve_op_meaning,rInfo.resolve_str,rInfo.resolve_float,rInfo.resolve_int,rInfo.resolve_token_noun_data)
                def _hx_local_20():
                    _hx_local_19 = add_result
                    if (Std.isOfType(_hx_local_19,Int) or ((_hx_local_19 is None))):
                        _hx_local_19
                    else:
                        raise "Class cast error"
                    return _hx_local_19
                if ((0 != _hx_local_20()) or ((0 < len(_hx_dict.addWord_msg)))):
                    forGL_ForGL_ui.status(Std.string(rInfo))
                    forGL_ForGL_ui.status(_hx_dict.addWord_msg)
                result = add_result
            i = (i + 1)
        if (0 < len(words)):
            _hx_dict.sortDictionary()
        return result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.importWords_msgs = None


class forGL_ResolveInfo:
    _hx_class_name = "forGL.ResolveInfo"
    __slots__ = ("resolve_token_noun_data", "resolve_int", "resolve_float", "resolve_str", "resolve_out_token", "resolve_use_out", "resolve_op_meaning")
    _hx_fields = ["resolve_token_noun_data", "resolve_int", "resolve_float", "resolve_str", "resolve_out_token", "resolve_use_out", "resolve_op_meaning"]

    def __init__(self):
        self.resolve_token_noun_data = 0
        self.resolve_int = 0
        self.resolve_float = 0.0
        self.resolve_str = ""
        self.resolve_out_token = ""
        self.resolve_use_out = False
        self.resolve_op_meaning = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resolve_token_noun_data = None
        _hx_o.resolve_int = None
        _hx_o.resolve_float = None
        _hx_o.resolve_str = None
        _hx_o.resolve_out_token = None
        _hx_o.resolve_use_out = None
        _hx_o.resolve_op_meaning = None


class forGL_NLTypeAs:
    _hx_class_name = "forGL.NLTypeAs"
    __slots__ = ()
    _hx_statics = ["nlTypeIsData", "nlTypeAsStr", "resolveType"]

    @staticmethod
    def nlTypeIsData(nl_type):
        retVal = False
        return retVal

    @staticmethod
    def nlTypeAsStr(nl_type):
        ret_str = ""
        nl_type1 = nl_type
        if (nl_type1 == 0):
            ret_str = "Unknown"
        elif (nl_type1 == 1):
            ret_str = "Comment"
        elif (nl_type1 == 2):
            ret_str = "Operator"
        elif (nl_type1 == 3):
            ret_str = "Verb, Built In"
        elif (nl_type1 == 4):
            ret_str = "Verb"
        elif (nl_type1 == 5):
            ret_str = "Return from Verb"
        elif (nl_type1 == 6):
            ret_str = "Noun"
        elif (nl_type1 == 7):
            ret_str = "Noun, Local"
        elif (nl_type1 == 8):
            ret_str = "String"
        elif (nl_type1 == 9):
            ret_str = "Integer"
        elif (nl_type1 == 10):
            ret_str = "Bool"
        elif (nl_type1 == 11):
            ret_str = "Float"
        elif (nl_type1 == 12):
            ret_str = "Punctuation"
        elif (nl_type1 == 13):
            ret_str = "Choice"
        else:
            pass
        return ret_str

    @staticmethod
    def resolveType(in_token,rInfo,run_verbose = None,trim_quotes = None):
        if (run_verbose is None):
            run_verbose = False
        if (trim_quotes is None):
            trim_quotes = False
        type_found = 0
        verbose = run_verbose
        rInfo.resolve_use_out = False
        if (("true" == in_token) or (("false" == in_token))):
            if ("true" == in_token):
                rInfo.resolve_int = 1
            else:
                rInfo.resolve_int = 0
            return 10
        if ((("\"" == hx_strings_Strings.charAt8(in_token,0)) and ((1 < ((0 if ((in_token is None)) else len(in_token)))))) and (("\"" == hx_strings_Strings.charAt8(in_token,(((0 if ((in_token is None)) else len(in_token))) - 1))))):
            rInfo.resolve_str = in_token
            type_found = 8
            if (not trim_quotes):
                return type_found
            elif (3 <= ((0 if ((in_token is None)) else len(in_token)))):
                in_token = hx_strings_Strings.trim(in_token,hx_strings_internal__Either2__Either2.a("\""))
            else:
                return type_found
        rInfo.resolve_str = ""
        rInfo.resolve_float = Std.parseFloat(in_token)
        if (not python_lib_Math.isnan(rInfo.resolve_float)):
            if (((0.0 == rInfo.resolve_float) and ((2 < ((0 if ((in_token is None)) else len(in_token)))))) and (("0" == hx_strings_Strings.charAt8(in_token,0)))):
                if (("x" == hx_strings_Strings.charAt8(in_token,1)) or (("X" == hx_strings_Strings.charAt8(in_token,1)))):
                    rInfo.resolve_int = Std.parseInt(in_token)
                    if verbose:
                        forGL_ForGL_ui.msg((((("\nHex number " + Std.string(in_token)) + " is now ") + Std.string(rInfo.resolve_int)) + "\n"))
                    return 9
            type_found = 11
            decimal_idx = hx_strings_Strings.indexOf8(in_token,".")
            test_tokens = [""]
            if (len(test_tokens) != 0):
                test_tokens.pop()
            if (-1 != decimal_idx):
                x = hx_strings_Strings.substringBefore(in_token,".")
                test_tokens.append(x)
                x = hx_strings_Strings.substringAfter(in_token,".")
                test_tokens.append(x)
            else:
                test_tokens.append(in_token)
            test_tokens_len = len(test_tokens)
            if verbose:
                forGL_ForGL_ui.msg((("test_tokens.length = " + Std.string(test_tokens_len)) + "\n"))
                forGL_ForGL_ui.msg((("test_tokens[0] = " + Std.string((test_tokens[0] if 0 < len(test_tokens) else None))) + "\n"))
            if (2 == test_tokens_len):
                if (0 == Std.parseInt((test_tokens[1] if 1 < len(test_tokens) else None))):
                    test_tokens_len = 1
            if (1 == test_tokens_len):
                rInfo.resolve_int = Std.parseInt((test_tokens[0] if 0 < len(test_tokens) else None))
                cast_float = rInfo.resolve_int
                diff_float = (rInfo.resolve_float - cast_float)
                if verbose:
                    forGL_ForGL_ui.msg((("resolve_float = " + Std.string(rInfo.resolve_float)) + "\n"))
                    forGL_ForGL_ui.msg((("  cast_float  = " + Std.string(cast_float)) + "\n"))
                    forGL_ForGL_ui.msg((("  diff_float  = " + Std.string(diff_float)) + "\n"))
                if (0.0 == diff_float):
                    type_found = 9
            elif verbose:
                forGL_ForGL_ui.msg((("test_tokens.length = " + Std.string(len(test_tokens))) + "\n"))
        else:
            type_found = 2
            in_token1 = in_token
            if (in_token1 == "!="):
                rInfo.resolve_op_meaning = 11
            elif (in_token1 == "%"):
                rInfo.resolve_op_meaning = 5
            elif (in_token1 == "("):
                rInfo.resolve_op_meaning = 18
            elif (in_token1 == ")"):
                rInfo.resolve_op_meaning = 19
            elif (in_token1 == "*"):
                rInfo.resolve_op_meaning = 3
            elif (in_token1 == "**"):
                rInfo.resolve_out_token = "**"
                rInfo.resolve_op_meaning = 9
            elif (in_token1 == "+"):
                rInfo.resolve_op_meaning = 1
            elif (in_token1 == "++"):
                rInfo.resolve_op_meaning = 36
            elif (in_token1 == ","):
                rInfo.resolve_op_meaning = 46
            elif (in_token1 == "-"):
                rInfo.resolve_op_meaning = 2
            elif (in_token1 == "--"):
                rInfo.resolve_op_meaning = 35
            elif (in_token1 == "."):
                rInfo.resolve_op_meaning = 45
            elif (in_token1 == "/"):
                rInfo.resolve_op_meaning = 4
            elif (in_token1 == ":"):
                rInfo.resolve_op_meaning = 47
            elif (in_token1 == ":="):
                rInfo.resolve_op_meaning = 34
            elif (in_token1 == ";"):
                rInfo.resolve_op_meaning = 48
            elif (in_token1 == "<"):
                rInfo.resolve_op_meaning = 12
            elif (in_token1 == "<="):
                rInfo.resolve_op_meaning = 13
            elif (in_token1 == "="):
                rInfo.resolve_op_meaning = 32
            elif (in_token1 == "=:"):
                rInfo.resolve_op_meaning = 33
            elif (in_token1 == "=="):
                rInfo.resolve_op_meaning = 10
            elif (in_token1 == ">"):
                rInfo.resolve_op_meaning = 14
            elif (in_token1 == ">="):
                rInfo.resolve_op_meaning = 15
            elif (in_token1 == "["):
                rInfo.resolve_op_meaning = 22
            elif (in_token1 == "]"):
                rInfo.resolve_op_meaning = 23
            elif (in_token1 == "^"):
                rInfo.resolve_out_token = "^"
                rInfo.resolve_op_meaning = 9
            elif (in_token1 == "{"):
                rInfo.resolve_op_meaning = 26
            elif (in_token1 == "}"):
                rInfo.resolve_op_meaning = 27
            else:
                type_found = 0
            if (2 == type_found):
                return 2
            type_found = 2
            in_token_lower = hx_strings_Strings.toLowerCase8(in_token)
            in_token_lower1 = in_token_lower
            if (in_token_lower1 == "abs"):
                rInfo.resolve_out_token = "abs"
                rInfo.resolve_op_meaning = 50
            elif (in_token_lower1 == "acos"):
                rInfo.resolve_out_token = "acos"
                rInfo.resolve_op_meaning = 57
            elif (in_token_lower1 == "add"):
                rInfo.resolve_out_token = "+"
                rInfo.resolve_op_meaning = 1
            elif (in_token_lower1 == "asin"):
                rInfo.resolve_out_token = "asin"
                rInfo.resolve_op_meaning = 56
            elif (in_token_lower1 == "atan"):
                rInfo.resolve_out_token = "atan"
                rInfo.resolve_op_meaning = 58
            elif (in_token_lower1 == "atan2"):
                rInfo.resolve_out_token = "atan2"
                rInfo.resolve_op_meaning = 8
            elif (in_token_lower1 == "ceil"):
                rInfo.resolve_out_token = "ceil"
                rInfo.resolve_op_meaning = 65
            elif (in_token_lower1 == "concat"):
                rInfo.resolve_out_token = "concat"
                rInfo.resolve_op_meaning = 28
            elif (in_token_lower1 == "concatenate"):
                rInfo.resolve_out_token = "concat"
                rInfo.resolve_op_meaning = 28
            elif (in_token_lower1 == "cos"):
                rInfo.resolve_out_token = "cos"
                rInfo.resolve_op_meaning = 54
            elif (in_token_lower1 == "decrement"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 35
            elif (in_token_lower1 == "degree"):
                rInfo.resolve_out_token = "degrees"
                rInfo.resolve_op_meaning = 51
            elif (in_token_lower1 == "degrees"):
                rInfo.resolve_out_token = "degrees"
                rInfo.resolve_op_meaning = 51
            elif (in_token_lower1 == "divide"):
                rInfo.resolve_out_token = "/"
                rInfo.resolve_op_meaning = 4
            elif (in_token_lower1 == "divided"):
                rInfo.resolve_out_token = "/"
                rInfo.resolve_op_meaning = 4
            elif (in_token_lower1 == "equal"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 32
            elif (in_token_lower1 == "equals"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 32
            elif (in_token_lower1 == "exp"):
                rInfo.resolve_out_token = "exp"
                rInfo.resolve_op_meaning = 59
            elif (in_token_lower1 == "floor"):
                rInfo.resolve_out_token = "floor"
                rInfo.resolve_op_meaning = 64
            elif (in_token_lower1 == "from"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 34
            elif (in_token_lower1 == "increment"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 36
            elif (in_token_lower1 == "into"):
                rInfo.resolve_out_token = "="
                rInfo.resolve_op_meaning = 33
            elif (in_token_lower1 == "ln"):
                rInfo.resolve_out_token = "ln"
                rInfo.resolve_op_meaning = 60
            elif (in_token_lower1 == "log"):
                rInfo.resolve_out_token = "log"
                rInfo.resolve_op_meaning = 61
            elif (in_token_lower1 == "max"):
                rInfo.resolve_out_token = "max"
                rInfo.resolve_op_meaning = 7
            elif (in_token_lower1 == "min"):
                rInfo.resolve_out_token = "min"
                rInfo.resolve_op_meaning = 6
            elif (in_token_lower1 == "minus"):
                rInfo.resolve_out_token = "-"
                rInfo.resolve_op_meaning = 2
            elif (in_token_lower1 == "mod"):
                rInfo.resolve_out_token = "%"
                rInfo.resolve_op_meaning = 5
            elif (in_token_lower1 == "modulo"):
                rInfo.resolve_out_token = "%"
                rInfo.resolve_op_meaning = 5
            elif (in_token_lower1 == "multiplied"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "multiply"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "pi"):
                rInfo.resolve_out_token = "pi"
                rInfo.resolve_op_meaning = 30
            elif (in_token_lower1 == "plus"):
                rInfo.resolve_out_token = "+"
                rInfo.resolve_op_meaning = 1
            elif (in_token_lower1 == "pow"):
                rInfo.resolve_out_token = "pow"
                rInfo.resolve_op_meaning = 9
            elif (in_token_lower1 == "radian"):
                rInfo.resolve_out_token = "radians"
                rInfo.resolve_op_meaning = 52
            elif (in_token_lower1 == "radians"):
                rInfo.resolve_out_token = "radians"
                rInfo.resolve_op_meaning = 52
            elif (in_token_lower1 == "random"):
                rInfo.resolve_out_token = "random"
                rInfo.resolve_op_meaning = 31
            elif (in_token_lower1 == "round"):
                rInfo.resolve_out_token = "round"
                rInfo.resolve_op_meaning = 63
            elif (in_token_lower1 == "sin"):
                rInfo.resolve_out_token = "sin"
                rInfo.resolve_op_meaning = 53
            elif (in_token_lower1 == "sqrt"):
                rInfo.resolve_out_token = "sqrt"
                rInfo.resolve_op_meaning = 62
            elif (in_token_lower1 == "subtract"):
                rInfo.resolve_out_token = "-"
                rInfo.resolve_op_meaning = 2
            elif (in_token_lower1 == "tan"):
                rInfo.resolve_out_token = "tan"
                rInfo.resolve_op_meaning = 55
            elif (in_token_lower1 == "times"):
                rInfo.resolve_out_token = "*"
                rInfo.resolve_op_meaning = 3
            elif (in_token_lower1 == "unconcat"):
                rInfo.resolve_out_token = "unconcat"
                rInfo.resolve_op_meaning = 29
            elif (in_token_lower1 == "unconcatenate"):
                rInfo.resolve_out_token = "unconcat"
                rInfo.resolve_op_meaning = 29
            else:
                type_found = 0
            if (2 == type_found):
                rInfo.resolve_use_out = True
                return 2
            type_found = 3
            in_token_lower1 = in_token_lower
            if (in_token_lower1 == "repeat"):
                pass
            elif (in_token_lower1 == "show"):
                pass
            elif (in_token_lower1 == "view"):
                pass
            else:
                type_found = 0
            if (3 == type_found):
                rInfo.resolve_out_token = in_token_lower
                rInfo.resolve_use_out = True
                return 3
        return type_found

class forGL_ParseStyle(Enum):
    __slots__ = ()
    _hx_class_name = "forGL.ParseStyle"
    _hx_constructs = ["PARSE_LEFT_TO_RIGHT", "PARSE_RIGHT_TO_LEFT"]
forGL_ParseStyle.PARSE_LEFT_TO_RIGHT = forGL_ParseStyle("PARSE_LEFT_TO_RIGHT", 0, ())
forGL_ParseStyle.PARSE_RIGHT_TO_LEFT = forGL_ParseStyle("PARSE_RIGHT_TO_LEFT", 1, ())


class forGL_NLToken:
    _hx_class_name = "forGL.NLToken"
    __slots__ = ("internal_token", "visible_token", "verbose_phrase", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means")
    _hx_fields = ["internal_token", "visible_token", "verbose_phrase", "token_str", "token_float", "token_type", "token_noun_data", "token_int", "token_op_means"]

    def __init__(self,internal_word,visible_word,verbose,data_str,data_float,word_type,noun_data,data_int,op_means):
        self.internal_token = internal_word
        self.visible_token = visible_word
        self.verbose_phrase = verbose
        self.token_str = data_str
        self.token_float = data_float
        self.token_type = word_type
        self.token_noun_data = noun_data
        self.token_int = data_int
        self.token_op_means = op_means

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.internal_token = None
        _hx_o.visible_token = None
        _hx_o.verbose_phrase = None
        _hx_o.token_str = None
        _hx_o.token_float = None
        _hx_o.token_type = None
        _hx_o.token_noun_data = None
        _hx_o.token_int = None
        _hx_o.token_op_means = None


class forGL_Parse:
    _hx_class_name = "forGL.Parse"
    __slots__ = ("parse_text_lines_added", "resolve_similar_word", "left_groups", "right_groups", "repeat_verb_found", "resolveChoice_msgs", "saveNounValues_errors", "updateNounValues_errors", "words_table_text")
    _hx_fields = ["parse_text_lines_added", "resolve_similar_word", "left_groups", "right_groups", "repeat_verb_found", "resolveChoice_msgs", "saveNounValues_errors", "updateNounValues_errors", "words_table_text"]
    _hx_methods = ["init", "strChunk", "parse", "resolveTokens", "resolveAssigns", "refactorForExport", "resolveChoice", "saveNounValues", "updateNounValues", "showWordsTable", "cleanUp"]

    def __init__(self):
        self.words_table_text = ""
        self.updateNounValues_errors = ""
        self.saveNounValues_errors = ""
        self.resolveChoice_msgs = ""
        self.repeat_verb_found = False
        self.right_groups = 0
        self.left_groups = 0
        self.resolve_similar_word = ""
        self.parse_text_lines_added = 0

    def init(self):
        pass

    def strChunk(self,chunk,prev,style,verbose = None):
        if (verbose is None):
            verbose = False
        unChunks = list()
        i = 0
        code = 0
        char = ""
        while (i < len(prev)):
            unChunks.append((prev[i] if i >= 0 and i < len(prev) else None))
            i = (i + 1)
        prev_char = ""
        is_prev_num = False
        next = ""
        length = (0 if ((chunk is None)) else len(chunk))
        i = 0
        while (i < length):
            code = hx_strings_Strings.charCodeAt8(chunk,i)
            char = hx_strings_Strings.charAt8(chunk,i)
            if (32 <= code):
                if is_prev_num:
                    if ((48 <= code) and ((code <= 57))):
                        next = (("null" if next is None else next) + ("null" if char is None else char))
                        prev_char = char
                        i = (i + 1)
                        continue
                    elif ((((((("." != char) and (("x" != char))) and (("X" != char))) and (("+" != char))) and (("-" != char))) and (("e" != char))) and (("E" != char))):
                        if ((" " == char) and (("." == prev_char))):
                            next = HxString.substr(next,0,(len(next) - 1))
                            next = (("null" if next is None else next) + " ")
                            next = (("null" if next is None else next) + ".")
                        is_prev_num = False
                        next = (("null" if next is None else next) + " ")
                    else:
                        next = (("null" if next is None else next) + ("null" if char is None else char))
                        prev_char = char
                        i = (i + 1)
                        continue
                elif (("0" <= char) and ((char <= "9"))):
                    is_prev_num = True
                    if (" " != prev_char):
                        next = (("null" if next is None else next) + " ")
                    next = (("null" if next is None else next) + ("null" if char is None else char))
                    prev_char = char
                    i = (i + 1)
                    continue
                insert_blanks = True
                insert_str = char
                char1 = char
                if (char1 == "!"):
                    if (i < ((length - 1))):
                        char2 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char2):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "%"):
                    pass
                elif (char1 == "&"):
                    if (i < ((length - 1))):
                        char21 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("&" == char21):
                            insert_str = (("null" if insert_str is None else insert_str) + "&")
                            i = (i + 1)
                        elif ("=" == char21):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "'"):
                    pass
                elif (char1 == "("):
                    pass
                elif (char1 == ")"):
                    pass
                elif (char1 == "*"):
                    if (i < ((length - 1))):
                        char22 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("*" == char22):
                            insert_str = (("null" if insert_str is None else insert_str) + "*")
                            i = (i + 1)
                elif (char1 == "+"):
                    if (i < ((length - 1))):
                        char23 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("+" == char23):
                            insert_str = (("null" if insert_str is None else insert_str) + "+")
                            i = (i + 1)
                elif (char1 == ","):
                    pass
                elif (char1 == "-"):
                    if (i < ((length - 1))):
                        char24 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("-" == char24):
                            insert_str = (("null" if insert_str is None else insert_str) + "-")
                            i = (i + 1)
                    elif (i < ((length - 1))):
                        char25 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if (hx_strings_Strings.isDigits(char25) or (("." == char25))):
                            insert_blanks = False
                elif (char1 == "."):
                    if (i < ((length - 1))):
                        char26 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if hx_strings_Strings.isDigits(char26):
                            insert_blanks = False
                elif (char1 == "/"):
                    pass
                elif (char1 == ":"):
                    if (i < ((length - 1))):
                        char27 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char27):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == ";"):
                    pass
                elif (char1 == "<"):
                    if (i < ((length - 1))):
                        char28 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char28):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "="):
                    if (i < ((length - 1))):
                        char29 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char29):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                        elif (":" == char29):
                            insert_str = (("null" if insert_str is None else insert_str) + ":")
                            i = (i + 1)
                elif (char1 == ">"):
                    if (i < ((length - 1))):
                        char210 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("=" == char210):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "?"):
                    pass
                elif (char1 == "@"):
                    pass
                elif (char1 == "["):
                    pass
                elif (char1 == "\\"):
                    pass
                elif (char1 == "]"):
                    pass
                elif (char1 == "^"):
                    pass
                elif (char1 == "{"):
                    pass
                elif (char1 == "|"):
                    if (i < ((length - 1))):
                        char211 = hx_strings_Strings.charAt8(chunk,(i + 1))
                        if ("|" == char211):
                            insert_str = (("null" if insert_str is None else insert_str) + "|")
                            i = (i + 1)
                        elif ("=" == char211):
                            insert_str = (("null" if insert_str is None else insert_str) + "=")
                            i = (i + 1)
                elif (char1 == "}"):
                    pass
                else:
                    insert_blanks = False
                if insert_blanks:
                    next = (("null" if next is None else next) + HxOverrides.stringOrNull((((" " + ("null" if insert_str is None else insert_str)) + " "))))
                    prev_char = " "
                else:
                    next = (("null" if next is None else next) + ("null" if char is None else char))
                    prev_char = char
            else:
                tmp = (13 == code)
                next = (("null" if next is None else next) + " ")
                prev_char = " "
            i = (i + 1)
        io_tokens = next.split(" ")
        i = 0
        while (i < len(io_tokens)):
            if (0 < len((io_tokens[i] if i >= 0 and i < len(io_tokens) else None))):
                unChunks.append((io_tokens[i] if i >= 0 and i < len(io_tokens) else None))
            i = (i + 1)
        return unChunks

    def parse(self,in_lang_str,style,verbose = None):
        if (verbose is None):
            verbose = False
        ret_val = 0
        self.parse_text_lines_added = 0
        scanning_top_to_bottom = True
        scanning_left_to_right = True
        if (forGL_ParseStyle.PARSE_RIGHT_TO_LEFT == style):
            scanning_left_to_right = False
        no_empty = list()
        try:
            parse_str = in_lang_str
            length = (0 if ((parse_str is None)) else len(parse_str))
            if scanning_left_to_right:
                i = 0
                char = ""
                str_chunk = ""
                quoted_str = ""
                string_depth = 0
                while (i < length):
                    char = hx_strings_Strings.charAt8(parse_str,i)
                    if ("\"" == char):
                        if (0 == string_depth):
                            if (0 < ((0 if ((str_chunk is None)) else len(str_chunk)))):
                                no_empty = self.strChunk(str_chunk,no_empty,style,verbose)
                                str_chunk = ""
                            string_depth = (string_depth + 1)
                            quoted_str = "\""
                        else:
                            string_depth = (string_depth - 1)
                            if (0 == string_depth):
                                quoted_str = (Std.string(quoted_str) + "\"")
                                no_empty.append(quoted_str)
                                quoted_str = ""
                        i = (i + 1)
                        continue
                    if (0 != string_depth):
                        quoted_str = (Std.string(quoted_str) + ("null" if char is None else char))
                    else:
                        str_chunk = (Std.string(str_chunk) + ("null" if char is None else char))
                    i = (i + 1)
                if (0 < ((0 if ((str_chunk is None)) else len(str_chunk)))):
                    no_empty = self.strChunk(str_chunk,no_empty,style,verbose)
                    str_chunk = ""
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Parse style Right to Left not implemented. \n")
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.parse_text_lines_added
                _hx_local_7.parse_text_lines_added = (_hx_local_8 + 1)
                _hx_local_8
                ret_val = -10
                verbose = True
                return list()
            if (0 == len(no_empty)):
                forGL_ForGL_ui.error("ERROR: Nothing to parse. \n")
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.parse_text_lines_added
                _hx_local_9.parse_text_lines_added = (_hx_local_10 + 1)
                _hx_local_10
                ret_val = -3
                verbose = True
                return no_empty
            if verbose:
                forGL_ForGL_ui.msg("\nOriginal definition:\n")
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.parse_text_lines_added
                _hx_local_11.parse_text_lines_added = (_hx_local_12 + 1)
                _hx_local_12
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.parse_text_lines_added
                _hx_local_13.parse_text_lines_added = (_hx_local_14 + 1)
                _hx_local_14
                forGL_ForGL_ui.msg((Std.string(parse_str) + "\n"))
                _hx_local_15 = self
                _hx_local_16 = _hx_local_15.parse_text_lines_added
                _hx_local_15.parse_text_lines_added = (_hx_local_16 + 1)
                _hx_local_16
                forGL_ForGL_ui.msg((Std.string(len(no_empty)) + " tokens found\n"))
                _hx_local_17 = self
                _hx_local_18 = _hx_local_17.parse_text_lines_added
                _hx_local_17.parse_text_lines_added = (_hx_local_18 + 1)
                _hx_local_18
                forGL_ForGL_ui.msg((Std.string(no_empty) + "\n"))
                char_code = Sys.getChar(False)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in Parse.parse(): " + Std.string(e)) + " \n"))
        return no_empty

    def resolveTokens(self,tokens,nlDict,runStack,verbose = None):
        if (verbose is None):
            verbose = False
        lines_added = 0
        self.resolve_similar_word = ""
        append_offset = len(runStack)
        self.left_groups = 0
        self.right_groups = 0
        self.repeat_verb_found = False
        ri = forGL_ResolveInfo()
        type_found = 0
        i = 0
        dictIdx = -1
        token = ""
        token_lower = ""
        try:
            prev_replace = ""
            no_replace = ""
            a_token = forGL_NLToken("","","","",0.0,0,0,0,0)
            runIdx = append_offset
            prev_internal_token = ""
            while (i < len(tokens)):
                runIdx = (append_offset + i)
                token = (tokens[i] if i >= 0 and i < len(tokens) else None)
                token_lower = hx_strings_Strings.toLowerCase8(token)
                dictIdx = nlDict.findWord(token)
                if (dictIdx < 0):
                    type_found = forGL_NLTypeAs.resolveType(token,ri,verbose)
                    ask_similar = True
                    if (0 == type_found):
                        if ("=:" == prev_internal_token):
                            type_found = 7
                        else:
                            type_found = 7
                    if (7 == type_found):
                        ask_similar = False
                    if ((ask_similar and ((0 == type_found))) and ((1 < ((0 if ((token_lower is None)) else len(token_lower)))))):
                        similarWord = nlDict.findSimilar(token_lower)
                        if (0 < ((0 if ((similarWord is None)) else len(similarWord)))):
                            newline_needed = False
                            if ((token_lower != prev_replace) and ((token_lower != no_replace))):
                                forGL_ForGL_ui.msg((((Std.string(token_lower) + "  was not found. Use  ") + Std.string(similarWord)) + "  instead (y/n)? "))
                                ans_done = False
                                while (not ans_done):
                                    char_code = Sys.getChar(True)
                                    if ((13 == char_code) or ((10 == char_code))):
                                        break
                                    if ((89 == char_code) or ((121 == char_code))):
                                        prev_replace = token_lower
                                        token_lower = similarWord
                                        self.resolve_similar_word = similarWord
                                        token = token_lower
                                        dictIdx = nlDict.findWord(token)
                                        newline_needed = True
                                        break
                                    elif ((78 == char_code) or ((110 == char_code))):
                                        no_replace = token_lower
                                        newline_needed = True
                                        break
                            elif (token_lower == prev_replace):
                                token_lower = similarWord
                                token = token_lower
                                dictIdx = nlDict.findWord(token)
                            if newline_needed:
                                forGL_ForGL_ui.msg("\n")
                                lines_added = (lines_added + 1)
                if (0 <= dictIdx):
                    type_found = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_type
                    ri.resolve_str = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str
                    ri.resolve_float = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float
                    ri.resolve_int = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int
                    ri.resolve_op_meaning = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_op_means
                    ri.resolve_token_noun_data = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data
                    ri.resolve_use_out = True
                    ri.resolve_out_token = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).internal_token
                    if (16 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 18
                    elif (17 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 19
                    elif (20 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 22
                    elif (21 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 23
                    elif (24 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 26
                    elif (25 == ri.resolve_op_meaning):
                        ri.resolve_op_meaning = 27
                a_token.internal_token = token
                a_token.visible_token = token
                a_token.verbose_phrase = token
                a_token.token_str = ""
                a_token.token_type = type_found
                a_token.token_noun_data = 0
                a_token.token_float = 0.0
                a_token.token_int = 0
                a_token.token_op_means = 0
                if (type_found == 9):
                    a_token.token_int = ri.resolve_int
                elif (type_found == 10):
                    a_token.token_int = ri.resolve_int
                elif (type_found == 2):
                    a_token.token_op_means = ri.resolve_op_meaning
                    if (((18 == a_token.token_op_means) or ((22 == a_token.token_op_means))) or ((26 == a_token.token_op_means))):
                        _hx_local_1 = self
                        _hx_local_2 = _hx_local_1.left_groups
                        _hx_local_1.left_groups = (_hx_local_2 + 1)
                        _hx_local_2
                    elif (((19 == a_token.token_op_means) or ((23 == a_token.token_op_means))) or ((27 == a_token.token_op_means))):
                        _hx_local_3 = self
                        _hx_local_4 = _hx_local_3.right_groups
                        _hx_local_3.right_groups = (_hx_local_4 + 1)
                        _hx_local_4
                elif (type_found == 6):
                    a_token.token_noun_data = ri.resolve_token_noun_data
                    if (9 == ri.resolve_token_noun_data):
                        a_token.token_int = ri.resolve_int
                    elif (10 == ri.resolve_token_noun_data):
                        a_token.token_int = ri.resolve_int
                    elif (11 == ri.resolve_token_noun_data):
                        a_token.token_float = ri.resolve_float
                    elif (8 == ri.resolve_token_noun_data):
                        a_token.token_str = ri.resolve_str
                    else:
                        forGL_ForGL_ui.msg((("INTERNAL ERROR: Strange value for  resolve_token_noun_data : " + Std.string(ri.resolve_token_noun_data)) + "\n"))
                        lines_added = (lines_added + 1)
                elif (type_found == 11):
                    a_token.token_float = ri.resolve_float
                elif (type_found == 8):
                    a_token.token_str = ri.resolve_str
                elif (type_found == 4):
                    a_token.token_str = ri.resolve_str
                if ri.resolve_use_out:
                    a_token.internal_token = ri.resolve_out_token
                if (("repeat" == a_token.internal_token) and ((3 == a_token.token_type))):
                    self.repeat_verb_found = True
                x = forGL_NLToken(a_token.internal_token,a_token.visible_token,a_token.verbose_phrase,a_token.token_str,a_token.token_float,a_token.token_type,a_token.token_noun_data,a_token.token_int,a_token.token_op_means)
                runStack.append(x)
                prev_internal_token = a_token.internal_token
                i = (i + 1)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in Parse.resolveTokens(): " + Std.string(e)) + " \n"))
            lines_added = (lines_added + 1)
        return lines_added

    def resolveAssigns(self,runStack):
        i = 0
        assignment_count = 0
        statement_start = 0
        statement_end = -1
        assign_pos = -1
        while (i < len(runStack)):
            if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                op_found = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                if (26 == op_found):
                    statement_start = (i + 1)
                    i = (i + 1)
                    continue
                if (((((45 == op_found) or ((46 == op_found))) or ((47 == op_found))) or ((48 == op_found))) or ((27 == op_found))):
                    statement_end = i
                    if (-1 == assign_pos):
                        statement_start = (statement_end + 1)
                        statement_end = -1
                        i = (i + 1)
                        continue
                    elif (assign_pos == statement_start):
                        (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                        (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                        assign_pos = -1
                        statement_start = (statement_end + 1)
                        statement_end = -1
                        i = (i + 1)
                        continue
                    left_count = (assign_pos - statement_start)
                    right_count = ((statement_end - assign_pos) - 1)
                    if ((1 == left_count) and ((1 == right_count))):
                        left_type = python_internal_ArrayImpl._get(runStack, (assign_pos - 1)).token_type
                        right_type = python_internal_ArrayImpl._get(runStack, (assign_pos + 1)).token_type
                        if ((((8 == left_type) or ((9 == left_type))) or ((10 == left_type))) or ((11 == left_type))):
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                        elif ((((8 == right_type) or ((9 == right_type))) or ((10 == right_type))) or ((11 == right_type))):
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 34
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(34,True)
                    elif ((left_count != right_count) and (((1 == left_count) or ((1 == right_count))))):
                        if (1 == left_count):
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 34
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(34,True)
                        else:
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).token_op_means = 33
                            (runStack[assign_pos] if assign_pos >= 0 and assign_pos < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(33,True)
                    assign_pos = -1
                    statement_start = (statement_end + 1)
                    statement_end = -1
                elif (32 == op_found):
                    assignment_count = (assignment_count + 1)
                    assign_pos = i
            i = (i + 1)

    def refactorForExport(self,runStack):
        retArray = list()
        i = 0
        into_assignment_count = 0
        assignment_count = 0
        changes_done = False
        while (i < len(runStack)):
            if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                op_found = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                if (((45 == op_found) or ((46 == op_found))) or ((47 == op_found))):
                    (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means = 48
                    (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token = forGL_MeansWhat.opMeanAsStr(48,True)
                    (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                    changes_done = True
                if (33 == op_found):
                    into_assignment_count = (into_assignment_count + 1)
                if (32 == op_found):
                    assignment_count = (assignment_count + 1)
            i = (i + 1)
        if ((0 < into_assignment_count) or ((0 < assignment_count))):
            added_count = 0
            statement_start = 0
            statement_end = 0
            assign_pos = -1
            assign_type = 0
            i = 0
            while (i < len(runStack)):
                if (2 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                    op_found = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                    if ((48 == op_found) or ((27 == op_found))):
                        insert_semicolon = False
                        if (27 == op_found):
                            insert_semicolon = True
                        statement_end = i
                        j = statement_start
                        if (((assign_pos < 0) or ((34 == assign_type))) or ((assign_pos == statement_start))):
                            while (j <= statement_end):
                                x = forGL_NLToken("","","","",0.0,0,0,0,0)
                                retArray.append(x)
                                idx = (len(retArray) - 1)
                                if ((j == statement_end) and insert_semicolon):
                                    added_count = (added_count + 1)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = 2
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = forGL_MeansWhat.opMeanAsStr(48,True)
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = 0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = ""
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = 0.0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = 0
                                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = 48
                                    x1 = forGL_NLToken("","","","",0.0,0,0,0,0)
                                    retArray.append(x1)
                                    idx = (len(retArray) - 1)
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            statement_start = (statement_end + 1)
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                        else:
                            j = (assign_pos + 1)
                            while (j < statement_end):
                                x2 = forGL_NLToken("","","","",0.0,0,0,0,0)
                                retArray.append(x2)
                                idx1 = (len(retArray) - 1)
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx1] if idx1 >= 0 and idx1 < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            x3 = forGL_NLToken("","","","",0.0,0,0,0,0)
                            retArray.append(x3)
                            idx2 = (len(retArray) - 1)
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(34,True)
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_type = 2
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).internal_token = (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).visible_token
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_noun_data = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_str = ""
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_float = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_int = 0
                            (retArray[idx2] if idx2 >= 0 and idx2 < len(retArray) else None).token_op_means = 34
                            j = statement_start
                            while (j < assign_pos):
                                x4 = forGL_NLToken("","","","",0.0,0,0,0,0)
                                retArray.append(x4)
                                idx3 = (len(retArray) - 1)
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                                (retArray[idx3] if idx3 >= 0 and idx3 < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                                j = (j + 1)
                            x5 = forGL_NLToken("","","","",0.0,0,0,0,0)
                            retArray.append(x5)
                            idx4 = (len(retArray) - 1)
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_type = 2
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).internal_token = (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_noun_data = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_str = ""
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_float = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_int = 0
                            (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_op_means = 48
                            if insert_semicolon:
                                added_count = (added_count + 1)
                                x6 = forGL_NLToken("","","","",0.0,0,0,0,0)
                                retArray.append(x6)
                                idx4 = (len(retArray) - 1)
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(27,True)
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_type = 2
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).internal_token = (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).visible_token
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_noun_data = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_str = ""
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_float = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_int = 0
                                (retArray[idx4] if idx4 >= 0 and idx4 < len(retArray) else None).token_op_means = 27
                            statement_start = (statement_end + 1)
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                    elif (((32 == op_found) or ((33 == op_found))) or ((34 == op_found))):
                        if ((33 == op_found) and ((i == statement_start))):
                            assign_pos = -1
                            assign_type = 0
                            i = (i + 1)
                            continue
                        assign_pos = i
                        assign_type = op_found
                    elif (("{" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) or (("}" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))):
                        x7 = forGL_NLToken("","","","",0.0,0,0,0,0)
                        retArray.append(x7)
                        idx5 = (len(retArray) - 1)
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).visible_token = (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_type = (runStack[i] if i >= 0 and i < len(runStack) else None).token_type
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).internal_token = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_noun_data = (runStack[i] if i >= 0 and i < len(runStack) else None).token_noun_data
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_str = (runStack[i] if i >= 0 and i < len(runStack) else None).token_str
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_float = (runStack[i] if i >= 0 and i < len(runStack) else None).token_float
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_int = (runStack[i] if i >= 0 and i < len(runStack) else None).token_int
                        (retArray[idx5] if idx5 >= 0 and idx5 < len(retArray) else None).token_op_means = (runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means
                        statement_start = (i + 1)
                elif (13 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_type):
                    if (((("for" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) or (("if" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))) or (("switch" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))) or (("while" == (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token))):
                        j1 = i
                        while (j1 < len(runStack)):
                            x8 = forGL_NLToken("","","","",0.0,0,0,0,0)
                            retArray.append(x8)
                            idx6 = (len(retArray) - 1)
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).visible_token = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).visible_token
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_type = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_type
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).internal_token = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).internal_token
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_noun_data = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_noun_data
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_str = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_str
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_float = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_float
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_int = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_int
                            (retArray[idx6] if idx6 >= 0 and idx6 < len(retArray) else None).token_op_means = (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).token_op_means
                            if (")" == (runStack[j1] if j1 >= 0 and j1 < len(runStack) else None).internal_token):
                                statement_start = (j1 + 1)
                                break
                            j1 = (j1 + 1)
                        i = (j1 + 1)
                        continue
                i = (i + 1)
            if ((len(retArray) - added_count) < len(runStack)):
                j = statement_start
                while (j < len(runStack)):
                    x = forGL_NLToken("","","","",0.0,0,0,0,0)
                    retArray.append(x)
                    idx = (len(retArray) - 1)
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = (runStack[j] if j >= 0 and j < len(runStack) else None).visible_token
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = (runStack[j] if j >= 0 and j < len(runStack) else None).token_type
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = (runStack[j] if j >= 0 and j < len(runStack) else None).internal_token
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = (runStack[j] if j >= 0 and j < len(runStack) else None).token_noun_data
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = (runStack[j] if j >= 0 and j < len(runStack) else None).token_str
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = (runStack[j] if j >= 0 and j < len(runStack) else None).token_float
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = (runStack[j] if j >= 0 and j < len(runStack) else None).token_int
                    (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = (runStack[j] if j >= 0 and j < len(runStack) else None).token_op_means
                    j = (j + 1)
            if ((forGL_MeansWhat.opMeanAsStr(27,True) != python_internal_ArrayImpl._get(retArray, (len(retArray) - 1)).internal_token) and ((forGL_MeansWhat.opMeanAsStr(48,True) != python_internal_ArrayImpl._get(retArray, (len(retArray) - 1)).internal_token))):
                x = forGL_NLToken("","","","",0.0,0,0,0,0)
                retArray.append(x)
                idx = (len(retArray) - 1)
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token = forGL_MeansWhat.opMeanAsStr(48,True)
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_type = 2
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).internal_token = (retArray[idx] if idx >= 0 and idx < len(retArray) else None).visible_token
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_noun_data = 0
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_str = ""
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_float = 0
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_int = 0
                (retArray[idx] if idx >= 0 and idx < len(retArray) else None).token_op_means = 48
        else:
            retArray = runStack
        return retArray

    def resolveChoice(self,rStack):
        ret_val = 0
        self.resolveChoice_msgs = ""
        is_balanced = False
        choice_found = ""
        end_paren_idx = -1
        end_block_idx = -1
        else_found = False
        else_start = -1
        else_end = -1
        i = 0
        while (i < len(rStack)):
            choice_found = ""
            else_found = False
            if ((((("for" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token) or (("if" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("switch" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("while" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))) or (("return" == (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token))):
                choice_found = (rStack[i] if i >= 0 and i < len(rStack) else None).internal_token
                if ("return" == choice_found):
                    i = (i + 1)
                    continue
            else:
                i = (i + 1)
                continue
            if (not is_balanced):
                if ((self.left_groups != self.right_groups) or ((0 == self.left_groups))):
                    return -4
                is_balanced = True
            if ((len(rStack) - 4) < i):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.resolveChoice_msgs
                _hx_local_2.resolveChoice_msgs = (("null" if _hx_local_3 is None else _hx_local_3) + HxOverrides.stringOrNull(((("SYNTAX ERROR: " + ("null" if choice_found is None else choice_found)) + " missing ( expression ) or statement.\n"))))
                _hx_local_2.resolveChoice_msgs
                return -4
            if ("(" != python_internal_ArrayImpl._get(rStack, (i + 1)).internal_token):
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.resolveChoice_msgs
                _hx_local_4.resolveChoice_msgs = (("null" if _hx_local_5 is None else _hx_local_5) + HxOverrides.stringOrNull(((("SYNTAX ERROR: " + ("null" if choice_found is None else choice_found)) + " ( expression ) not next.\n"))))
                _hx_local_4.resolveChoice_msgs
                return -4
            left_parens = 0
            right_parens = 0
            p = (i + 2)
            while (p < len(rStack)):
                if (")" == (rStack[p] if p >= 0 and p < len(rStack) else None).internal_token):
                    if (left_parens == right_parens):
                        break
                    right_parens = (right_parens + 1)
                elif ("(" == (rStack[p] if p >= 0 and p < len(rStack) else None).internal_token):
                    left_parens = (left_parens + 1)
                p = (p + 1)
            if ((len(rStack) - 2) < p):
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.resolveChoice_msgs
                _hx_local_9.resolveChoice_msgs = (("null" if _hx_local_10 is None else _hx_local_10) + HxOverrides.stringOrNull(((("SYNTAX ERROR: No statement after " + ("null" if choice_found is None else choice_found)) + " expression.\n"))))
                _hx_local_9.resolveChoice_msgs
                return -4
            end_paren_idx = p
            b = (p + 1)
            e = -1
            if ("{" != (rStack[b] if b >= 0 and b < len(rStack) else None).internal_token):
                if ("switch" == choice_found):
                    _hx_local_11 = self
                    _hx_local_12 = _hx_local_11.resolveChoice_msgs
                    _hx_local_11.resolveChoice_msgs = (("null" if _hx_local_12 is None else _hx_local_12) + "SYNTAX ERROR: Single statement not allowed for switch.\n")
                    _hx_local_11.resolveChoice_msgs
                    return -4
                while (b < len(rStack)):
                    if (2 == (rStack[b] if b >= 0 and b < len(rStack) else None).token_type):
                        op_to_do = (rStack[b] if b >= 0 and b < len(rStack) else None).token_op_means
                        if ((((45 == op_to_do) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                            break
                    b = (b + 1)
            else:
                while (b < len(rStack)):
                    if ("}" == (rStack[b] if b >= 0 and b < len(rStack) else None).internal_token):
                        break
                    b = (b + 1)
                if ((("if" == choice_found) and ((b < ((len(rStack) - 3))))) and (("else" == python_internal_ArrayImpl._get(rStack, (b + 1)).internal_token))):
                    if ("{" == python_internal_ArrayImpl._get(rStack, (b + 2)).internal_token):
                        else_start = (b + 2)
                        else_end = (b + 3)
                        while (else_end < len(rStack)):
                            if ("}" == (rStack[else_end] if else_end >= 0 and else_end < len(rStack) else None).internal_token):
                                else_found = True
                                break
                            else_end = (else_end + 1)
            if (len(rStack) <= b):
                b = (len(rStack) - 1)
            end_block_idx = b
            (rStack[i] if i >= 0 and i < len(rStack) else None).token_int = end_paren_idx
            (rStack[i] if i >= 0 and i < len(rStack) else None).token_float = end_block_idx
            if (("if" == choice_found) and else_found):
                (rStack[end_block_idx] if end_block_idx >= 0 and end_block_idx < len(rStack) else None).token_float = ((else_end - end_block_idx) + 1)
            (rStack[end_paren_idx] if end_paren_idx >= 0 and end_paren_idx < len(rStack) else None).token_int = (i + 1)
            if (("for" == choice_found) or (("while" == choice_found))):
                (rStack[end_block_idx] if end_block_idx >= 0 and end_block_idx < len(rStack) else None).token_int = (i + 1)
            i = (end_paren_idx + 1)
        return ret_val

    def saveNounValues(self,nlDict,runStack,nouns):
        num_saved = 0
        self.saveNounValues_errors = ""
        i = 0
        while (i < len(nouns)):
            runIdx = (nouns[i] if i >= 0 and i < len(nouns) else None)
            if (6 != (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_type):
                i = (i + 1)
                continue
            dictIdx = nlDict.findWord((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)
            if (0 <= dictIdx):
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_noun_data
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_str
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_float
                (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int = (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_int
                num_saved = (num_saved + 1)
            else:
                err_msg = (("ERROR not Saving: Noun " + Std.string((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)) + " not in dictionary.\n")
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.saveNounValues_errors
                _hx_local_2.saveNounValues_errors = (Std.string(_hx_local_3) + ("null" if err_msg is None else err_msg))
                _hx_local_2.saveNounValues_errors
            i = (i + 1)
        return num_saved

    def updateNounValues(self,nlDict,runStack,nouns,lastOnly = None):
        if (lastOnly is None):
            lastOnly = False
        num_updated = 0
        self.updateNounValues_errors = ""
        i = 0
        if lastOnly:
            i = (len(nouns) - 1)
        while (i < len(nouns)):
            runIdx = (nouns[i] if i >= 0 and i < len(nouns) else None)
            if (6 != (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_type):
                i = (i + 1)
                continue
            dictIdx = nlDict.findWord((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)
            if (0 <= dictIdx):
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_noun_data = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_noun_data
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_str = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_str
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_float = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_float
                (runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).token_int = (nlDict.unique_Dictionary_Words[dictIdx] if dictIdx >= 0 and dictIdx < len(nlDict.unique_Dictionary_Words) else None).token_int
                num_updated = (num_updated + 1)
            else:
                err_msg = (("ERROR not Updating: Noun " + Std.string((runStack[runIdx] if runIdx >= 0 and runIdx < len(runStack) else None).visible_token)) + " not in dictionary.\n")
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.updateNounValues_errors
                _hx_local_2.updateNounValues_errors = (Std.string(_hx_local_3) + ("null" if err_msg is None else err_msg))
                _hx_local_2.updateNounValues_errors
            i = (i + 1)
        return num_updated

    def showWordsTable(self,runStack,show_words = None,show_index = None,text_str = None):
        if (show_words is None):
            show_words = True
        if (show_index is None):
            show_index = False
        if (text_str is None):
            text_str = False
        self.words_table_text = ""
        lines_added = 0
        msg_text = ""
        _hx_len = len(runStack)
        if (0 < _hx_len):
            return lines_added
        msg_text = (("\n\t\t\t" + Std.string(_hx_len)) + "  Words")
        if show_words:
            forGL_ForGL_ui.msg(msg_text)
        if text_str:
            self.words_table_text = msg_text
        if show_words:
            lines_added = (lines_added + 2)
        if show_index:
            msg_text = (("  [ 0 to " + Std.string((_hx_len - 1))) + " ]\n")
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.words_table_text
                _hx_local_1.words_table_text = (("null" if _hx_local_2 is None else _hx_local_2) + ("null" if msg_text is None else msg_text))
                _hx_local_1.words_table_text
            msg_text = "Index                 Internal           Word     Verb  or  Noun  Details ...\n"
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.words_table_text
                _hx_local_3.words_table_text = (("null" if _hx_local_4 is None else _hx_local_4) + ("null" if msg_text is None else msg_text))
                _hx_local_3.words_table_text
            if show_words:
                lines_added = (lines_added + 1)
            msg_text = "        Name            Name             Type     string, float, integer or bool"
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.words_table_text
                _hx_local_6.words_table_text = (("null" if _hx_local_7 is None else _hx_local_7) + ("null" if msg_text is None else msg_text))
                _hx_local_6.words_table_text
        else:
            msg_text = "\n              Internal           Word     Verb  or  Noun  Details ...\n"
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.words_table_text
                _hx_local_8.words_table_text = (("null" if _hx_local_9 is None else _hx_local_9) + ("null" if msg_text is None else msg_text))
                _hx_local_8.words_table_text
            if show_words:
                lines_added = (lines_added + 1)
            msg_text = "Name            Name             Type     string, float, integer or bool\n"
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.words_table_text
                _hx_local_11.words_table_text = (("null" if _hx_local_12 is None else _hx_local_12) + ("null" if msg_text is None else msg_text))
                _hx_local_11.words_table_text
        if show_words:
            lines_added = (lines_added + 1)
        msg_text = "--------------------------------------------------------------------------------"
        if show_words:
            forGL_ForGL_ui.msg(msg_text)
        if text_str:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.words_table_text
            _hx_local_14.words_table_text = (("null" if _hx_local_15 is None else _hx_local_15) + HxOverrides.stringOrNull(((("null" if msg_text is None else msg_text) + "\n"))))
            _hx_local_14.words_table_text
        if show_words:
            lines_added = (lines_added + 1)
        used_inference = False
        i = 0
        while (i < _hx_len):
            if show_index:
                msg_text = (("[" + Std.string(i)) + "]\t")
                if show_words:
                    forGL_ForGL_ui.msg(msg_text)
                if text_str:
                    _hx_local_17 = self
                    _hx_local_18 = _hx_local_17.words_table_text
                    _hx_local_17.words_table_text = (("null" if _hx_local_18 is None else _hx_local_18) + ("null" if msg_text is None else msg_text))
                    _hx_local_17.words_table_text
            used_inference = False
            nl_type = (runStack[i] if i >= 0 and i < len(runStack) else None).token_type
            if (0 == nl_type):
                used_inference = True
                nl_type = 7
            type_color = forGL_ForGL_ui.getTypeColor(nl_type)
            msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).visible_token) + "\t\t")
            _hx_str = (runStack[i] if i >= 0 and i < len(runStack) else None).visible_token
            if (((0 if ((_hx_str is None)) else len(_hx_str))) >= 8):
                msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).visible_token) + "\t")
            if show_words:
                forGL_ForGL_ui.msg(msg_text,type_color)
            if text_str:
                _hx_local_19 = self
                _hx_local_20 = _hx_local_19.words_table_text
                _hx_local_19.words_table_text = (("null" if _hx_local_20 is None else _hx_local_20) + ("null" if msg_text is None else msg_text))
                _hx_local_19.words_table_text
            msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) + "\t\t")
            str1 = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
            if (((0 if ((str1 is None)) else len(str1))) >= 8):
                msg_text = (Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).internal_token) + "\t")
            if show_words:
                forGL_ForGL_ui.msg(msg_text,type_color)
            if text_str:
                _hx_local_21 = self
                _hx_local_22 = _hx_local_21.words_table_text
                _hx_local_21.words_table_text = (("null" if _hx_local_22 is None else _hx_local_22) + ("null" if msg_text is None else msg_text))
                _hx_local_21.words_table_text
            nl_type_text = (HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(nl_type)) + "\t")
            nl_type_text_more = ""
            msg_text = nl_type_text
            type_unknown_error = False
            nl_type1 = nl_type
            if (nl_type1 == 0):
                err_str = ("INTERNAL LOGIC ERROR: Unknown type not resolved, Name: " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).visible_token))
                this1 = (runStack[i] if i >= 0 and i < len(runStack) else None).internal_token
                if (0 < ((0 if ((this1 is None)) else len(this1)))):
                    err_str = (Std.string(err_str) + HxOverrides.stringOrNull(((" Internal name is " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).internal_token)))))
                forGL_ForGL_ui.error(err_str,1)
                if show_words:
                    forGL_ForGL_ui.msg(msg_text,1)
                _hx_local_24 = self
                _hx_local_25 = _hx_local_24.words_table_text
                _hx_local_24.words_table_text = (("null" if _hx_local_25 is None else _hx_local_25) + Std.string(err_str))
                _hx_local_24.words_table_text
                type_unknown_error = True
            elif (nl_type1 == 1):
                nl_type_text_more = (runStack[i] if i >= 0 and i < len(runStack) else None).token_str
            elif (nl_type1 == 2):
                msg_text = forGL_MeansWhat.opMeanAsStr((runStack[i] if i >= 0 and i < len(runStack) else None).token_op_means)
            elif (nl_type1 == 3):
                pass
            elif (nl_type1 == 4):
                nl_type_text_more = (" " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_str))
            elif (nl_type1 == 5):
                pass
            elif (nl_type1 == 6):
                pass
            elif (nl_type1 == 7):
                pass
            elif (nl_type1 == 8):
                nl_type_text_more = (" " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_str))
            elif (nl_type1 == 9):
                nl_type_text_more = (" " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_int))
            elif (nl_type1 == 10):
                if (1 == (runStack[i] if i >= 0 and i < len(runStack) else None).token_int):
                    nl_type_text_more = "true"
                else:
                    nl_type_text_more = "false"
            elif (nl_type1 == 11):
                nl_type_text_more = (" " + Std.string((runStack[i] if i >= 0 and i < len(runStack) else None).token_float))
            elif (nl_type1 == 12):
                pass
            elif (nl_type1 == 13):
                pass
            else:
                pass
            if (0 < len(nl_type_text_more)):
                msg_text = (("null" if msg_text is None else msg_text) + ("null" if nl_type_text_more is None else nl_type_text_more))
            msg_text = (("null" if msg_text is None else msg_text) + "\n")
            lines_added = (lines_added + 1)
            if show_words:
                forGL_ForGL_ui.msg(msg_text)
            if text_str:
                _hx_local_29 = self
                _hx_local_30 = _hx_local_29.words_table_text
                _hx_local_29.words_table_text = (("null" if _hx_local_30 is None else _hx_local_30) + ("null" if msg_text is None else msg_text))
                _hx_local_29.words_table_text
            i = (i + 1)
        return lines_added

    def cleanUp(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.parse_text_lines_added = None
        _hx_o.resolve_similar_word = None
        _hx_o.left_groups = None
        _hx_o.right_groups = None
        _hx_o.repeat_verb_found = None
        _hx_o.resolveChoice_msgs = None
        _hx_o.saveNounValues_errors = None
        _hx_o.updateNounValues_errors = None
        _hx_o.words_table_text = None


class forGL_DataItem:
    _hx_class_name = "forGL.DataItem"
    __slots__ = ("data_float", "data_type", "data_int", "data_str")
    _hx_fields = ["data_float", "data_type", "data_int", "data_str"]
    _hx_methods = ["toStr"]

    def __init__(self,_hx_type,_hx_str,_hx_float,_hx_int):
        self.data_type = _hx_type
        self.data_str = _hx_str
        self.data_float = _hx_float
        self.data_int = _hx_int

    def toStr(self):
        ret_val = self.data_str
        if (11 == self.data_type):
            ret_val = Std.string(self.data_float)
        if (9 == self.data_type):
            ret_val = Std.string(self.data_int)
        if (10 == self.data_type):
            if (1 == self.data_int):
                ret_val = "True"
            else:
                ret_val = "False"
        return ret_val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data_float = None
        _hx_o.data_type = None
        _hx_o.data_int = None
        _hx_o.data_str = None


class forGL_TypedTokens:
    _hx_class_name = "forGL.TypedTokens"
    __slots__ = ("token_type", "token_name")
    _hx_fields = ["token_type", "token_name"]

    def __init__(self,_hx_type,name):
        self.token_type = _hx_type
        self.token_name = name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.token_type = None
        _hx_o.token_name = None


class forGL_ForGL_Run:
    _hx_class_name = "forGL.ForGL_Run"
    __slots__ = ("run_text_line", "export_as_code", "export_as_code_log", "export_as_code_verb_name", "display_internal", "show_details", "show_words_table", "show_stacks", "show_stacks_Data_Only", "single_step", "delay_seconds_default", "delay_seconds", "nlDict", "stdin", "run_verbose", "ForGLData", "nl_Import_used", "nl_Import", "nl_Parse", "in_dictionary_file_name", "use_Built_In_Dictionary", "out_dictionary_file_name", "dataOpNoun_text_line", "steps_done", "steps_done_Verb", "intp_ip", "old_dataStackFrames", "old_dataStack", "old_opStackFrames", "old_opStack", "old_nounStackFrames", "old_nounStack", "old_assignStackFrames", "old_assignStack", "elapsed_intp_time", "user_def", "forgl_ver_major", "forgl_ver_minor", "forgl_ver_build", "forgl_ver_stability", "forgl_version", "prev_dataStackOut", "prev_opStackOut", "prev_nounStackOut", "prev_callStackOut", "view_DON_throttle", "last_view_DON_time", "prev_show1_data", "argsOrData_list", "start_session_time", "total_intp_time", "verb_to_run", "runStack", "dataStack", "opStack", "nouns", "callStack", "exportStack", "assignStack", "repeat_found", "repeat_count", "repeat_limit", "repeat_limit_found", "show_text_line", "start_intp_time", "intp_return_result")
    _hx_fields = ["run_text_line", "export_as_code", "export_as_code_log", "export_as_code_verb_name", "display_internal", "show_details", "show_words_table", "show_stacks", "show_stacks_Data_Only", "single_step", "delay_seconds_default", "delay_seconds", "nlDict", "stdin", "run_verbose", "ForGLData", "nl_Import_used", "nl_Import", "nl_Parse", "in_dictionary_file_name", "use_Built_In_Dictionary", "out_dictionary_file_name", "dataOpNoun_text_line", "steps_done", "steps_done_Verb", "intp_ip", "old_dataStackFrames", "old_dataStack", "old_opStackFrames", "old_opStack", "old_nounStackFrames", "old_nounStack", "old_assignStackFrames", "old_assignStack", "elapsed_intp_time", "user_def", "forgl_ver_major", "forgl_ver_minor", "forgl_ver_build", "forgl_ver_stability", "forgl_version", "prev_dataStackOut", "prev_opStackOut", "prev_nounStackOut", "prev_callStackOut", "view_DON_throttle", "last_view_DON_time", "prev_show1_data", "argsOrData_list", "start_session_time", "total_intp_time", "verb_to_run", "runStack", "dataStack", "opStack", "nouns", "callStack", "exportStack", "assignStack", "repeat_found", "repeat_count", "repeat_limit", "repeat_limit_found", "show_text_line", "start_intp_time", "intp_return_result"]
    _hx_methods = ["init", "cleanUp", "dataStackToString", "opStackToString", "nounStackToString", "dataStackOut", "viewDataOpNouns", "show1Data", "viewRepeatCount", "runAssignment", "addQuotes", "trimQuotes", "addName", "argsOrData_Str", "arrToStrSep", "argsOrData", "runMath1Data", "runStr2Data", "runMath2Data", "runOperators", "run", "runDef", "runDef_End", "runInterpreter"]

    def __init__(self):
        self.assignStack = None
        self.exportStack = None
        self.callStack = None
        self.nouns = None
        self.opStack = None
        self.dataStack = None
        self.runStack = None
        self.argsOrData_list = None
        self.nl_Parse = None
        self.nl_Import = None
        self.ForGLData = None
        self.nlDict = None
        self.intp_return_result = 0
        self.start_intp_time = 0.0
        self.show_text_line = 0
        self.repeat_limit_found = False
        self.repeat_limit = -1
        self.repeat_count = 0
        self.repeat_found = False
        self.verb_to_run = "15 test_factorial"
        self.total_intp_time = 0.0
        self.start_session_time = 0.0
        self.prev_show1_data = ""
        self.last_view_DON_time = 0.0
        self.view_DON_throttle = False
        self.prev_callStackOut = ""
        self.prev_nounStackOut = ""
        self.prev_opStackOut = ""
        self.prev_dataStackOut = ""
        self.forgl_version = ""
        self.forgl_ver_stability = "Prototype"
        self.forgl_ver_build = "3"
        self.forgl_ver_minor = "0"
        self.forgl_ver_major = "0"
        self.user_def = ""
        self.elapsed_intp_time = 0.0
        self.old_assignStack = list()
        self.old_assignStackFrames = list()
        self.old_nounStack = list()
        self.old_nounStackFrames = list()
        self.old_opStack = list()
        self.old_opStackFrames = list()
        self.old_dataStack = list()
        self.old_dataStackFrames = list()
        self.intp_ip = 0
        self.steps_done_Verb = 0
        self.steps_done = 0
        self.dataOpNoun_text_line = 0
        self.out_dictionary_file_name = ""
        self.use_Built_In_Dictionary = False
        self.in_dictionary_file_name = ""
        self.nl_Import_used = False
        self.run_verbose = False
        self.stdin = Sys.stdin()
        self.delay_seconds = 1.0
        self.delay_seconds_default = 1.0
        self.single_step = True
        self.show_stacks_Data_Only = False
        self.show_stacks = True
        self.show_words_table = True
        self.show_details = False
        self.display_internal = False
        self.export_as_code_verb_name = ""
        self.export_as_code_log = list()
        self.export_as_code = False
        self.run_text_line = 0
        self.forgl_version = ((((((("v" + HxOverrides.stringOrNull(self.forgl_ver_major)) + ".") + HxOverrides.stringOrNull(self.forgl_ver_minor)) + ".") + HxOverrides.stringOrNull(self.forgl_ver_build)) + " ") + HxOverrides.stringOrNull(self.forgl_ver_stability))

    def init(self,in_dict_name,lines_added,verbose = None):
        if (verbose is None):
            verbose = False
        ret_val = 0
        try:
            lines_added = 0
            self.run_verbose = verbose
            self.ForGLData = forGL_data_ForGL_data()
            self.in_dictionary_file_name = in_dict_name
            if (0 < len(self.in_dictionary_file_name)):
                init_result = self.ForGLData.init(self.in_dictionary_file_name,2)
                self.in_dictionary_file_name = self.ForGLData.actual_path_file
                def _hx_local_1():
                    _hx_local_0 = init_result
                    if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                if (_hx_local_1() < 0):
                    forGL_ForGL_ui.error((("\n    SEVERE ERROR  " + Std.string(forGL_MeansWhat.returnMeanAsStr(init_result))) + " trying to Initialize the Data service.  Stopping."))
                    lines_added = (lines_added + 1)
                    ret_val = init_result
                    self.in_dictionary_file_name = ""
                    return ret_val
            self.nlDict = forGL_NLDictionary()
            dict_result = self.nlDict.init(self.in_dictionary_file_name)
            self.use_Built_In_Dictionary = self.nlDict.use_Built_In_Dictionary
            def _hx_local_4():
                _hx_local_3 = dict_result
                if (Std.isOfType(_hx_local_3,Int) or ((_hx_local_3 is None))):
                    _hx_local_3
                else:
                    raise "Class cast error"
                return _hx_local_3
            if (0 != _hx_local_4()):
                ret_val = dict_result
            else:
                lines_added = (lines_added + 1)
                lines_added = (lines_added + 1)
                lines_added = (lines_added + 1)
                if (0 < len(self.in_dictionary_file_name)):
                    self.nl_Import = forGL_NLImport()
                    import_result = self.nl_Import.importWords(self.ForGLData,self.nlDict,self.in_dictionary_file_name)
                    this1 = self.nl_Import.importWords_msgs
                    if (0 < ((0 if ((this1 is None)) else len(this1)))):
                        if verbose:
                            forGL_ForGL_ui.status(self.nl_Import.importWords_msgs)
                        lines_added = (lines_added + 1)
                        lines_added = (lines_added + 1)
                        lines_added = (lines_added + 1)
                    ret_val = import_result
                else:
                    forGL_ForGL_ui.status("No Dictionary name given so no Import of word(s).",3,False,True)
            def _hx_local_12():
                _hx_local_11 = ret_val
                if (Std.isOfType(_hx_local_11,Int) or ((_hx_local_11 is None))):
                    _hx_local_11
                else:
                    raise "Class cast error"
                return _hx_local_11
            if (0 == _hx_local_12()):
                self.nl_Parse = forGL_Parse()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in forGL_run.init(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def cleanUp(self):
        self.ForGLData.cleanUp()
        self.nlDict.cleanUp()
        if self.nl_Import_used:
            self.nl_Import.cleanUp()
            self.nl_Import_used = False

    def dataStackToString(self,dStack):
        if ((0 == len(dStack)) and ((0 == len(self.old_dataStack)))):
            return "[]"
        result = "["
        i = 0
        if (0 < len(self.old_dataStack)):
            while (i < len(self.old_dataStack)):
                result = (Std.string(result) + " ")
                if (9 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = (Std.string(result) + Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_int))
                elif (10 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    if (1 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_int):
                        result = (Std.string(result) + "true")
                    else:
                        result = (Std.string(result) + "false")
                elif (11 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = (Std.string(result) + Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_float))
                elif (8 == (self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_type):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((self.old_dataStack[i] if i >= 0 and i < len(self.old_dataStack) else None).data_str))
                else:
                    forGL_ForGL_ui.error("INTERNAL ERROR: Some other data type in the Data stack. \n")
                    result = (Std.string(result) + "'?'")
                result = (Std.string(result) + " ")
                i = (i + 1)
            result = (Std.string(result) + ":")
            i = 0
        while (i < len(dStack)):
            result = (Std.string(result) + " ")
            if (9 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = (Std.string(result) + Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_int))
            elif (10 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                if (1 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_int):
                    result = (Std.string(result) + "true")
                else:
                    result = (Std.string(result) + "false")
            elif (11 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = (Std.string(result) + Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_float))
            elif (8 == (dStack[i] if i >= 0 and i < len(dStack) else None).data_type):
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((dStack[i] if i >= 0 and i < len(dStack) else None).data_str))
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Some other data type in the Data stack. \n")
                result = (Std.string(result) + "'?'")
            result = (Std.string(result) + " ")
            i = (i + 1)
        result = (Std.string(result) + "]")
        return result

    def opStackToString(self,rStack,oStack):
        if ((0 == len(oStack)) and ((0 == len(self.old_opStack)))):
            return "[]"
        result = "["
        i = 0
        result = "["
        if (0 < len(self.old_opStack)):
            while (i < len(self.old_opStack)):
                result = (Std.string(result) + " ")
                rIdx = (self.old_opStack[i] if i >= 0 and i < len(self.old_opStack) else None)
                if self.display_internal:
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).internal_token))
                else:
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).visible_token))
                result = (Std.string(result) + " ")
                i = (i + 1)
            result = (Std.string(result) + ":")
            i = 0
        while (i < len(oStack)):
            result = (Std.string(result) + " ")
            rIdx = (oStack[i] if i >= 0 and i < len(oStack) else None)
            if self.display_internal:
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).internal_token))
            else:
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).visible_token))
            result = (Std.string(result) + " ")
            i = (i + 1)
        result = (Std.string(result) + "]")
        return result

    def nounStackToString(self,rStack,nStack):
        if (0 == len(nStack)):
            return "[]"
        result = "["
        i = 0
        while (i < len(nStack)):
            rIdx = (nStack[i] if i >= 0 and i < len(nStack) else None)
            if self.display_internal:
                result = (("null" if result is None else result) + HxOverrides.stringOrNull((((" (" + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).internal_token)) + ")"))))
            else:
                result = (("null" if result is None else result) + HxOverrides.stringOrNull((((" (" + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).visible_token)) + ")"))))
            if (9 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_int))
            elif (10 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                if (1 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_int):
                    result = (("null" if result is None else result) + "true")
                else:
                    result = (("null" if result is None else result) + "false")
            elif (11 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_float))
            elif (8 == (rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_noun_data):
                result = (("null" if result is None else result) + Std.string((rStack[rIdx] if rIdx >= 0 and rIdx < len(rStack) else None).token_str))
            result = (("null" if result is None else result) + " ")
            i = (i + 1)
        result = (("null" if result is None else result) + "]")
        return result

    def dataStackOut(self,dStack):
        lines_added = 0
        out = self.dataStackToString(dStack)
        if (out != self.prev_dataStackOut):
            forGL_ForGL_ui.setOut(2)
            forGL_ForGL_ui.msg((("Data = " + Std.string(out)) + "\n"))
            forGL_ForGL_ui.setOut()
            self.prev_dataStackOut = out
            lines_added = (lines_added + 1)
        return lines_added

    def viewDataOpNouns(self,rStack,dStack,oStack,nStack,textLine = None,first_time = None):
        if (textLine is None):
            textLine = -1
        if (first_time is None):
            first_time = False
        if first_time:
            self.prev_dataStackOut = ""
            self.prev_opStackOut = ""
            self.prev_nounStackOut = ""
            self.last_view_DON_time = (Date.now().date.timestamp() * 1000)
        elif self.view_DON_throttle:
            time = (Date.now().date.timestamp() * 1000)
            if ((time - self.last_view_DON_time) < 0.2):
                return
            self.last_view_DON_time = time
        color = forGL_ForGL_ui.DEFAULT_COLOR
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            forGL_ForGL_ui.goToPos(textLine,0)
        _hx_str = ("Data  " + Std.string(self.dataStackToString(dStack)))
        if (_hx_str != self.prev_dataStackOut):
            forGL_ForGL_ui.setOut(2)
            color = forGL_ForGL_ui.getTypeColor(8)
            forGL_ForGL_ui.msg(_hx_str,color)
            forGL_ForGL_ui.eraseToLineEnd(len(_hx_str))
            self.prev_dataStackOut = _hx_str
        if (not self.show_stacks_Data_Only):
            _hx_str = ("Ops   " + Std.string(self.opStackToString(rStack,oStack)))
            if (_hx_str != self.prev_opStackOut):
                forGL_ForGL_ui.setOut(3)
                if (0 <= textLine):
                    forGL_ForGL_ui.goToPos((textLine + 1),0)
                else:
                    forGL_ForGL_ui.msg("\n")
                color = forGL_ForGL_ui.getTypeColor(2)
                forGL_ForGL_ui.msg(_hx_str,color)
                forGL_ForGL_ui.eraseToLineEnd(len(_hx_str))
                self.prev_opStackOut = _hx_str
            _hx_str = ("Nouns " + Std.string(self.nounStackToString(rStack,nStack)))
            if (_hx_str != self.prev_nounStackOut):
                forGL_ForGL_ui.setOut(4)
                if (0 <= textLine):
                    forGL_ForGL_ui.goToPos((textLine + 2),0)
                else:
                    forGL_ForGL_ui.msg("\n")
                color = forGL_ForGL_ui.getTypeColor(7)
                forGL_ForGL_ui.msg((("null" if _hx_str is None else _hx_str) + " "),color)
                forGL_ForGL_ui.eraseToLineEnd(len(_hx_str))
                self.prev_nounStackOut = _hx_str
        forGL_ForGL_ui.setOut()
        forGL_ForGL_ui.restorePos()

    def show1Data(self,dataStr,textLine = None):
        if (textLine is None):
            textLine = -1
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            forGL_ForGL_ui.goToPos(textLine,0)
        _hx_str = self.prev_show1_data
        self.prev_show1_data = hx_strings_Strings.insertAt(self.prev_show1_data,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(dataStr))
        forGL_ForGL_ui.setOut(5)
        forGL_ForGL_ui.msg(self.prev_show1_data)
        forGL_ForGL_ui.setOut()
        if (0 <= textLine):
            forGL_ForGL_ui.restorePos()

    def viewRepeatCount(self,repeatCount,textLine = None):
        if (textLine is None):
            textLine = -1
        if (0 <= textLine):
            forGL_ForGL_ui.savePos()
            forGL_ForGL_ui.goToPos(textLine,0)
        forGL_ForGL_ui.msg(Std.string(repeatCount))
        if (0 <= textLine):
            forGL_ForGL_ui.restorePos()

    def runAssignment(self,rStack,dStack,oStack,nStack,assign_op = None,op_idx = None):
        if (assign_op is None):
            assign_op = 32
        if (op_idx is None):
            op_idx = -1
        if ((0 < len(nStack)) and ((0 < len(dStack)))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.steps_done
            _hx_local_0.steps_done = (_hx_local_1 + 1)
            _hx_local_1
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.steps_done_Verb
            _hx_local_2.steps_done_Verb = (_hx_local_3 + 1)
            _hx_local_3
            data_type_OK = True
            nounIdx = python_internal_ArrayImpl._get(nStack, (len(nStack) - 1))
            if (0 <= op_idx):
                noun_name = python_internal_ArrayImpl._get(rStack, (op_idx - 1)).internal_token
                k = 0
                while (k < len(nStack)):
                    if (python_internal_ArrayImpl._get(rStack, (nStack[k] if k >= 0 and k < len(nStack) else None)).internal_token == noun_name):
                        nounIdx = (nStack[k] if k >= 0 and k < len(nStack) else None)
                        break
                    k = (k + 1)
            dataIdx = 0
            dataType = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_type
            data1_str = ""
            data1_name = ""
            if (8 != dataType):
                data1_name = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
            if ((9 == dataType) or ((10 == dataType))):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_int = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int
                data1_str = Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int)
            elif (11 == dataType):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_float = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float
                data1_str = Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float)
            elif (8 == dataType):
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_noun_data = dataType
                (rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_str = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
                data1_str = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
            else:
                forGL_ForGL_ui.error("\n   INTERNAL ERROR: Not valid Data type in the Data Stack\n")
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.run_text_line
                _hx_local_5.run_text_line = (_hx_local_6 + 1)
                _hx_local_6
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.run_text_line
                _hx_local_7.run_text_line = (_hx_local_8 + 1)
                _hx_local_8
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.steps_done
                _hx_local_9.steps_done = (_hx_local_10 - 1)
                _hx_local_10
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.steps_done_Verb
                _hx_local_11.steps_done_Verb = (_hx_local_12 - 1)
                _hx_local_12
            if self.show_details:
                msg_str = " "
                if self.display_internal:
                    msg_str = (("null" if msg_str is None else msg_str) + Std.string((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).internal_token))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + Std.string((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).visible_token))
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull((("  now is  " + ("null" if data1_str is None else data1_str)))))
                if (0 < len(data1_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("(" + ("null" if data1_name is None else data1_name)) + ")"))))
                msg_str = (("null" if msg_str is None else msg_str) + "\n")
                forGL_ForGL_ui.msg(msg_str)
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.run_text_line
                _hx_local_18.run_text_line = (_hx_local_19 + 1)
                _hx_local_19
            if self.export_as_code:
                exp_str = data1_str
                if (0 < len(data1_name)):
                    exp_str = data1_name
                _this = self.export_as_code_log
                x = forGL_TypedTokens((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).token_type,((Std.string((rStack[nounIdx] if nounIdx >= 0 and nounIdx < len(rStack) else None).visible_token) + " = ") + ("null" if exp_str is None else exp_str)))
                _this.append(x)
            if data_type_OK:
                if (len(dStack) != 0):
                    dStack.pop(0)
            if self.show_stacks:
                self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        elif (1 < len(nStack)):
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.steps_done
            _hx_local_20.steps_done = (_hx_local_21 - 1)
            _hx_local_21
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.steps_done_Verb
            _hx_local_22.steps_done_Verb = (_hx_local_23 - 1)
            _hx_local_23
            return -10
        else:
            forGL_ForGL_ui.msg(" INFO: Not enough Data or Nouns to do Assignment now. Done later.\n")
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.run_text_line
            _hx_local_24.run_text_line = (_hx_local_25 + 1)
            _hx_local_25
            return 1
        return 0

    def addQuotes(self,_hx_str):
        return (("\"" + Std.string(_hx_str)) + "\"")

    def trimQuotes(self,_hx_str):
        if (("\"" == hx_strings_Strings.charAt8(_hx_str,0)) and (("\"" == hx_strings_Strings.charAt8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - 1))))):
            return hx_strings_Strings.trim(_hx_str,hx_strings_internal__Either2__Either2.a("\""))
        return _hx_str

    def addName(self,str_array,name):
        found = False
        search_name = hx_strings_Strings.toLowerCase8(name)
        i = 0
        while (i < len(str_array)):
            if (search_name == hx_strings_Strings.toLowerCase8((str_array[i] if i >= 0 and i < len(str_array) else None))):
                found = True
                break
            i = (i + 1)
        if (not found):
            str_array.append(name)

    def argsOrData_Str(self):
        return self.arrToStrSep(self.argsOrData_list," ")

    def arrToStrSep(self,str_array,separator = None):
        if (separator is None):
            separator = " "
        ret_Str = ""
        i = 0
        while (i < len(str_array)):
            ret_Str = hx_strings_Strings.insertAt(ret_Str,(0 if ((ret_Str is None)) else len(ret_Str)),Std.string((str_array[i] if i >= 0 and i < len(str_array) else None)))
            i = (i + 1)
            if (i < len(str_array)):
                ret_Str = hx_strings_Strings.insertAt(ret_Str,(0 if ((ret_Str is None)) else len(ret_Str)),Std.string(separator))
        return ret_Str

    def argsOrData(self,start,rStack,dStack,oStack):
        while (0 < len(self.argsOrData_list)):
            _this = self.argsOrData_list
            if (len(_this) != 0):
                _this.pop()
        doing_args = False
        idx = start
        if ((idx + 2) <= len(rStack)):
            if ((2 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type) and ((18 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_op_means))):
                idx = (idx + 1)
                doing_args = True
        while (idx < len(rStack)):
            handled = False
            if ((6 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type) or ((7 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type))):
                x = forGL_DataItem((rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_noun_data,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_str,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_float,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_int)
                dStack.append(x)
                handled = True
            if (8 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                x1 = forGL_DataItem(8,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_str,0.0,0)
                dStack.append(x1)
                handled = True
            if (11 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                x2 = forGL_DataItem(11,"",(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_float,0)
                dStack.append(x2)
                handled = True
            if (9 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                x3 = forGL_DataItem(9,"",0.0,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_int)
                dStack.append(x3)
                handled = True
            if (10 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                x4 = forGL_DataItem(10,"",0.0,(rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_int)
                dStack.append(x4)
                handled = True
            if (not handled):
                if doing_args:
                    if ((2 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type) and ((19 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_op_means))):
                        idx = (idx + 1)
                        break
                    op_to_do = (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_op_means
                    skip = False
                    if (12 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                        skip = True
                    if (2 == (rStack[idx] if idx >= 0 and idx < len(rStack) else None).token_type):
                        if ((((45 == op_to_do) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                            skip = True
                    if skip:
                        idx = (idx + 1)
                        continue
                    break
                break
            if handled:
                if self.display_internal:
                    _this = self.argsOrData_list
                    x5 = (rStack[idx] if idx >= 0 and idx < len(rStack) else None).internal_token
                    _this.append(x5)
                else:
                    _this1 = self.argsOrData_list
                    x6 = (rStack[idx] if idx >= 0 and idx < len(rStack) else None).visible_token
                    _this1.append(x6)
            idx = (idx + 1)
        return (idx - start)

    def runMath1Data(self,rStack,dStack,oStack,nStack,after_expression):
        opIdx = (oStack[0] if 0 < len(oStack) else None)
        dataIdx = 0
        if after_expression:
            opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            dataIdx = (len(dStack) - 1)
        math_1_int = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_int
        math_1_float = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_float
        math_1_type = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_type
        op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
        data1_str = ""
        data1_name = ""
        if (10 == math_1_type):
            forGL_ForGL_ui.error((("  Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a Bool not correct.  Stopping now.\n"))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            return -3
        if (8 == math_1_type):
            resolve_info = forGL_ResolveInfo()
            type_found = forGL_NLTypeAs.resolveType((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
            if ((11 != type_found) and ((9 != type_found))):
                forGL_ForGL_ui.error(((((" Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a String ") + Std.string((dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str)) + " not available. Stopping.\n"))
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.run_text_line
                _hx_local_2.run_text_line = (_hx_local_3 + 1)
                _hx_local_3
                return -3
            math_1_type = type_found
            math_1_float = resolve_info.resolve_float
            math_1_int = resolve_info.resolve_int
        else:
            data1_name = (dStack[dataIdx] if dataIdx >= 0 and dataIdx < len(dStack) else None).data_str
        if (9 == math_1_type):
            math_1_float = math_1_int
            data1_str = Std.string(math_1_int)
        else:
            data1_str = Std.string(math_1_float)
        if after_expression:
            if (len(dStack) != 0):
                dStack.pop()
            if (len(oStack) != 0):
                oStack.pop()
        else:
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(oStack) != 0):
                oStack.pop(0)
        result = 0.0
        result_int = 0
        is_int = False
        try:
            op_to_do1 = op_to_do
            if (op_to_do1 == 50):
                result = Reflect.field(Math,"fabs")(math_1_float)
            elif (op_to_do1 == 51):
                result = ((math_1_float * 180.0) / Math.PI)
            elif (op_to_do1 == 52):
                result = ((math_1_float * Math.PI) / 180.0)
            elif (op_to_do1 == 53):
                result = (Math.NaN if (((math_1_float == Math.POSITIVE_INFINITY) or ((math_1_float == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(math_1_float))
            elif (op_to_do1 == 54):
                result = (Math.NaN if (((math_1_float == Math.POSITIVE_INFINITY) or ((math_1_float == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(math_1_float))
            elif (op_to_do1 == 55):
                result = Math.tan(math_1_float)
            elif (op_to_do1 == 56):
                result = Math.asin(math_1_float)
            elif (op_to_do1 == 57):
                result = Math.acos(math_1_float)
            elif (op_to_do1 == 58):
                result = Math.atan(math_1_float)
            elif (op_to_do1 == 59):
                result = (0.0 if ((math_1_float == Math.NEGATIVE_INFINITY)) else (Math.POSITIVE_INFINITY if ((math_1_float == Math.POSITIVE_INFINITY)) else Reflect.field(Math,"exp")(math_1_float)))
            elif (op_to_do1 == 60):
                result = (Math.NEGATIVE_INFINITY if ((math_1_float == 0.0)) else (Math.NaN if ((math_1_float < 0.0)) else python_lib_Math.log(math_1_float)))
            elif (op_to_do1 == 61):
                result = (((Math.NEGATIVE_INFINITY if ((math_1_float == 0.0)) else (Math.NaN if ((math_1_float < 0.0)) else python_lib_Math.log(math_1_float)))) / python_lib_Math.log(10))
            elif (op_to_do1 == 62):
                if (0.0 > math_1_float):
                    forGL_ForGL_ui.error(((((" ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " of ") + Std.string(math_1_float)) + " not allowed. Stopping now.\n"))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.run_text_line
                    _hx_local_4.run_text_line = (_hx_local_5 + 1)
                    _hx_local_5
                    return -3
                result = (Math.NaN if ((math_1_float < 0)) else python_lib_Math.sqrt(math_1_float))
            elif (op_to_do1 == 63):
                is_int = True
                result_int = Math.floor((math_1_float + 0.5))
            elif (op_to_do1 == 64):
                is_int = True
                result_int = Math.floor(math_1_float)
            elif (op_to_do1 == 65):
                is_int = True
                result_int = Math.ceil(math_1_float)
            else:
                forGL_ForGL_ui.error((((("  INTERNAL ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " of ") + Std.string(math_1_float)) + " Unknown. Stopping now.\n"))
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.run_text_line
                _hx_local_6.run_text_line = (_hx_local_7 + 1)
                _hx_local_7
                return -11
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.warning((("\nMath ERROR: Exception in  runMath1Data(): " + Std.string(e)) + "\n"))
        if is_int:
            if after_expression:
                x = forGL_DataItem(9,"",0.0,result_int)
                dStack.append(x)
            else:
                x = forGL_DataItem(9,"",0.0,result_int)
                dStack.insert(0, x)
            result = result_int
        elif after_expression:
            x = forGL_DataItem(11,"",result,0)
            dStack.append(x)
        else:
            x = forGL_DataItem(11,"",result,0)
            dStack.insert(0, x)
        if self.show_details:
            msg_str = (((" " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "  of  ") + ("null" if data1_str is None else data1_str))
            if (0 < len(data1_name)):
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull((((" ( " + ("null" if data1_name is None else data1_name)) + " )"))))
            forGL_ForGL_ui.msg((((("null" if msg_str is None else msg_str) + "  is  ") + Std.string(result)) + "\n"))
            _hx_local_9 = self
            _hx_local_10 = _hx_local_9.run_text_line
            _hx_local_9.run_text_line = (_hx_local_10 + 1)
            _hx_local_10
        if self.show_stacks:
            self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        return 0

    def runStr2Data(self,op_to_do,dStack,after_expression):
        dataIdx0 = 0
        dataIdx1 = 1
        if after_expression:
            dataIdx0 = (len(dStack) - 2)
            dataIdx1 = (len(dStack) - 1)
        str1 = self.trimQuotes((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str)
        if (9 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            str1 = Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int)
        elif (11 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            str1 = Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float)
        elif (10 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            if (1 == (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int):
                str1 = "true"
            else:
                str1 = "false"
        elif (8 != (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type):
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Unknown Data item Type: " + Std.string((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type)) + " Stopping.\n"))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.run_text_line
            _hx_local_2.run_text_line = (_hx_local_3 + 1)
            _hx_local_3
            return -11
        str2 = self.trimQuotes((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str)
        if (9 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            str2 = Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int)
        elif (11 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            str2 = Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float)
        elif (10 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            if (1 == (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int):
                str2 = "true"
            else:
                str2 = "false"
        elif (8 != (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type):
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Unknown Data item Type: " + Std.string((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type)) + " Stopping.\n"))
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 1)
            _hx_local_7
            return -11
        ret_val = 0
        result = ""
        op_to_do1 = op_to_do
        if (op_to_do1 == 1):
            result = hx_strings_Strings.insertAt(str1,(0 if ((str1 is None)) else len(str1)),Std.string(str2))
        elif (op_to_do1 == 2):
            if ((0 < ((0 if ((str2 is None)) else len(str2)))) and ((0 < ((0 if ((str1 is None)) else len(str1)))))):
                pieces = hx_strings_Strings.split8(str1,[str2])
                while (0 < len(pieces)):
                    result = (Std.string(result) + HxOverrides.stringOrNull((None if ((len(pieces) == 0)) else pieces.pop(0))))
            else:
                result = str1
        elif (op_to_do1 == 3):
            forGL_ForGL_ui.error("\nINTERNAL ERROR: Copy a string multiple times is NOT IMPLEMENTED.  Stopping.\n")
            ret_val = -10
        elif (op_to_do1 == 28):
            result = hx_strings_Strings.insertAt(str1,(0 if ((str1 is None)) else len(str1)),Std.string(str2))
        elif (op_to_do1 == 29):
            if ((0 < ((0 if ((str2 is None)) else len(str2)))) and ((0 < ((0 if ((str1 is None)) else len(str1)))))):
                pieces = hx_strings_Strings.split8(str1,[str2])
                while (0 < len(pieces)):
                    result = (Std.string(result) + HxOverrides.stringOrNull((None if ((len(pieces) == 0)) else pieces.pop(0))))
            else:
                result = str1
        else:
            forGL_ForGL_ui.error((("\nINTERNAL ERROR:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " Wrong Operator to use with a string.  Stopping.\n"))
            ret_val = -11
        if (0 == ret_val):
            if after_expression:
                if (len(dStack) != 0):
                    dStack.pop()
                if (len(dStack) != 0):
                    dStack.pop()
                x = forGL_DataItem(8,self.addQuotes(result),0,0)
                dStack.append(x)
            else:
                if (len(dStack) != 0):
                    dStack.pop(0)
                if (len(dStack) != 0):
                    dStack.pop(0)
                x = forGL_DataItem(8,self.addQuotes(result),0,0)
                dStack.insert(0, x)
        return ret_val

    def runMath2Data(self,rStack,dStack,oStack,nStack,after_expression):
        opIdx = (oStack[0] if 0 < len(oStack) else None)
        dataIdx0 = 0
        dataIdx1 = 1
        if after_expression:
            opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            dataIdx0 = (len(dStack) - 2)
            dataIdx1 = (len(dStack) - 1)
        op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
        running_msg = ""
        data1_str = ""
        data2_str = ""
        data1_name = ""
        data2_name = ""
        if self.show_details:
            running_msg = (("  Running op:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "\n")
        math_1_int = 0
        math_1_float = 0
        math_2_int = 0
        math_2_float = 0
        math_1_type = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_type
        math_2_type = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_type
        if (8 != math_1_type):
            data1_name = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str
        if (8 != math_2_type):
            data2_name = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str
        need_conversion = False
        if ((math_1_type != math_2_type) and (((10 == math_1_type) or ((10 == math_2_type))))):
            forGL_ForGL_ui.msg(running_msg)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            forGL_ForGL_ui.error(" Syntax ERROR: Only a Bool with a Bool is valid.  Stopping now.\n")
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.run_text_line
            _hx_local_2.run_text_line = (_hx_local_3 + 1)
            _hx_local_3
            return -3
        if (9 == math_1_type):
            math_1_int = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int
            math_1_float = math_1_int
            if (self.show_details or self.export_as_code):
                data1_str = Std.string(math_1_int)
        elif (11 == math_1_type):
            math_1_float = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float
            if (self.show_details or self.export_as_code):
                data1_str = Std.string(math_1_float)
        else:
            need_conversion = True
        if (9 == math_2_type):
            math_2_int = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int
            math_2_float = math_2_int
            if (self.show_details or self.export_as_code):
                data2_str = Std.string(math_2_int)
        elif (11 == math_2_type):
            math_2_float = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float
            if (self.show_details or self.export_as_code):
                data2_str = Std.string(math_2_float)
        else:
            need_conversion = True
        if need_conversion:
            if ((28 == op_to_do) or ((29 == op_to_do))):
                str2result = self.runStr2Data(op_to_do,dStack,after_expression)
                def _hx_local_5():
                    _hx_local_4 = str2result
                    if (Std.isOfType(_hx_local_4,Int) or ((_hx_local_4 is None))):
                        _hx_local_4
                    else:
                        raise "Class cast error"
                    return _hx_local_4
                if (0 == _hx_local_5()):
                    if after_expression:
                        if (len(oStack) != 0):
                            oStack.pop()
                    elif (len(oStack) != 0):
                        oStack.pop(0)
                return str2result
            resolve_info = forGL_ResolveInfo()
            math_error = False
            if (8 == math_1_type):
                math_1_type = forGL_NLTypeAs.resolveType((dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
                if (11 == math_1_type):
                    math_1_float = resolve_info.resolve_float
                elif (9 == math_1_type):
                    math_1_int = resolve_info.resolve_int
                    math_1_float = math_1_int
                else:
                    math_error = True
            if ((not math_error) and ((8 == math_2_type))):
                math_2_type = forGL_NLTypeAs.resolveType((dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_str,resolve_info,self.run_verbose,True)
                if (11 == math_2_type):
                    math_2_float = resolve_info.resolve_float
                elif (9 == math_2_type):
                    math_2_int = resolve_info.resolve_int
                    math_2_float = math_2_int
                else:
                    math_error = True
            if math_error:
                if (((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))):
                    str2result = self.runStr2Data(op_to_do,dStack,after_expression)
                    def _hx_local_7():
                        _hx_local_6 = str2result
                        if (Std.isOfType(_hx_local_6,Int) or ((_hx_local_6 is None))):
                            _hx_local_6
                        else:
                            raise "Class cast error"
                        return _hx_local_6
                    if (0 == _hx_local_7()):
                        if after_expression:
                            if (len(oStack) != 0):
                                oStack.pop()
                        elif (len(oStack) != 0):
                            oStack.pop(0)
                    return str2result
                forGL_ForGL_ui.error(((" Syntax ERROR: " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + " with a String not available. Stopping now.\n"))
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.run_text_line
                _hx_local_8.run_text_line = (_hx_local_9 + 1)
                _hx_local_9
                return -3
        else:
            if (9 == math_1_type):
                math_1_int = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_int
                math_1_float = math_1_int
                if self.show_details:
                    data1_str = Std.string(math_1_int)
            else:
                math_1_float = (dStack[dataIdx0] if dataIdx0 >= 0 and dataIdx0 < len(dStack) else None).data_float
                if self.show_details:
                    data1_str = Std.string(math_1_float)
            if (9 == math_2_type):
                math_2_int = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_int
                math_2_float = math_2_int
                if self.show_details:
                    data2_str = Std.string(math_2_int)
            else:
                math_2_float = (dStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(dStack) else None).data_float
                if self.show_details:
                    data2_str = Std.string(math_2_float)
        math_is_float = True
        if (((9 == math_1_type) and ((9 == math_2_type))) or ((10 == math_1_type))):
            if ((((((((((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))) or ((5 == op_to_do))) or ((10 == op_to_do))) or ((11 == op_to_do))) or ((12 == op_to_do))) or ((13 == op_to_do))) or ((14 == op_to_do))) or ((15 == op_to_do))):
                math_is_float = False
        if after_expression:
            if (len(dStack) != 0):
                dStack.pop()
            if (len(dStack) != 0):
                dStack.pop()
            if (len(oStack) != 0):
                oStack.pop()
        else:
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(dStack) != 0):
                dStack.pop(0)
            if (len(oStack) != 0):
                oStack.pop(0)
        bool_ret = False
        use_bool = False
        result_int = 0
        result = 0.0
        if (10 == math_1_type):
            use_bool = True
            op_to_do1 = op_to_do
            if (op_to_do1 == 10):
                bool_ret = (math_1_int == math_2_int)
            elif (op_to_do1 == 11):
                bool_ret = (math_1_int != math_2_int)
            elif (op_to_do1 == 12):
                bool_ret = (math_1_int < math_2_int)
            elif (op_to_do1 == 13):
                bool_ret = (math_1_int <= math_2_int)
            elif (op_to_do1 == 14):
                bool_ret = (math_1_int > math_2_int)
            elif (op_to_do1 == 15):
                bool_ret = (math_1_int >= math_2_int)
            else:
                use_bool = False
            if use_bool:
                if bool_ret:
                    result_int = 1
                else:
                    result_int = 0
                if after_expression:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x)
                else:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x)
            result = result_int
        elif (not math_is_float):
            try:
                op_to_do1 = op_to_do
                if (op_to_do1 == 1):
                    result_int = (math_1_int + math_2_int)
                elif (op_to_do1 == 2):
                    result_int = (math_1_int - math_2_int)
                elif (op_to_do1 == 3):
                    result_int = (math_1_int * math_2_int)
                elif (op_to_do1 == 4):
                    if (0 == math_2_int):
                        forGL_ForGL_ui.error("ERROR: Divide by 0 not allowed. Stopping. \n")
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.run_text_line
                        _hx_local_10.run_text_line = (_hx_local_11 + 1)
                        _hx_local_11
                        return -3
                    else:
                        temp_float = (math_1_int / math_2_int)
                        result_int = Math.floor(temp_float)
                elif (op_to_do1 == 5):
                    if (0 == math_2_int):
                        result_int = math_1_int
                    else:
                        result_int = HxOverrides.mod(math_1_int, math_2_int)
                elif (op_to_do1 == 10):
                    bool_ret = (math_1_int == math_2_int)
                    use_bool = True
                elif (op_to_do1 == 11):
                    bool_ret = (math_1_int != math_2_int)
                    use_bool = True
                elif (op_to_do1 == 12):
                    bool_ret = (math_1_int < math_2_int)
                    use_bool = True
                elif (op_to_do1 == 13):
                    bool_ret = (math_1_int <= math_2_int)
                    use_bool = True
                elif (op_to_do1 == 14):
                    bool_ret = (math_1_int > math_2_int)
                    use_bool = True
                elif (op_to_do1 == 15):
                    bool_ret = (math_1_int >= math_2_int)
                    use_bool = True
                else:
                    result_int = 1
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                forGL_ForGL_ui.warning((("\nMATH ERROR: Exception in  runMath2Data(): Integer part " + Std.string(e)) + "\n"))
            if use_bool:
                result_int = 0
                if (True == bool_ret):
                    result_int = 1
                if after_expression:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x)
                else:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x)
            elif after_expression:
                x = forGL_DataItem(9,"",0,result_int)
                dStack.append(x)
            else:
                x = forGL_DataItem(9,"",0,result_int)
                dStack.insert(0, x)
            result = result_int
        else:
            try:
                op_to_do1 = op_to_do
                if (op_to_do1 == 1):
                    result = (math_1_float + math_2_float)
                elif (op_to_do1 == 2):
                    result = (math_1_float - math_2_float)
                elif (op_to_do1 == 3):
                    result = (math_1_float * math_2_float)
                elif (op_to_do1 == 4):
                    if (0.0 == math_2_float):
                        forGL_ForGL_ui.error("ERROR: Divide by 0 not allowed. Stopping. \n")
                        _hx_local_12 = self
                        _hx_local_13 = _hx_local_12.run_text_line
                        _hx_local_12.run_text_line = (_hx_local_13 + 1)
                        _hx_local_13
                        return -3
                    else:
                        result = (math_1_float / math_2_float)
                elif (op_to_do1 == 5):
                    result = HxOverrides.modf(math_1_float, math_2_float)
                elif (op_to_do1 == 6):
                    result = (math_1_float if (python_lib_Math.isnan(math_1_float)) else (math_2_float if (python_lib_Math.isnan(math_2_float)) else min(math_1_float,math_2_float)))
                elif (op_to_do1 == 7):
                    result = (math_1_float if (python_lib_Math.isnan(math_1_float)) else (math_2_float if (python_lib_Math.isnan(math_2_float)) else max(math_1_float,math_2_float)))
                elif (op_to_do1 == 8):
                    result = Math.atan2(math_1_float,math_2_float)
                elif (op_to_do1 == 9):
                    result = Math.pow(math_1_float,math_2_float)
                elif (op_to_do1 == 10):
                    bool_ret = (math_1_float == math_2_float)
                    use_bool = True
                elif (op_to_do1 == 11):
                    bool_ret = (math_1_float != math_2_float)
                    use_bool = True
                elif (op_to_do1 == 12):
                    bool_ret = (math_1_float < math_2_float)
                    use_bool = True
                elif (op_to_do1 == 13):
                    bool_ret = (math_1_float <= math_2_float)
                    use_bool = True
                elif (op_to_do1 == 14):
                    bool_ret = (math_1_float > math_2_float)
                    use_bool = True
                elif (op_to_do1 == 15):
                    bool_ret = (math_1_float >= math_2_float)
                    use_bool = True
                else:
                    result = 1.2
            except BaseException as _g:
                None
                e = haxe_Exception.caught(_g).unwrap()
                forGL_ForGL_ui.warning((("\nMATH ERROR: Exception in  runMath2Data(): Float part " + Std.string(e)) + "\n"))
            if use_bool:
                result_int = 0
                if (True == bool_ret):
                    result_int = 1
                if after_expression:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.append(x)
                else:
                    x = forGL_DataItem(10,"",0,result_int)
                    dStack.insert(0, x)
            elif after_expression:
                x = forGL_DataItem(11,"",result,0)
                dStack.append(x)
            else:
                x = forGL_DataItem(11,"",result,0)
                dStack.insert(0, x)
        if self.show_details:
            result_str = Std.string(result)
            if use_bool:
                if (1 == result):
                    result_str = "True"
                else:
                    result_str = "False"
                msg_str = " ( "
                if (0 < len(data1_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data1_name is None else data1_name))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data1_str is None else data1_str))
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do,True))) + "  "))))
                if (0 < len(data2_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data2_name is None else data2_name))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data2_str is None else data2_str))
                msg_str = (("null" if msg_str is None else msg_str) + " ) ")
                forGL_ForGL_ui.msg((((("null" if msg_str is None else msg_str) + "  \tis  ") + ("null" if result_str is None else result_str)) + "\n"))
            else:
                msg_str = "    "
                if (0 < len(data1_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data1_name is None else data1_name))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data1_str is None else data1_str))
                msg_str = (("null" if msg_str is None else msg_str) + HxOverrides.stringOrNull(((("  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do,True))) + "  "))))
                if (0 < len(data2_name)):
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data2_name is None else data2_name))
                else:
                    msg_str = (("null" if msg_str is None else msg_str) + ("null" if data2_str is None else data2_str))
                forGL_ForGL_ui.msg((((("null" if msg_str is None else msg_str) + "  \t=  ") + ("null" if result_str is None else result_str)) + "\n"))
            _hx_local_25 = self
            _hx_local_26 = _hx_local_25.run_text_line
            _hx_local_25.run_text_line = (_hx_local_26 + 1)
            _hx_local_26
        if self.show_stacks:
            self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line)
        return 0

    def runOperators(self,rStack,dStack,oStack,nStack,after_expression = None,punctuation_hit = None):
        if (after_expression is None):
            after_expression = False
        if (punctuation_hit is None):
            punctuation_hit = False
        ret_val = 0
        original_opStack_length = len(oStack)
        assign_opStack_length = -1
        while (0 < len(oStack)):
            opIdx = (oStack[0] if 0 < len(oStack) else None)
            if after_expression:
                opIdx = python_internal_ArrayImpl._get(oStack, (len(oStack) - 1))
            op_to_do = (rStack[opIdx] if opIdx >= 0 and opIdx < len(rStack) else None).token_op_means
            if ((32 == op_to_do) or ((34 == op_to_do))):
                if ((1 < len(oStack)) and (((oStack[0] if 0 < len(oStack) else None) == opIdx))):
                    if (assign_opStack_length < 0):
                        assign_opStack_length = len(oStack)
                        after_expression = True
                        continue
                    elif (len(oStack) < assign_opStack_length):
                        assign_opStack_length = len(oStack)
                        after_expression = True
                        continue
                if (not punctuation_hit):
                    return 3
                if (0 < len(nStack)):
                    if self.show_details:
                        forGL_ForGL_ui.msg((("\n  Running op:  " + Std.string(forGL_MeansWhat.opMeanAsStr(op_to_do))) + "\n"))
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.run_text_line
                        _hx_local_0.run_text_line = (_hx_local_1 + 1)
                        _hx_local_1
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.run_text_line
                        _hx_local_2.run_text_line = (_hx_local_3 + 1)
                        _hx_local_3
                    assign_result = self.runAssignment(rStack,dStack,oStack,nStack,op_to_do,opIdx)
                    def _hx_local_5():
                        _hx_local_4 = assign_result
                        if (Std.isOfType(_hx_local_4,Int) or ((_hx_local_4 is None))):
                            _hx_local_4
                        else:
                            raise "Class cast error"
                        return _hx_local_4
                    if (0 != _hx_local_5()):
                        return assign_result
                    elif after_expression:
                        if (len(oStack) != 0):
                            oStack.pop()
                    elif (len(oStack) != 0):
                        oStack.pop(0)
                else:
                    return 2
            elif (0 == len(dStack)):
                return 1
            if ((((((((((((((((50 == op_to_do) or ((51 == op_to_do))) or ((52 == op_to_do))) or ((53 == op_to_do))) or ((54 == op_to_do))) or ((55 == op_to_do))) or ((56 == op_to_do))) or ((57 == op_to_do))) or ((58 == op_to_do))) or ((59 == op_to_do))) or ((60 == op_to_do))) or ((61 == op_to_do))) or ((62 == op_to_do))) or ((63 == op_to_do))) or ((64 == op_to_do))) or ((65 == op_to_do))):
                math_op_result = self.runMath1Data(rStack,dStack,oStack,nStack,after_expression)
                def _hx_local_7():
                    _hx_local_6 = math_op_result
                    if (Std.isOfType(_hx_local_6,Int) or ((_hx_local_6 is None))):
                        _hx_local_6
                    else:
                        raise "Class cast error"
                    return _hx_local_6
                if (0 != _hx_local_7()):
                    return math_op_result
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.steps_done
                _hx_local_8.steps_done = (_hx_local_9 + 1)
                _hx_local_9
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.steps_done_Verb
                _hx_local_10.steps_done_Verb = (_hx_local_11 + 1)
                _hx_local_11
            elif (((((((((((((((((1 == op_to_do) or ((2 == op_to_do))) or ((3 == op_to_do))) or ((4 == op_to_do))) or ((5 == op_to_do))) or ((6 == op_to_do))) or ((7 == op_to_do))) or ((8 == op_to_do))) or ((9 == op_to_do))) or ((10 == op_to_do))) or ((11 == op_to_do))) or ((12 == op_to_do))) or ((13 == op_to_do))) or ((14 == op_to_do))) or ((15 == op_to_do))) or ((28 == op_to_do))) or ((29 == op_to_do))):
                if (2 <= len(dStack)):
                    math_op_result1 = self.runMath2Data(rStack,dStack,oStack,nStack,after_expression)
                    def _hx_local_13():
                        _hx_local_12 = math_op_result1
                        if (Std.isOfType(_hx_local_12,Int) or ((_hx_local_12 is None))):
                            _hx_local_12
                        else:
                            raise "Class cast error"
                        return _hx_local_12
                    if (0 != _hx_local_13()):
                        return math_op_result1
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.steps_done
                    _hx_local_14.steps_done = (_hx_local_15 + 1)
                    _hx_local_15
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.steps_done_Verb
                    _hx_local_16.steps_done_Verb = (_hx_local_17 + 1)
                    _hx_local_17
                    after_expression = False
                    continue
                else:
                    return 1
            if self.show_stacks:
                self.viewDataOpNouns(rStack,dStack,oStack,nStack,self.dataOpNoun_text_line,True)
            after_expression = False
        return ret_val

    def run(self):
        ret_val = 0
        try:
            self.start_session_time = (Date.now().date.timestamp() * 1000)
            self.total_intp_time = 0.0
            test_def = "5 show. show( 7 )"
            verb_display_line = self.run_text_line
            words_saved = 0
            run_result = 0
            def _hx_local_1():
                _hx_local_0 = run_result
                if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            while (0 <= _hx_local_1()):
                self.elapsed_intp_time = 0.0
                _hx_str = self.user_def
                if (0 != ((0 if ((_hx_str is None)) else len(_hx_str)))):
                    test_def = self.user_def
                run_result = self.runDef(test_def,verb_display_line)
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.total_intp_time
                _hx_local_2.total_intp_time = (_hx_local_3 + self.elapsed_intp_time)
                _hx_local_2.total_intp_time
                def _hx_local_5():
                    _hx_local_4 = run_result
                    if (Std.isOfType(_hx_local_4,Int) or ((_hx_local_4 is None))):
                        _hx_local_4
                    else:
                        raise "Class cast error"
                    return _hx_local_4
                if (0 > _hx_local_5()):
                    break
                while (0 < len(self.callStack)):
                    _this = self.callStack
                    if (len(_this) != 0):
                        _this.pop()
                if (0 == len(self.in_dictionary_file_name)):
                    forGL_ForGL_ui.msg("\n    Hit a Key to run again or  F to Finish ? ")
                else:
                    forGL_ForGL_ui.msg("\n    Hit a Key to run again or  S to Save Verb or  F to Finish ? ")
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.run_text_line
                _hx_local_6.run_text_line = (_hx_local_7 + 1)
                _hx_local_7
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.run_text_line
                _hx_local_8.run_text_line = (_hx_local_9 + 1)
                _hx_local_9
                ans = self.stdin.readLine()
                action = ""
                if (0 < len(ans)):
                    action = ("" if ((0 >= len(ans))) else ans[0]).upper()
                if ("F" == action):
                    break
                if (0 < len(self.in_dictionary_file_name)):
                    if ("S" == action):
                        forGL_ForGL_ui.msg("\rSave Verb as what Name (no name means not Saving) ?\n")
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.run_text_line
                        _hx_local_10.run_text_line = (_hx_local_11 + 1)
                        _hx_local_11
                        name = ""
                        done = False
                        while (not done):
                            ans = self.stdin.readLine()
                            if (0 == len(ans)):
                                break
                            name_internal = hx_strings_Strings.toLowerCase8(ans)
                            dict_idx = self.nlDict.findWord(ans)
                            if (0 <= dict_idx):
                                forGL_ForGL_ui.msg("\r   That word is in the Dictionary. Please use another name.\n")
                                forGL_ForGL_ui.msg("\r")
                                forGL_ForGL_ui.eraseToLineEnd(0)
                                continue
                            add_result = self.nlDict.addWord(ans,4,name_internal,0,self.user_def)
                            def _hx_local_13():
                                _hx_local_12 = add_result
                                if (Std.isOfType(_hx_local_12,Int) or ((_hx_local_12 is None))):
                                    _hx_local_12
                                else:
                                    raise "Class cast error"
                                return _hx_local_12
                            if (0 == _hx_local_13()):
                                words_saved = (words_saved + 1)
                                break
                            else:
                                break
            show_times = True
            if show_times:
                end_session_time = (Date.now().date.timestamp() * 1000)
                total_session_time = (((end_session_time - self.start_session_time)) / 1000.0)
                elapsed_session = Math.floor((total_session_time * 1000.0))
                total_session_time = (elapsed_session / 1000.0)
                forGL_ForGL_ui.msg((("\n  ... Elapsed total Run Time " + Std.string(self.total_intp_time)) + " Seconds"))
                forGL_ForGL_ui.msg((("\n  Elapsed total session Time " + Std.string(total_session_time)) + " Seconds\n"))
            def _hx_local_16():
                _hx_local_15 = run_result
                if (Std.isOfType(_hx_local_15,Int) or ((_hx_local_15 is None))):
                    _hx_local_15
                else:
                    raise "Class cast error"
                return _hx_local_15
            ret_val = _hx_local_16()
            errors = self.ForGLData.getDataErrors()
            if (0 < len(errors)):
                forGL_ForGL_ui.msg((("\n\t\t" + Std.string(len(errors))) + "  Data  handling  ERRORS\n"))
                i = 0
                while (i < len(errors)):
                    forGL_ForGL_ui.msg((errors[i] if i >= 0 and i < len(errors) else None))
                    i = (i + 1)
            warnings = self.ForGLData.getDataWarnings()
            if (0 < len(warnings)):
                forGL_ForGL_ui.msg((("\t\t" + Std.string(len(warnings))) + "  Data  handling  Warnings\n"))
                i = 0
                while (i < len(warnings)):
                    forGL_ForGL_ui.msg((warnings[i] if i >= 0 and i < len(warnings) else None))
                    i = (i + 1)
            forGL_ForGL_ui.msg("\t\tImport   handling  Messages\n")
            forGL_ForGL_ui.msg(self.nl_Import.importWords_msgs)
            if (0 < words_saved):
                forGL_ForGL_ui.msg("Save your changes as a new file (y/n) ? ",1)
                if forGL_ForGL_ui.enterYes():
                    forGL_ForGL_ui.msg("\r")
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    export = forGL_NLExport()
                    export_result = export.exportWords(self.nlDict,self.in_dictionary_file_name,self.ForGLData)
                    forGL_ForGL_ui.msg("\t\tExport  handling  Messages\n")
                    forGL_ForGL_ui.msg(export.exportWords_msgs)
                    def _hx_local_20():
                        _hx_local_19 = export_result
                        if (Std.isOfType(_hx_local_19,Int) or ((_hx_local_19 is None))):
                            _hx_local_19
                        else:
                            raise "Class cast error"
                        return _hx_local_19
                    if (0 != _hx_local_20()):
                        forGL_ForGL_ui.msg("Problem with Saving your Dictionary. Please check messages and .toml file\n")
            if (0 < len(self.export_as_code_log)):
                forGL_ForGL_ui.msg("\n")
                forGL_ForGL_ui.eraseToLineEnd(0)
                forGL_ForGL_ui.msg("#    Export as Code Log\n")
                i = 0
                while (i < len(self.export_as_code_log)):
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg((Std.string((self.export_as_code_log[i] if i >= 0 and i < len(self.export_as_code_log) else None).token_name) + " "),forGL_ForGL_ui.getTypeColor((self.export_as_code_log[i] if i >= 0 and i < len(self.export_as_code_log) else None).token_type),False)
                    forGL_ForGL_ui.msg("\n")
                    i = (i + 1)
                forGL_ForGL_ui.msg("\n")
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in run(): " + Std.string(e)) + " \n"))
            def _hx_local_23():
                _hx_local_22 = -11
                if (Std.isOfType(_hx_local_22,Int) or ((_hx_local_22 is None))):
                    _hx_local_22
                else:
                    raise "Class cast error"
                return _hx_local_22
            ret_val = _hx_local_23()
        return ret_val

    def runDef(self,def_to_run,textLine):
        ret_val = 0
        try:
            self.run_text_line = textLine
            self.export_as_code = False
            self.display_internal = False
            self.show_details = False
            user_Verb = ""
            forGL_ForGL_ui.goToPos(self.run_text_line,0)
            forGL_ForGL_ui.eraseToDispEnd()
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.run_text_line
            _hx_local_0.run_text_line = (_hx_local_1 + 1)
            _hx_local_1
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            if (not self.export_as_code):
                forGL_ForGL_ui.msg("\rShow internal Names when running (y/n) ?  ")
                self.display_internal = forGL_ForGL_ui.enterYes()
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.run_text_line
                _hx_local_2.run_text_line = (_hx_local_3 + 1)
                _hx_local_3
                forGL_ForGL_ui.msg("\r")
                forGL_ForGL_ui.eraseToLineEnd(0)
            else:
                self.display_internal = True
            forGL_ForGL_ui.msg("\rShow details of various information (y/n) ?  ")
            self.show_details = forGL_ForGL_ui.enterYes()
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            forGL_ForGL_ui.msg("\rShow details of Words used (y/n) ?  ")
            self.show_words_table = forGL_ForGL_ui.enterYes()
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 1)
            _hx_local_7
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            self.show_stacks = True
            self.show_stacks_Data_Only = False
            self.single_step = True
            forGL_ForGL_ui.msg("\rShow Stacks: N = none & no Steps  OR  D is only Data  OR  any Key for all ? ")
            ans = self.stdin.readLine()
            if (0 < len(ans)):
                char = ("" if ((0 >= len(ans))) else ans[0])
                if (("N" == char) or (("n" == char))):
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rNo stepping; will Run full speed and not show stacks.\n")
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.run_text_line
                    _hx_local_8.run_text_line = (_hx_local_9 + 1)
                    _hx_local_9
                    self.show_stacks = False
                    self.single_step = False
                    self.delay_seconds_default = 0
                    self.delay_seconds = self.delay_seconds_default
                    self.view_DON_throttle = True
                elif (("D" == char) or (("d" == char))):
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rManual stepping and only Data stack will show.\n")
                    _hx_local_10 = self
                    _hx_local_11 = _hx_local_10.run_text_line
                    _hx_local_10.run_text_line = (_hx_local_11 + 1)
                    _hx_local_11
                    self.show_stacks = True
                    self.show_stacks_Data_Only = True
                    self.single_step = True
                else:
                    forGL_ForGL_ui.eraseToLineEnd(0)
                    forGL_ForGL_ui.msg("\rManual stepping and all stacks will show.\n")
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.run_text_line
                    _hx_local_12.run_text_line = (_hx_local_13 + 1)
                    _hx_local_13
                    self.show_stacks = True
                    self.single_step = True
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.run_text_line
            _hx_local_14.run_text_line = (_hx_local_15 + 1)
            _hx_local_15
            forGL_ForGL_ui.msg("\r")
            forGL_ForGL_ui.eraseToLineEnd(0)
            if self.show_stacks:
                self.single_step = True
                forGL_ForGL_ui.msg("\rDelay: your # (times .1 seconds)  OR  any Key for Manual ? ")
                ans = self.stdin.readLine()
                if (0 < len(ans)):
                    delay_wanted = Std.parseFloat(ans)
                    if (not python_lib_Math.isnan(delay_wanted)):
                        if (delay_wanted < 0):
                            delay_wanted = 0
                        self.delay_seconds_default = (delay_wanted / 10.0)
                        self.delay_seconds = self.delay_seconds_default
                        forGL_ForGL_ui.eraseToLineEnd(0)
                        forGL_ForGL_ui.msg((("\rAutomatic stepping with  " + Std.string(self.delay_seconds)) + "  seconds delay.\n"))
                        _hx_local_16 = self
                        _hx_local_17 = _hx_local_16.run_text_line
                        _hx_local_16.run_text_line = (_hx_local_17 + 1)
                        _hx_local_17
                        self.show_stacks = True
                        self.single_step = False
                    else:
                        forGL_ForGL_ui.eraseToLineEnd(0)
                        forGL_ForGL_ui.msg("\rManual stepping. Hit a key to do next step.\n")
                        _hx_local_18 = self
                        _hx_local_19 = _hx_local_18.run_text_line
                        _hx_local_18.run_text_line = (_hx_local_19 + 1)
                        _hx_local_19
                        self.show_stacks = True
                        self.single_step = True
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.run_text_line
            _hx_local_20.run_text_line = (_hx_local_21 + self.nlDict.showDictionaryWords(False))
            _hx_local_20.run_text_line
            forGL_ForGL_ui.setOut(6)
            forGL_ForGL_ui.msg(("    Test_Verb is:\n" + Std.string(def_to_run)),2,True)
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.run_text_line
            _hx_local_22.run_text_line = (_hx_local_23 + 1)
            _hx_local_23
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.run_text_line
            _hx_local_24.run_text_line = (_hx_local_25 + 1)
            _hx_local_25
            forGL_ForGL_ui.setOut(-1)
            user_Verb = forGL_ForGL_ui.enterYourVerb()
            _hx_local_26 = self
            _hx_local_27 = _hx_local_26.run_text_line
            _hx_local_26.run_text_line = (_hx_local_27 + 1)
            _hx_local_27
            _hx_local_28 = self
            _hx_local_29 = _hx_local_28.run_text_line
            _hx_local_28.run_text_line = (_hx_local_29 + 1)
            _hx_local_29
            def _hx_local_31():
                _hx_local_30 = forGL_ForGL_ui.enterYourVerb_return
                if (Std.isOfType(_hx_local_30,Int) or ((_hx_local_30 is None))):
                    _hx_local_30
                else:
                    raise "Class cast error"
                return _hx_local_30
            if (0 != _hx_local_31()):
                return forGL_ForGL_ui.enterYourVerb_return
            user_Verb_lc = hx_strings_Strings.toLowerCase8(user_Verb)
            if ((("main" == user_Verb_lc) or (("test_verb" == user_Verb_lc))) or (("testverb" == user_Verb_lc))):
                user_Verb = def_to_run
            self.user_def = user_Verb
            if self.export_as_code:
                forGL_ForGL_ui.msg("\r    Please enter the export Name for this Verb ? ")
                self.export_as_code_verb_name = self.stdin.readLine()
                _hx_local_32 = self
                _hx_local_33 = _hx_local_32.run_text_line
                _hx_local_32.run_text_line = (_hx_local_33 + 1)
                _hx_local_33
                if (0 < len(self.export_as_code_log)):
                    while (0 < len(self.export_as_code_log)):
                        _this = self.export_as_code_log
                        if (len(_this) != 0):
                            _this.pop()
                _this = self.export_as_code_log
                x = forGL_TypedTokens(4,("# Original Verb  " + HxOverrides.stringOrNull(self.export_as_code_verb_name)))
                _this.append(x)
                _this = self.export_as_code_log
                x = forGL_TypedTokens(4,self.user_def)
                _this.append(x)
            self.repeat_found = False
            self.repeat_count = 0
            self.repeat_limit = -1
            self.repeat_limit_found = False
            tokens = self.nl_Parse.parse(user_Verb,forGL_ParseStyle.PARSE_LEFT_TO_RIGHT)
            _hx_local_34 = self
            _hx_local_35 = _hx_local_34.run_text_line
            _hx_local_34.run_text_line = (_hx_local_35 + self.nl_Parse.parse_text_lines_added)
            _hx_local_34.run_text_line
            self.callStack = list()
            self.exportStack = list()
            self.argsOrData_list = list()
            self.runStack = list()
            _hx_local_36 = self
            _hx_local_37 = _hx_local_36.run_text_line
            _hx_local_36.run_text_line = (_hx_local_37 + self.nl_Parse.resolveTokens(tokens,self.nlDict,self.runStack,self.run_verbose))
            _hx_local_36.run_text_line
            self.repeat_found = self.nl_Parse.repeat_verb_found
            if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not equal.\n"))
                _hx_local_38 = self
                _hx_local_39 = _hx_local_38.run_text_line
                _hx_local_38.run_text_line = (_hx_local_39 + 1)
                _hx_local_39
                _hx_local_40 = self
                _hx_local_41 = _hx_local_40.run_text_line
                _hx_local_40.run_text_line = (_hx_local_41 + 1)
                _hx_local_41
            self.nl_Parse.resolveAssigns(self.runStack)
            choice_result = -11
            choice_result = self.nl_Parse.resolveChoice(self.runStack)
            def _hx_local_43():
                _hx_local_42 = choice_result
                if (Std.isOfType(_hx_local_42,Int) or ((_hx_local_42 is None))):
                    _hx_local_42
                else:
                    raise "Class cast error"
                return _hx_local_42
            if (0 > _hx_local_43()):
                return choice_result
            if (((self.show_words_table or self.export_as_code)) and ((0 < len(self.runStack)))):
                _hx_local_44 = self
                _hx_local_45 = _hx_local_44.run_text_line
                _hx_local_44.run_text_line = (_hx_local_45 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,self.export_as_code))
                _hx_local_44.run_text_line
            forGL_ForGL_ui.setOut(6)
            colored_text_line = self.run_text_line
            colored_text_no_color = ""
            color = forGL_ForGL_ui.DEFAULT_COLOR
            i = 0
            while (i < len(self.runStack)):
                _hx_str = ""
                if self.display_internal:
                    _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).internal_token
                else:
                    _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).visible_token
                no_color_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).internal_token
                color = forGL_ForGL_ui.getTypeColor((self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type)
                forGL_ForGL_ui.msg((("null" if _hx_str is None else _hx_str) + " "),color)
                colored_text_no_color = (("null" if colored_text_no_color is None else colored_text_no_color) + HxOverrides.stringOrNull(((Std.string(no_color_str) + " "))))
                i = (i + 1)
            forGL_ForGL_ui.setOut(-1)
            if self.export_as_code:
                _this = self.export_as_code_log
                x = forGL_TypedTokens(4,("# forGL Verb after changes for Export as Code  " + HxOverrides.stringOrNull(self.export_as_code_verb_name)))
                _this.append(x)
                _this = self.export_as_code_log
                x = forGL_TypedTokens(4,colored_text_no_color)
                _this.append(x)
                _this = self.export_as_code_log
                x = forGL_TypedTokens(4,("# forGL Verb exact Syntax  " + HxOverrides.stringOrNull(self.export_as_code_verb_name)))
                _this.append(x)
                export_words_needed = list()
                export_words_done = list()
                done = False
                work_tokens = list()
                work_stack = list()
                color = forGL_ForGL_ui.DEFAULT_COLOR
                i = 0
                while (i < len(self.runStack)):
                    _hx_str = ""
                    if self.display_internal:
                        _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).internal_token
                    else:
                        _hx_str = (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).visible_token
                    color = forGL_ForGL_ui.getTypeColor((self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type)
                    forGL_ForGL_ui.msg((Std.string(_hx_str) + " "),color)
                    work_tokens.append(_hx_str)
                    colored_text_no_color = (("null" if colored_text_no_color is None else colored_text_no_color) + HxOverrides.stringOrNull(((Std.string(_hx_str) + " "))))
                    if (((3 == (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type) or ((4 == (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type))) or ((6 == (self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type))):
                        export_words_needed.append(_hx_str)
                    _this = self.export_as_code_log
                    x = forGL_TypedTokens((self.runStack[i] if i >= 0 and i < len(self.runStack) else None).token_type,_hx_str)
                    _this.append(x)
                    i = (i + 1)
                lines = self.nl_Parse.resolveTokens(work_tokens,self.nlDict,work_stack,True)
                if (0 == len(export_words_needed)):
                    done = True
                while (not done):
                    text_lines = self.nl_Parse.resolveTokens(work_tokens,self.nlDict,work_stack,True)
                    self.repeat_found = self.nl_Parse.repeat_verb_found
                    if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                        forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not equal.\n"))
                        _hx_local_50 = self
                        _hx_local_51 = _hx_local_50.run_text_line
                        _hx_local_50.run_text_line = (_hx_local_51 + 1)
                        _hx_local_51
                        _hx_local_52 = self
                        _hx_local_53 = _hx_local_52.run_text_line
                        _hx_local_52.run_text_line = (_hx_local_53 + 1)
                        _hx_local_53
                    self.nl_Parse.resolveAssigns(work_stack)
                    done = True
            forGL_ForGL_ui.msg("\n")
            _hx_local_54 = self
            _hx_local_55 = _hx_local_54.run_text_line
            _hx_local_54.run_text_line = (_hx_local_55 + 1)
            _hx_local_55
            repeat_text_line = self.run_text_line
            if self.repeat_found:
                forGL_ForGL_ui.msg("\n")
                _hx_local_56 = self
                _hx_local_57 = _hx_local_56.run_text_line
                _hx_local_56.run_text_line = (_hx_local_57 + 1)
                _hx_local_57
            self.show_text_line = self.run_text_line
            self.prev_show1_data = ""
            forGL_ForGL_ui.msg("\n\n")
            _hx_local_58 = self
            _hx_local_59 = _hx_local_58.run_text_line
            _hx_local_58.run_text_line = (_hx_local_59 + 1)
            _hx_local_59
            _hx_local_60 = self
            _hx_local_61 = _hx_local_60.run_text_line
            _hx_local_60.run_text_line = (_hx_local_61 + 1)
            _hx_local_61
            self.dataStack = list()
            self.opStack = list()
            self.assignStack = list()
            self.nouns = list()
            self.dataOpNoun_text_line = self.run_text_line
            if self.show_stacks:
                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line,True)
                forGL_ForGL_ui.msg("\n\n\n")
                _hx_local_62 = self
                _hx_local_63 = _hx_local_62.run_text_line
                _hx_local_62.run_text_line = (_hx_local_63 + 3)
                _hx_local_62.run_text_line
            if self.repeat_found:
                repeat_text_line = self.run_text_line
                forGL_ForGL_ui.msg("\n")
                _hx_local_64 = self
                _hx_local_65 = _hx_local_64.run_text_line
                _hx_local_64.run_text_line = (_hx_local_65 + 1)
                _hx_local_65
            self.start_intp_time = (Date.now().date.timestamp() * 1000)
            self.last_view_DON_time = self.start_intp_time
            self.intp_ip = 0
            self.steps_done = 0
            self.steps_done_Verb = 0
            self.intp_return_result = 0
            intp_done = False
            while (not intp_done):
                apply_op = False
                i = 0
                ip = self.intp_ip
                while (ip < len(self.runStack)):
                    if self.single_step:
                        char_code = Sys.getChar(False)
                        if (27 == char_code):
                            self.single_step = False
                            char_code = Sys.getChar(False)
                        else:
                            if ((48 <= char_code) and ((char_code <= 57))):
                                self.delay_seconds = (char_code - 48)
                            char_code = Sys.getChar(False)
                    elif (0.0 < self.delay_seconds):
                        Sys.sleep(self.delay_seconds)
                    else:
                        self.view_DON_throttle = True
                    if (self.single_step or self.show_stacks):
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                    if (13 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        if (((((("if" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("for" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("switch" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("while" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("else" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("return" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                            _hx_local_66 = self
                            _hx_local_67 = _hx_local_66.steps_done
                            _hx_local_66.steps_done = (_hx_local_67 + 1)
                            _hx_local_67
                            ip = (ip + 1)
                            continue
                    if ((((9 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((10 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((11 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((8 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        _this = self.dataStack
                        x = forGL_DataItem((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int)
                        _this.append(x)
                        _hx_local_69 = self
                        _hx_local_70 = _hx_local_69.steps_done
                        _hx_local_69.steps_done = (_hx_local_70 + 1)
                        _hx_local_70
                        ip = (ip + 1)
                        continue
                    if (((6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((7 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                        if (0 == ((0 if ((name_to_find is None)) else len(name_to_find)))):
                            forGL_ForGL_ui.error((("INTERNAL ERROR: Internal Name of Noun " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)) + " is missing\n"))
                            _hx_local_72 = self
                            _hx_local_73 = _hx_local_72.run_text_line
                            _hx_local_72.run_text_line = (_hx_local_73 + 1)
                            _hx_local_73
                            name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                        nounsIdx = 0
                        runIdx = 0
                        already_known = False
                        while (nounsIdx < len(self.nouns)):
                            runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                            if (name_to_find == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token):
                                already_known = True
                                break
                            nounsIdx = (nounsIdx + 1)
                        local_inference = False
                        if ((not already_known) and ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                            local_inference = True
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type = 7
                            (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_noun_data = 0
                        if (False == already_known):
                            _this1 = self.nouns
                            _this1.append(ip)
                            if (6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                                self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns,True)
                            nounsIdx = (len(self.nouns) - 1)
                            runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                        if (not local_inference):
                            if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                if (0 < len(self.opStack)):
                                    self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                    name = ""
                                    if self.display_internal:
                                        name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                                    else:
                                        name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                                    if (0 < len(self.assignStack)):
                                        message = "\nInfo:  "
                                        message = (("null" if message is None else message) + ("null" if name is None else name))
                                        message = (("null" if message is None else message) + "  assigned\n")
                                        forGL_ForGL_ui.warning(message)
                                        _hx_local_77 = self
                                        _hx_local_78 = _hx_local_77.run_text_line
                                        _hx_local_77.run_text_line = (_hx_local_78 + 1)
                                        _hx_local_78
                                        _this2 = self.assignStack
                                        if (len(_this2) != 0):
                                            _this2.pop()
                                        self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    else:
                                        message1 = (("\nSyntax Problem:  " + ("null" if name is None else name)) + "  used with no value. = (assignment) is missing.\n")
                                        message1 = (("null" if message1 is None else message1) + "Or a Verb was spelled wrong and a loop may not end !\n")
                                        message1 = (("null" if message1 is None else message1) + "Solution: Please fix spelling OR add = with Punctuation at end.\n")
                                        message1 = (("null" if message1 is None else message1) + "Now trying as local Noun and assignment anyway to help.\n")
                                        forGL_ForGL_ui.error(message1)
                                        _hx_local_82 = self
                                        _hx_local_83 = _hx_local_82.run_text_line
                                        _hx_local_82.run_text_line = (_hx_local_83 + 1)
                                        _hx_local_83
                                        _hx_local_84 = self
                                        _hx_local_85 = _hx_local_84.run_text_line
                                        _hx_local_84.run_text_line = (_hx_local_85 + 1)
                                        _hx_local_85
                                        _hx_local_86 = self
                                        _hx_local_87 = _hx_local_86.run_text_line
                                        _hx_local_86.run_text_line = (_hx_local_87 + 1)
                                        _hx_local_87
                                        _hx_local_88 = self
                                        _hx_local_89 = _hx_local_88.run_text_line
                                        _hx_local_88.run_text_line = (_hx_local_89 + 1)
                                        _hx_local_89
                                        _hx_local_90 = self
                                        _hx_local_91 = _hx_local_90.run_text_line
                                        _hx_local_90.run_text_line = (_hx_local_91 + 1)
                                        _hx_local_91
                                        self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                        if (0 < len(self.dataStack)):
                                            dataIdx = (len(self.dataStack) - 1)
                                            data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float
                                            (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int
                                            if (9 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                                data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int)
                                            elif (10 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                                if (1 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int):
                                                    data = "true"
                                                else:
                                                    data = "false"
                                            else:
                                                data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float)
                                            _this3 = self.dataStack
                                            if (len(_this3) != 0):
                                                _this3.pop()
                                            forGL_ForGL_ui.warning((((((("\nSyntax WARNING:  " + ("null" if name is None else name)) + " used without a value.  GUESSING: ") + ("null" if name is None else name)) + " = ") + Std.string(data)) + " .\n"))
                                            _hx_local_92 = self
                                            _hx_local_93 = _hx_local_92.run_text_line
                                            _hx_local_92.run_text_line = (_hx_local_93 + 1)
                                            _hx_local_93
                                            _hx_local_94 = self
                                            _hx_local_95 = _hx_local_94.run_text_line
                                            _hx_local_94.run_text_line = (_hx_local_95 + 1)
                                            _hx_local_95
                                        else:
                                            message2 = (((("\nSyntax ERROR:  " + ("null" if name is None else name)) + " used without a value. Suggest ") + ("null" if name is None else name)) + " = your_data .  Stopping.\n")
                                            forGL_ForGL_ui.error(message2,1)
                                            _hx_local_96 = self
                                            _hx_local_97 = _hx_local_96.run_text_line
                                            _hx_local_96.run_text_line = (_hx_local_97 + 1)
                                            _hx_local_97
                                            _hx_local_98 = self
                                            _hx_local_99 = _hx_local_98.run_text_line
                                            _hx_local_98.run_text_line = (_hx_local_99 + 1)
                                            _hx_local_99
                                            self.intp_return_result = -4
                                            break
                            if (not (((((ip + 1) < ((len(self.runStack) - 1))) and ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((34 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))))):
                                if (8 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                    _this4 = self.dataStack
                                    x1 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                                    _this4.append(x1)
                                else:
                                    name1 = ""
                                    if self.display_internal:
                                        name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                                    else:
                                        name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                                    _this5 = self.dataStack
                                    x2 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,name1,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                                    _this5.append(x2)
                        _hx_local_100 = self
                        _hx_local_101 = _hx_local_100.steps_done
                        _hx_local_100.steps_done = (_hx_local_101 + 1)
                        _hx_local_101
                        ip = (ip + 1)
                        continue
                    apply_op = False
                    if ((2 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        op_to_do = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_op_means
                        if (((((12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((45 == op_to_do))) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                            apply_op = True
                            if self.show_stacks:
                                if self.show_details:
                                    forGL_ForGL_ui.msg((("   running Punctuation  " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                                    _hx_local_103 = self
                                    _hx_local_104 = _hx_local_103.run_text_line
                                    _hx_local_103.run_text_line = (_hx_local_104 + 1)
                                    _hx_local_104
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                            if (0 < len(self.assignStack)):
                                _this6 = self.opStack
                                _this7 = self.assignStack
                                x3 = (None if ((len(_this7) == 0)) else _this7.pop())
                                _this6.insert(0, x3)
                            if (0 < len(self.opStack)):
                                ops_result = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                def _hx_local_106():
                                    _hx_local_105 = ops_result
                                    if (Std.isOfType(_hx_local_105,Int) or ((_hx_local_105 is None))):
                                        _hx_local_105
                                    else:
                                        raise "Class cast error"
                                    return _hx_local_105
                                if (_hx_local_106() < 0):
                                    self.intp_return_result = ops_result
                                    break
                        else:
                            if (((32 == op_to_do) or ((33 == op_to_do))) or ((34 == op_to_do))):
                                if (33 == op_to_do):
                                    if (((7 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((6 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                        forGL_ForGL_ui.error("SYNTAX ERROR: Noun or local Noun must follow Assign into. Stopping\n")
                                        _hx_local_107 = self
                                        _hx_local_108 = _hx_local_107.run_text_line
                                        _hx_local_107.run_text_line = (_hx_local_108 + 1)
                                        _hx_local_108
                                        self.intp_return_result = -4
                                        break
                                    if (0 == len(self.dataStack)):
                                        if (0 == len(self.opStack)):
                                            forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available and nothing to make data. Stopping\n")
                                            _hx_local_109 = self
                                            _hx_local_110 = _hx_local_109.run_text_line
                                            _hx_local_109.run_text_line = (_hx_local_110 + 1)
                                            _hx_local_110
                                            self.intp_return_result = -4
                                            break
                                        self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                        if (0 == len(self.dataStack)):
                                            forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available. Stopping\n")
                                            _hx_local_111 = self
                                            _hx_local_112 = _hx_local_111.run_text_line
                                            _hx_local_111.run_text_line = (_hx_local_112 + 1)
                                            _hx_local_112
                                            self.intp_return_result = -4
                                            break
                                    if (0 < len(self.opStack)):
                                        self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                    assign_idx = (ip + 1)
                                    name_to_find1 = python_internal_ArrayImpl._get(self.runStack, (ip + 1)).internal_token
                                    nounsIdx1 = 0
                                    runIdx1 = 0
                                    already_known1 = False
                                    while (nounsIdx1 < len(self.nouns)):
                                        runIdx1 = (self.nouns[nounsIdx1] if nounsIdx1 >= 0 and nounsIdx1 < len(self.nouns) else None)
                                        if (name_to_find1 == (self.runStack[runIdx1] if runIdx1 >= 0 and runIdx1 < len(self.runStack) else None).internal_token):
                                            already_known1 = True
                                            assign_idx = runIdx1
                                            break
                                        nounsIdx1 = (nounsIdx1 + 1)
                                    if ((not already_known1) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                        _this8 = self.nouns
                                        _this8.append((ip + 1))
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_noun_data = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_str = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_str
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_float = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_float
                                    (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_int = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                    _this9 = self.dataStack
                                    if (len(_this9) != 0):
                                        _this9.pop()
                                    if (0 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type):
                                        if ((ip + 1) == assign_idx):
                                            python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type = 7
                                            _this10 = self.nouns
                                            _this10.append((ip + 1))
                                    if (2 == python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_type):
                                        next_op = python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_op_means
                                        if ((((45 == next_op) or ((46 == next_op))) or ((47 == next_op))) or ((48 == next_op))):
                                            ip = (ip + 3)
                                        else:
                                            ip = (ip + 2)
                                    else:
                                        ip = (ip + 2)
                                    _hx_local_117 = self
                                    _hx_local_118 = _hx_local_117.steps_done
                                    _hx_local_117.steps_done = (_hx_local_118 + 1)
                                    _hx_local_118
                                    continue
                                else:
                                    _this11 = self.assignStack
                                    _this11.append(ip)
                                    ip = (ip + 1)
                                    continue
                            elif (30 == op_to_do):
                                _this12 = self.dataStack
                                x4 = forGL_DataItem(11,"",Math.PI,0)
                                _this12.append(x4)
                                _hx_local_120 = self
                                _hx_local_121 = _hx_local_120.steps_done
                                _hx_local_120.steps_done = (_hx_local_121 + 1)
                                _hx_local_121
                                ip = (ip + 1)
                                continue
                            elif (31 == op_to_do):
                                _this13 = self.dataStack
                                x5 = forGL_DataItem(11,"",python_lib_Random.random(),0)
                                _this13.append(x5)
                                _hx_local_123 = self
                                _hx_local_124 = _hx_local_123.steps_done
                                _hx_local_123.steps_done = (_hx_local_124 + 1)
                                _hx_local_124
                                ip = (ip + 1)
                                continue
                            elif ((18 == op_to_do) or ((19 == op_to_do))):
                                if (18 == op_to_do):
                                    _this14 = self.old_opStackFrames
                                    x6 = len(self.opStack)
                                    _this14.append(x6)
                                    while (0 < len(self.opStack)):
                                        _this15 = self.old_opStack
                                        _this16 = self.opStack
                                        x7 = (None if ((len(_this16) == 0)) else _this16.pop(0))
                                        _this15.append(x7)
                                    _this17 = self.old_dataStackFrames
                                    x8 = len(self.dataStack)
                                    _this17.append(x8)
                                    while (0 < len(self.dataStack)):
                                        _this18 = self.old_dataStack
                                        _this19 = self.dataStack
                                        x9 = (None if ((len(_this19) == 0)) else _this19.pop(0))
                                        _this18.append(x9)
                                else:
                                    if (0 < len(self.opStack)):
                                        ops_result1 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                        def _hx_local_127():
                                            _hx_local_126 = ops_result1
                                            if (Std.isOfType(_hx_local_126,Int) or ((_hx_local_126 is None))):
                                                _hx_local_126
                                            else:
                                                raise "Class cast error"
                                            return _hx_local_126
                                        if (_hx_local_127() < 0):
                                            self.intp_return_result = ops_result1
                                            break
                                    num_to_do = 0
                                    if (0 < len(self.old_opStackFrames)):
                                        _this20 = self.old_opStackFrames
                                        num_to_do = (None if ((len(_this20) == 0)) else _this20.pop())
                                    while (0 < num_to_do):
                                        _this21 = self.opStack
                                        _this22 = self.old_opStack
                                        x10 = (None if ((len(_this22) == 0)) else _this22.pop())
                                        _this21.insert(0, x10)
                                        num_to_do = (num_to_do - 1)
                                    num_to_do = 0
                                    if (0 < len(self.old_dataStackFrames)):
                                        _this23 = self.old_dataStackFrames
                                        num_to_do = (None if ((len(_this23) == 0)) else _this23.pop())
                                    while (0 < num_to_do):
                                        _this24 = self.dataStack
                                        _this25 = self.old_dataStack
                                        x11 = (None if ((len(_this25) == 0)) else _this25.pop())
                                        _this24.insert(0, x11)
                                        num_to_do = (num_to_do - 1)
                                    if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                        choice_idx = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                        choice_name = (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).internal_token
                                        if (13 == (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_type):
                                            if (((("for" == choice_name) or (("if" == choice_name))) or (("switch" == choice_name))) or (("while" == choice_name))):
                                                if (("if" == choice_name) or (("while" == choice_name))):
                                                    if ((0 == len(self.dataStack)) or ((10 != python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type))):
                                                        forGL_ForGL_ui.error((("SYNTAX ERROR: " + Std.string(choice_name)) + " expression result is not Bool. Stopping.\n"))
                                                        _hx_local_130 = self
                                                        _hx_local_131 = _hx_local_130.run_text_line
                                                        _hx_local_130.run_text_line = (_hx_local_131 + 1)
                                                        _hx_local_131
                                                        forGL_ForGL_ui.msg((("Error location (word number) is " + Std.string(ip)) + "\n"))
                                                        _hx_local_132 = self
                                                        _hx_local_133 = _hx_local_132.run_text_line
                                                        _hx_local_132.run_text_line = (_hx_local_133 + 1)
                                                        _hx_local_133
                                                        _hx_local_134 = self
                                                        _hx_local_135 = _hx_local_134.run_text_line
                                                        _hx_local_134.run_text_line = (_hx_local_135 + self.nl_Parse.showWordsTable(self.runStack,True,True,False))
                                                        _hx_local_134.run_text_line
                                                        self.intp_return_result = -4
                                                        break
                                                    exp_bool = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                                    _this26 = self.dataStack
                                                    if (len(_this26) != 0):
                                                        _this26.pop()
                                                    if (1 == exp_bool):
                                                        ip = (ip + 1)
                                                        continue
                                                    else:
                                                        ip = (Math.floor((self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_float) + 1)
                                                        continue
                                                else:
                                                    forGL_ForGL_ui.error((("INTERNAL ERROR: " + Std.string(choice_name)) + " not implemented. Stopping.\n"))
                                                    _hx_local_137 = self
                                                    _hx_local_138 = _hx_local_137.run_text_line
                                                    _hx_local_137.run_text_line = (_hx_local_138 + 1)
                                                    _hx_local_138
                                                    self.intp_return_result = -10
                                                    break
                                        else:
                                            forGL_ForGL_ui.error("INTERNAL ERROR: Choice indicated but not referenced correctly. Stopping.\n")
                                            _hx_local_139 = self
                                            _hx_local_140 = _hx_local_139.run_text_line
                                            _hx_local_139.run_text_line = (_hx_local_140 + 1)
                                            _hx_local_140
                                            self.intp_return_result = -11
                                            break
                                    if (0 < len(self.opStack)):
                                        ops_result2 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,True)
                                        def _hx_local_142():
                                            _hx_local_141 = ops_result2
                                            if (Std.isOfType(_hx_local_141,Int) or ((_hx_local_141 is None))):
                                                _hx_local_141
                                            else:
                                                raise "Class cast error"
                                            return _hx_local_141
                                        if (_hx_local_142() < 0):
                                            self.intp_return_result = ops_result2
                                            break
                            elif (not (((22 == op_to_do) or ((23 == op_to_do))))):
                                if ((26 == op_to_do) or ((27 == op_to_do))):
                                    if (26 == op_to_do):
                                        _this27 = self.old_opStackFrames
                                        x12 = len(self.opStack)
                                        _this27.append(x12)
                                        while (0 < len(self.opStack)):
                                            _this28 = self.old_opStack
                                            _this29 = self.opStack
                                            x13 = (None if ((len(_this29) == 0)) else _this29.pop(0))
                                            _this28.append(x13)
                                        _this30 = self.old_dataStackFrames
                                        x14 = len(self.dataStack)
                                        _this30.append(x14)
                                        while (0 < len(self.dataStack)):
                                            _this31 = self.old_dataStack
                                            _this32 = self.dataStack
                                            x15 = (None if ((len(_this32) == 0)) else _this32.pop(0))
                                            _this31.append(x15)
                                    else:
                                        if (0 < len(self.opStack)):
                                            ops_result3 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                            def _hx_local_144():
                                                _hx_local_143 = ops_result3
                                                if (Std.isOfType(_hx_local_143,Int) or ((_hx_local_143 is None))):
                                                    _hx_local_143
                                                else:
                                                    raise "Class cast error"
                                                return _hx_local_143
                                            if (_hx_local_144() < 0):
                                                self.intp_return_result = ops_result3
                                                break
                                        if (0 < len(self.assignStack)):
                                            _this33 = self.assignStack
                                            r_idx = (None if ((len(_this33) == 0)) else _this33.pop())
                                            assign_op = (self.runStack[r_idx] if r_idx >= 0 and r_idx < len(self.runStack) else None).token_op_means
                                            self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns,assign_op)
                                        num_to_do1 = 0
                                        if (0 < len(self.old_opStackFrames)):
                                            _this34 = self.old_opStackFrames
                                            num_to_do1 = (None if ((len(_this34) == 0)) else _this34.pop())
                                        while (0 < num_to_do1):
                                            _this35 = self.opStack
                                            _this36 = self.old_opStack
                                            x16 = (None if ((len(_this36) == 0)) else _this36.pop())
                                            _this35.insert(0, x16)
                                            num_to_do1 = (num_to_do1 - 1)
                                        num_to_do1 = 0
                                        if (0 < len(self.old_dataStackFrames)):
                                            _this37 = self.old_dataStackFrames
                                            num_to_do1 = (None if ((len(_this37) == 0)) else _this37.pop())
                                        while (0 < num_to_do1):
                                            _this38 = self.dataStack
                                            _this39 = self.old_dataStack
                                            x17 = (None if ((len(_this39) == 0)) else _this39.pop())
                                            _this38.insert(0, x17)
                                            num_to_do1 = (num_to_do1 - 1)
                                        if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                            ip = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                            _hx_local_147 = self
                                            _hx_local_148 = _hx_local_147.steps_done
                                            _hx_local_147.steps_done = (_hx_local_148 + 1)
                                            _hx_local_148
                                            continue
                                        if (0.0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float):
                                            ip = (ip + Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float))
                                            _hx_local_150 = self
                                            _hx_local_151 = _hx_local_150.steps_done
                                            _hx_local_150.steps_done = (_hx_local_151 + 1)
                                            _hx_local_151
                                            continue
                                else:
                                    _this40 = self.opStack
                                    _this40.append(ip)
                                    if self.show_stacks:
                                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                                    ops_result4 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    def _hx_local_153():
                                        _hx_local_152 = ops_result4
                                        if (Std.isOfType(_hx_local_152,Int) or ((_hx_local_152 is None))):
                                            _hx_local_152
                                        else:
                                            raise "Class cast error"
                                        return _hx_local_152
                                    if (_hx_local_153() < 0):
                                        self.intp_return_result = ops_result4
                                        break
                            _hx_local_154 = self
                            _hx_local_155 = _hx_local_154.steps_done
                            _hx_local_154.steps_done = (_hx_local_155 + 1)
                            _hx_local_155
                            ip = (ip + 1)
                            continue
                    verb_pending = False
                    if (((4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        verb_pending = True
                        if (0 < len(self.opStack)):
                            apply_op = True
                            ip = (ip - 1)
                    if apply_op:
                        if (0 < len(self.opStack)):
                            ops_result5 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                            def _hx_local_159():
                                _hx_local_158 = ops_result5
                                if (Std.isOfType(_hx_local_158,Int) or ((_hx_local_158 is None))):
                                    _hx_local_158
                                else:
                                    raise "Class cast error"
                                return _hx_local_158
                            if (_hx_local_159() < 0):
                                self.intp_return_result = ops_result5
                                break
                            ip = (ip + 1)
                            continue
                    if (((4 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) and ((3 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                        ip = (ip + 1)
                        continue
                    verb_move_ahead = 1
                    if (5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        is_call_style = False
                        call_args = ""
                        if ((ip + 2) < len(self.runStack)):
                            if ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((18 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))):
                                is_call_style = True
                                result = self.argsOrData((ip + 1),self.runStack,self.dataStack,self.opStack)
                                verb_move_ahead = result
                                call_args = self.argsOrData_Str()
                        if (False == is_call_style):
                            if (0 < len(self.dataStack)):
                                call_args = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).toStr()
                            else:
                                result1 = self.argsOrData((ip + 1),self.runStack,self.dataStack,self.opStack)
                                verb_move_ahead = (result1 + 1)
                                call_args = self.argsOrData_Str()
                        verb_name = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                        if self.display_internal:
                            verb_name = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                        if self.show_details:
                            msg_str = "\n"
                            if (0 < len(self.callStack)):
                                msg_str = hx_strings_Strings.insertAt(msg_str,(0 if ((msg_str is None)) else len(msg_str)),Std.string(self.arrToStrSep(self.callStack," > ")))
                            forGL_ForGL_ui.msg((((((Std.string(msg_str) + " > ") + Std.string(verb_name)) + " ( ") + Std.string(call_args)) + " )\n"))
                            _hx_local_162 = self
                            _hx_local_163 = _hx_local_162.run_text_line
                            _hx_local_162.run_text_line = (_hx_local_163 + 1)
                            _hx_local_163
                            _hx_local_164 = self
                            _hx_local_165 = _hx_local_164.run_text_line
                            _hx_local_164.run_text_line = (_hx_local_165 + 1)
                            _hx_local_165
                        _this41 = self.callStack
                        _this41.append(verb_name)
                        self.addName(self.exportStack,verb_name)
                    if (4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        verb_text = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str
                        if (0 == ((0 if ((verb_text is None)) else len(verb_text)))):
                            forGL_ForGL_ui.error(("\nSYNTAX ERROR: No text for for Verb: " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)))
                            ip = (ip + verb_move_ahead)
                            continue
                        verb_tokens = self.nl_Parse.parse(verb_text,forGL_ParseStyle.PARSE_LEFT_TO_RIGHT,False)
                        if (0 == len(verb_tokens)):
                            ip = (ip + verb_move_ahead)
                            continue
                        self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                        old_length = len(self.runStack)
                        _hx_local_168 = self
                        _hx_local_169 = _hx_local_168.run_text_line
                        _hx_local_168.run_text_line = (_hx_local_169 + self.nl_Parse.resolveTokens(verb_tokens,self.nlDict,self.runStack,self.run_verbose))
                        _hx_local_168.run_text_line
                        self.repeat_found = self.nl_Parse.repeat_verb_found
                        if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                            forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not same.\n"))
                            _hx_local_170 = self
                            _hx_local_171 = _hx_local_170.run_text_line
                            _hx_local_170.run_text_line = (_hx_local_171 + 1)
                            _hx_local_171
                            _hx_local_172 = self
                            _hx_local_173 = _hx_local_172.run_text_line
                            _hx_local_172.run_text_line = (_hx_local_173 + 1)
                            _hx_local_173
                        self.nl_Parse.resolveAssigns(self.runStack)
                        choice_result = -11
                        choice_result = self.nl_Parse.resolveChoice(self.runStack)
                        def _hx_local_175():
                            _hx_local_174 = choice_result
                            if (Std.isOfType(_hx_local_174,Int) or ((_hx_local_174 is None))):
                                _hx_local_174
                            else:
                                raise "Class cast error"
                            return _hx_local_174
                        if (0 > _hx_local_175()):
                            self.intp_return_result = choice_result
                            break
                        if (0 >= len(self.runStack)):
                            forGL_ForGL_ui.error("\nSYNTAX ERROR: Nothing to run. Stopping\n")
                            self.intp_return_result = -4
                            break
                        if self.show_words_table:
                            _hx_local_176 = self
                            _hx_local_177 = _hx_local_176.run_text_line
                            _hx_local_176.run_text_line = (_hx_local_177 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,False))
                            _hx_local_176.run_text_line
                        elif self.export_as_code:
                            _hx_local_178 = self
                            _hx_local_179 = _hx_local_178.run_text_line
                            _hx_local_178.run_text_line = (_hx_local_179 + self.nl_Parse.showWordsTable(self.runStack,True,False,self.export_as_code))
                            _hx_local_178.run_text_line
                            j = 0
                            exp_text = ""
                            while (j < len(self.runStack)):
                                _hx_str = ""
                                if self.display_internal:
                                    _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).internal_token
                                    if ("" == _hx_str):
                                        _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                                else:
                                    _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                                exp_text = (("null" if exp_text is None else exp_text) + HxOverrides.stringOrNull(((("null" if _hx_str is None else _hx_str) + " "))))
                                j = (j + 1)
                            _this42 = self.export_as_code_log
                            x18 = forGL_TypedTokens((self.runStack[j] if j >= 0 and j < len(self.runStack) else None).token_type,exp_text)
                            _this42.append(x18)
                        _this43 = self.runStack
                        x19 = forGL_NLToken("","","","",0.0,0,0,0,0)
                        _this43.append(x19)
                        rIdx = (len(self.runStack) - 1)
                        new_length = len(self.runStack)
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_type = 5
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).internal_token = "return"
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).visible_token = "return"
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_int = ((ip + 1) + verb_move_ahead)
                        (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_float = (new_length - old_length)
                        _this44 = self.old_assignStackFrames
                        x20 = len(self.assignStack)
                        _this44.append(x20)
                        while (0 < len(self.assignStack)):
                            _this45 = self.old_assignStack
                            _this46 = self.assignStack
                            x21 = (None if ((len(_this46) == 0)) else _this46.pop(0))
                            _this45.append(x21)
                        _this47 = self.old_nounStackFrames
                        x22 = len(self.nouns)
                        _this47.append(x22)
                        while (0 < len(self.nouns)):
                            _this48 = self.old_nounStack
                            _this49 = self.nouns
                            x23 = (None if ((len(_this49) == 0)) else _this49.pop(0))
                            _this48.append(x23)
                        _this50 = self.old_opStackFrames
                        x24 = len(self.opStack)
                        _this50.append(x24)
                        while (0 < len(self.opStack)):
                            _this51 = self.old_opStack
                            _this52 = self.opStack
                            x25 = (None if ((len(_this52) == 0)) else _this52.pop(0))
                            _this51.append(x25)
                        ip = old_length
                        continue
                    elif (5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                        num_to_do2 = len(self.nouns)
                        while (0 < num_to_do2):
                            _this53 = self.nouns
                            if (len(_this53) != 0):
                                _this53.pop()
                            num_to_do2 = (num_to_do2 - 1)
                        num_to_do2 = 0
                        if (0 < len(self.old_assignStackFrames)):
                            _this54 = self.old_assignStackFrames
                            num_to_do2 = (None if ((len(_this54) == 0)) else _this54.pop())
                        while (0 < num_to_do2):
                            _this55 = self.assignStack
                            _this56 = self.old_assignStack
                            x26 = (None if ((len(_this56) == 0)) else _this56.pop())
                            _this55.insert(0, x26)
                            num_to_do2 = (num_to_do2 - 1)
                        num_to_do2 = 0
                        if (0 < len(self.old_nounStackFrames)):
                            _this57 = self.old_nounStackFrames
                            num_to_do2 = (None if ((len(_this57) == 0)) else _this57.pop())
                        while (0 < num_to_do2):
                            _this58 = self.nouns
                            _this59 = self.old_nounStack
                            x27 = (None if ((len(_this59) == 0)) else _this59.pop())
                            _this58.insert(0, x27)
                            num_to_do2 = (num_to_do2 - 1)
                        num_to_do2 = 0
                        if (0 < len(self.old_opStackFrames)):
                            _this60 = self.old_opStackFrames
                            num_to_do2 = (None if ((len(_this60) == 0)) else _this60.pop())
                        while (0 < num_to_do2):
                            _this61 = self.opStack
                            _this62 = self.old_opStack
                            x28 = (None if ((len(_this62) == 0)) else _this62.pop())
                            _this61.insert(0, x28)
                            num_to_do2 = (num_to_do2 - 1)
                        _this63 = self.callStack
                        if (len(_this63) != 0):
                            _this63.pop()
                        new_ip = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int
                        num_to_remove = Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float)
                        num_to_do2 = num_to_remove
                        while (0 < num_to_do2):
                            _this64 = self.runStack
                            if (len(_this64) != 0):
                                _this64.pop()
                            num_to_do2 = (num_to_do2 - 1)
                        self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns)
                        if ((len(self.runStack) - 1) < new_ip):
                            break
                        ip = new_ip
                        continue
                    elif (3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        if ("repeat" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                            if (self.repeat_limit < 0):
                                if (0 < len(self.dataStack)):
                                    repeat_data_type = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                                    if (9 == repeat_data_type):
                                        if (0 <= python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int):
                                            self.repeat_limit_found = True
                                            self.repeat_limit = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                if (self.repeat_limit < 0):
                                    self.repeat_limit = 0
                            _hx_local_187 = self
                            _hx_local_188 = _hx_local_187.repeat_count
                            _hx_local_187.repeat_count = (_hx_local_188 + 1)
                            _hx_local_188
                            if (self.repeat_count <= self.repeat_limit):
                                if self.repeat_limit_found:
                                    _this65 = self.dataStack
                                    if (len(_this65) != 0):
                                        _this65.pop()
                                i = (len(self.nouns) - 1)
                                while (0 <= i):
                                    nounIdx = (self.nouns[i] if i >= 0 and i < len(self.nouns) else None)
                                    if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                                        (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type = 0
                                        python_internal_ArrayImpl.remove(self.nouns,nounIdx)
                                    i = (i - 1)
                                if (0 < len(self.nouns)):
                                    if self.show_stacks:
                                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                                if (0 < len(self.opStack)):
                                    forGL_ForGL_ui.warning((("WARNING: Doing Repeat with leftover Operators: " + Std.string(self.opStackToString(self.runStack,self.opStack))) + "\n"))
                                    _hx_local_190 = self
                                    _hx_local_191 = _hx_local_190.run_text_line
                                    _hx_local_190.run_text_line = (_hx_local_191 + 1)
                                    _hx_local_191
                                forGL_ForGL_ui.msg("\r")
                                forGL_ForGL_ui.msg((Std.string(self.repeat_count) + "\t"))
                                ip = 0
                                continue
                            elif self.repeat_limit_found:
                                _this66 = self.dataStack
                                if (len(_this66) != 0):
                                    _this66.pop()
                        elif (("show" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                            showing = True
                            if ("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                                showing = False
                                forGL_ForGL_ui.msg("\n        Data  Stack\n")
                                _hx_local_192 = self
                                _hx_local_193 = _hx_local_192.run_text_line
                                _hx_local_192.run_text_line = (_hx_local_193 + 1)
                                _hx_local_193
                                _hx_local_194 = self
                                _hx_local_195 = _hx_local_194.run_text_line
                                _hx_local_194.run_text_line = (_hx_local_195 + 1)
                                _hx_local_195
                            i = (len(self.dataStack) - 1)
                            while (i >= 0):
                                dataIdx1 = i
                                dataStr = ""
                                if (9 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int)
                                elif (10 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = "false"
                                    if (1 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int):
                                        dataStr = "true"
                                elif (11 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_float)
                                elif (8 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    dataStr = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                    if showing:
                                        dataStr = self.trimQuotes(dataStr)
                                else:
                                    forGL_ForGL_ui.error(" \nINTERNAL ERROR: Data not Float, Integer, Bool or String\n")
                                    _hx_local_196 = self
                                    _hx_local_197 = _hx_local_196.run_text_line
                                    _hx_local_196.run_text_line = (_hx_local_197 + 1)
                                    _hx_local_197
                                    _hx_local_198 = self
                                    _hx_local_199 = _hx_local_198.run_text_line
                                    _hx_local_198.run_text_line = (_hx_local_199 + 1)
                                    _hx_local_199
                                    i = (i - 1)
                                    continue
                                if showing:
                                    if (0 < ((0 if ((dataStr is None)) else len(dataStr)))):
                                        self.show1Data(dataStr,self.show_text_line)
                                    if self.export_as_code:
                                        exp = dataStr
                                        tmp = None
                                        if (8 != (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                            this1 = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                            tmp = (0 < ((0 if ((this1 is None)) else len(this1))))
                                        else:
                                            tmp = False
                                        if tmp:
                                            exp = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                        _this67 = self.export_as_code_log
                                        x29 = forGL_TypedTokens(3,(("show ( " + ("null" if exp is None else exp)) + " )"))
                                        _this67.append(x29)
                                    _this68 = self.dataStack
                                    if (len(_this68) != 0):
                                        _this68.pop()
                                    break
                                else:
                                    forGL_ForGL_ui.msg((("null" if dataStr is None else dataStr) + "\n"))
                                    _hx_local_201 = self
                                    _hx_local_202 = _hx_local_201.run_text_line
                                    _hx_local_201.run_text_line = (_hx_local_202 + 1)
                                    _hx_local_202
                                i = (i - 1)
                            _this69 = self.callStack
                            if (len(_this69) != 0):
                                _this69.pop()
                        elif (("inspect" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)):
                            # Extract variable name (if provided)
                            ommand_tokens = self.runStack[ip]
                            variable_name = command_tokens.internal_token if len(command_tokens.token_str) > 0 else None
    
                            # Call the inspectRuntime method to display variables
                            self.inspectRuntime(variable_name)
                    if (0 >= verb_move_ahead):
                        forGL_ForGL_ui.error((("INTERNAL ERROR: verb_move_ahead = " + Std.string(verb_move_ahead)) + "\n"))
                        verb_move_ahead = 1
                    ip = (ip + verb_move_ahead)
                self.intp_ip = ip
                forGL_ForGL_ui.outputBuffersUsed()
                if (self.intp_ip >= len(self.runStack)):
                    break
                def _hx_local_206():
                    _hx_local_205 = self.intp_return_result
                    if (Std.isOfType(_hx_local_205,Int) or ((_hx_local_205 is None))):
                        _hx_local_205
                    else:
                        raise "Class cast error"
                    return _hx_local_205
                if (0 != _hx_local_206()):
                    break
            ret_val = self.runDef_End()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in runDef(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def runDef_End(self):
        ret_val = self.intp_return_result
        forGL_ForGL_ui.msg("\n   Finished. No more Natural Language words to process.\n")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.run_text_line
        _hx_local_0.run_text_line = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.run_text_line
        _hx_local_2.run_text_line = (_hx_local_3 + 1)
        _hx_local_3
        self.show_stacks_Data_Only = False
        if self.show_stacks:
            self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line,True)
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.run_text_line
            _hx_local_4.run_text_line = (_hx_local_5 + 1)
            _hx_local_5
            self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.run_text_line,True)
            forGL_ForGL_ui.msg("\n\n\n")
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.run_text_line
            _hx_local_6.run_text_line = (_hx_local_7 + 3)
            _hx_local_6.run_text_line
        forGL_ForGL_ui.goToPos(self.run_text_line,0)
        if (len(self.dataStack) > 0):
            data_count = len(self.dataStack)
            if (data_count > 1):
                message = (("There are " + Std.string(data_count)) + " Data items.\n")
                message = (("null" if message is None else message) + "You can use the Show built in Verb to take 1 item off the stack and Show it.\n")
                message = (("null" if message is None else message) + "You can use the View built in Verb to View all the stacks with no changes.\n")
                forGL_ForGL_ui.msg(message)
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.run_text_line
                _hx_local_10.run_text_line = (_hx_local_11 + 1)
                _hx_local_11
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.run_text_line
                _hx_local_12.run_text_line = (_hx_local_13 + 1)
                _hx_local_13
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.run_text_line
                _hx_local_14.run_text_line = (_hx_local_15 + 1)
                _hx_local_15
        if (len(self.nouns) > 0):
            nounIdx = python_internal_ArrayImpl._get(self.nouns, (len(self.nouns) - 1))
            if self.display_internal:
                forGL_ForGL_ui.msg((Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).internal_token) + " "),forGL_ForGL_ui.NOUN_COLOR)
            else:
                forGL_ForGL_ui.msg((Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token) + " "),forGL_ForGL_ui.NOUN_COLOR)
            forGL_ForGL_ui.msg((("is " + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_noun_data))) + " "))
            _g = (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_noun_data
            if (_g == 0):
                if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                    forGL_ForGL_ui.warning((("\nWARNING: Local Noun  " + Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token)) + "  had no value. Likely not used?"))
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.run_text_line
                    _hx_local_16.run_text_line = (_hx_local_17 + 1)
                    _hx_local_17
                elif (6 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                    forGL_ForGL_ui.error((("\nINTERNAL ERROR: Noun  " + Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).visible_token)) + "  data is unknown."))
                    _hx_local_18 = self
                    _hx_local_19 = _hx_local_18.run_text_line
                    _hx_local_18.run_text_line = (_hx_local_19 + 1)
                    _hx_local_19
            elif (_g == 8):
                forGL_ForGL_ui.msg((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_str,forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 9):
                forGL_ForGL_ui.msg(Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_int),forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 10):
                if (1 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_int):
                    forGL_ForGL_ui.msg("true",forGL_ForGL_ui.DATA_COLOR)
                else:
                    forGL_ForGL_ui.msg("false",forGL_ForGL_ui.DATA_COLOR)
            elif (_g == 11):
                forGL_ForGL_ui.msg(Std.string((self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_float),forGL_ForGL_ui.DATA_COLOR)
            else:
                forGL_ForGL_ui.error("\nINTERNAL ERROR: Wrong type of Noun data")
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.run_text_line
                _hx_local_20.run_text_line = (_hx_local_21 + 1)
                _hx_local_21
            forGL_ForGL_ui.msg("\n")
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.run_text_line
            _hx_local_22.run_text_line = (_hx_local_23 + 1)
            _hx_local_23
        if (0 < len(self.opStack)):
            forGL_ForGL_ui.msg((("\n   There are " + Std.string(len(self.opStack))) + " Operations not done.\n"))
            forGL_ForGL_ui.msg("This usually indicates a logical problem with the Verb (code).\n")
            forGL_ForGL_ui.msg("If you have gotten any ERRORS or WARNINGS those will guide you.")
        end_intp_time = (Date.now().date.timestamp() * 1000)
        self.elapsed_intp_time = (((end_intp_time - self.start_intp_time)) / 1000.0)
        elapsed = Math.floor((self.elapsed_intp_time * 1000.0))
        self.elapsed_intp_time = (elapsed / 1000.0)
        forGL_ForGL_ui.msg((((((("  ... Elapsed       Run time " + Std.string(self.elapsed_intp_time)) + " Seconds of ") + Std.string(self.steps_done)) + " Internal and ") + Std.string(self.steps_done_Verb)) + " Verb steps.\n"))
        return ret_val

    def runInterpreter(self):
        apply_op = False
        i = 0
        ip = self.intp_ip
        while (ip < len(self.runStack)):
            if self.single_step:
                char_code = Sys.getChar(False)
                if (27 == char_code):
                    self.single_step = False
                    char_code = Sys.getChar(False)
                else:
                    if ((48 <= char_code) and ((char_code <= 57))):
                        self.delay_seconds = (char_code - 48)
                    char_code = Sys.getChar(False)
            elif (0.0 < self.delay_seconds):
                Sys.sleep(self.delay_seconds)
            else:
                self.view_DON_throttle = True
            if (self.single_step or self.show_stacks):
                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
            if (13 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                if (((((("if" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("for" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("switch" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("while" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("else" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))) or (("return" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.steps_done
                    _hx_local_0.steps_done = (_hx_local_1 + 1)
                    _hx_local_1
                    ip = (ip + 1)
                    continue
            if ((((9 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((10 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((11 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((8 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                _this = self.dataStack
                x = forGL_DataItem((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float,(self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int)
                _this.append(x)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.steps_done
                _hx_local_3.steps_done = (_hx_local_4 + 1)
                _hx_local_4
                ip = (ip + 1)
                continue
            if (((6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((7 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                if (0 == ((0 if ((name_to_find is None)) else len(name_to_find)))):
                    forGL_ForGL_ui.error((("INTERNAL ERROR: Internal Name of Noun " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)) + " is missing\n"))
                    _hx_local_6 = self
                    _hx_local_7 = _hx_local_6.run_text_line
                    _hx_local_6.run_text_line = (_hx_local_7 + 1)
                    _hx_local_7
                    name_to_find = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                nounsIdx = 0
                runIdx = 0
                already_known = False
                while (nounsIdx < len(self.nouns)):
                    runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                    if (name_to_find == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token):
                        already_known = True
                        break
                    nounsIdx = (nounsIdx + 1)
                local_inference = False
                if ((not already_known) and ((0 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                    local_inference = True
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type = 7
                    (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_noun_data = 0
                if (False == already_known):
                    _this1 = self.nouns
                    _this1.append(ip)
                    if (6 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                        self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns,True)
                    nounsIdx = (len(self.nouns) - 1)
                    runIdx = (self.nouns[nounsIdx] if nounsIdx >= 0 and nounsIdx < len(self.nouns) else None)
                    if self.show_stacks:
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                if (not local_inference):
                    if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                        if (0 < len(self.opStack)):
                            self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                        if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                            name = ""
                            if self.display_internal:
                                name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                            else:
                                name = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                            if (0 < len(self.assignStack)):
                                message = "\nInfo:  "
                                message = (("null" if message is None else message) + ("null" if name is None else name))
                                message = (("null" if message is None else message) + "  assigned\n")
                                forGL_ForGL_ui.warning(message)
                                _hx_local_11 = self
                                _hx_local_12 = _hx_local_11.run_text_line
                                _hx_local_11.run_text_line = (_hx_local_12 + 1)
                                _hx_local_12
                                _this2 = self.assignStack
                                if (len(_this2) != 0):
                                    _this2.pop()
                                self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                            else:
                                message1 = (("\nSyntax Problem:  " + ("null" if name is None else name)) + "  used with no value. = (assignment) is missing.\n")
                                message1 = (("null" if message1 is None else message1) + "Or a Verb was spelled wrong and a loop may not end !\n")
                                message1 = (("null" if message1 is None else message1) + "Solution: Please fix spelling OR add = with Punctuation at end.\n")
                                message1 = (("null" if message1 is None else message1) + "Now trying as local Noun and assignment anyway to help.\n")
                                forGL_ForGL_ui.error(message1)
                                _hx_local_16 = self
                                _hx_local_17 = _hx_local_16.run_text_line
                                _hx_local_16.run_text_line = (_hx_local_17 + 1)
                                _hx_local_17
                                _hx_local_18 = self
                                _hx_local_19 = _hx_local_18.run_text_line
                                _hx_local_18.run_text_line = (_hx_local_19 + 1)
                                _hx_local_19
                                _hx_local_20 = self
                                _hx_local_21 = _hx_local_20.run_text_line
                                _hx_local_20.run_text_line = (_hx_local_21 + 1)
                                _hx_local_21
                                _hx_local_22 = self
                                _hx_local_23 = _hx_local_22.run_text_line
                                _hx_local_22.run_text_line = (_hx_local_23 + 1)
                                _hx_local_23
                                _hx_local_24 = self
                                _hx_local_25 = _hx_local_24.run_text_line
                                _hx_local_24.run_text_line = (_hx_local_25 + 1)
                                _hx_local_25
                                self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns)
                            if (0 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                                if (0 < len(self.dataStack)):
                                    dataIdx = (len(self.dataStack) - 1)
                                    data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_str
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float
                                    (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int = (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int
                                    if (9 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                        data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int)
                                    elif (10 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_type):
                                        if (1 == (self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_int):
                                            data = "true"
                                        else:
                                            data = "false"
                                    else:
                                        data = Std.string((self.dataStack[dataIdx] if dataIdx >= 0 and dataIdx < len(self.dataStack) else None).data_float)
                                    _this3 = self.dataStack
                                    if (len(_this3) != 0):
                                        _this3.pop()
                                    forGL_ForGL_ui.warning((((((("\nSyntax WARNING:  " + ("null" if name is None else name)) + " used without a value.  GUESSING: ") + ("null" if name is None else name)) + " = ") + Std.string(data)) + " .\n"))
                                    _hx_local_26 = self
                                    _hx_local_27 = _hx_local_26.run_text_line
                                    _hx_local_26.run_text_line = (_hx_local_27 + 1)
                                    _hx_local_27
                                    _hx_local_28 = self
                                    _hx_local_29 = _hx_local_28.run_text_line
                                    _hx_local_28.run_text_line = (_hx_local_29 + 1)
                                    _hx_local_29
                                else:
                                    message2 = (((("\nSyntax ERROR:  " + ("null" if name is None else name)) + " used without a value. Suggest ") + ("null" if name is None else name)) + " = your_data .  Stopping.\n")
                                    forGL_ForGL_ui.error(message2,1)
                                    _hx_local_30 = self
                                    _hx_local_31 = _hx_local_30.run_text_line
                                    _hx_local_30.run_text_line = (_hx_local_31 + 1)
                                    _hx_local_31
                                    _hx_local_32 = self
                                    _hx_local_33 = _hx_local_32.run_text_line
                                    _hx_local_32.run_text_line = (_hx_local_33 + 1)
                                    _hx_local_33
                                    self.intp_return_result = -4
                                    break
                    if (not (((((ip + 1) < ((len(self.runStack) - 1))) and ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((34 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))))):
                        if (8 == (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data):
                            _this4 = self.dataStack
                            x1 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_str,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                            _this4.append(x1)
                        else:
                            name1 = ""
                            if self.display_internal:
                                name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).internal_token
                            else:
                                name1 = (self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).visible_token
                            _this5 = self.dataStack
                            x2 = forGL_DataItem((self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_noun_data,name1,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_float,(self.runStack[runIdx] if runIdx >= 0 and runIdx < len(self.runStack) else None).token_int)
                            _this5.append(x2)
                _hx_local_34 = self
                _hx_local_35 = _hx_local_34.steps_done
                _hx_local_34.steps_done = (_hx_local_35 + 1)
                _hx_local_35
                ip = (ip + 1)
                continue
            apply_op = False
            if ((2 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                op_to_do = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_op_means
                if (((((12 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((45 == op_to_do))) or ((46 == op_to_do))) or ((47 == op_to_do))) or ((48 == op_to_do))):
                    apply_op = True
                    if self.show_stacks:
                        if self.show_details:
                            forGL_ForGL_ui.msg((("   running Punctuation  " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token)) + "\n"))
                            _hx_local_37 = self
                            _hx_local_38 = _hx_local_37.run_text_line
                            _hx_local_37.run_text_line = (_hx_local_38 + 1)
                            _hx_local_38
                        self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                    if (0 < len(self.assignStack)):
                        _this6 = self.opStack
                        _this7 = self.assignStack
                        x3 = (None if ((len(_this7) == 0)) else _this7.pop())
                        _this6.insert(0, x3)
                    if (0 < len(self.opStack)):
                        ops_result = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                        def _hx_local_40():
                            _hx_local_39 = ops_result
                            if (Std.isOfType(_hx_local_39,Int) or ((_hx_local_39 is None))):
                                _hx_local_39
                            else:
                                raise "Class cast error"
                            return _hx_local_39
                        if (_hx_local_40() < 0):
                            self.intp_return_result = ops_result
                            break
                else:
                    if (((32 == op_to_do) or ((33 == op_to_do))) or ((34 == op_to_do))):
                        if (33 == op_to_do):
                            if (((7 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))) and ((6 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                forGL_ForGL_ui.error("SYNTAX ERROR: Noun or local Noun must follow Assign into. Stopping\n")
                                _hx_local_41 = self
                                _hx_local_42 = _hx_local_41.run_text_line
                                _hx_local_41.run_text_line = (_hx_local_42 + 1)
                                _hx_local_42
                                self.intp_return_result = -4
                                break
                            if (0 == len(self.dataStack)):
                                if (0 == len(self.opStack)):
                                    forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available and nothing to make data. Stopping\n")
                                    _hx_local_43 = self
                                    _hx_local_44 = _hx_local_43.run_text_line
                                    _hx_local_43.run_text_line = (_hx_local_44 + 1)
                                    _hx_local_44
                                    self.intp_return_result = -4
                                    break
                                self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                                if (0 == len(self.dataStack)):
                                    forGL_ForGL_ui.error("\nSYNTAX ERROR: Assign into has no data available. Stopping\n")
                                    _hx_local_45 = self
                                    _hx_local_46 = _hx_local_45.run_text_line
                                    _hx_local_45.run_text_line = (_hx_local_46 + 1)
                                    _hx_local_46
                                    self.intp_return_result = -4
                                    break
                            if (0 < len(self.opStack)):
                                self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,False,True)
                            assign_idx = (ip + 1)
                            name_to_find1 = python_internal_ArrayImpl._get(self.runStack, (ip + 1)).internal_token
                            nounsIdx1 = 0
                            runIdx1 = 0
                            already_known1 = False
                            while (nounsIdx1 < len(self.nouns)):
                                runIdx1 = (self.nouns[nounsIdx1] if nounsIdx1 >= 0 and nounsIdx1 < len(self.nouns) else None)
                                if (name_to_find1 == (self.runStack[runIdx1] if runIdx1 >= 0 and runIdx1 < len(self.runStack) else None).internal_token):
                                    already_known1 = True
                                    assign_idx = runIdx1
                                    break
                                nounsIdx1 = (nounsIdx1 + 1)
                            if ((not already_known1) and ((0 != python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type))):
                                _this8 = self.nouns
                                _this8.append((ip + 1))
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_noun_data = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_str = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_str
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_float = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_float
                            (self.runStack[assign_idx] if assign_idx >= 0 and assign_idx < len(self.runStack) else None).token_int = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                            _this9 = self.dataStack
                            if (len(_this9) != 0):
                                _this9.pop()
                            if (0 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type):
                                if ((ip + 1) == assign_idx):
                                    python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type = 7
                                    _this10 = self.nouns
                                    _this10.append((ip + 1))
                            if (2 == python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_type):
                                next_op = python_internal_ArrayImpl._get(self.runStack, (ip + 2)).token_op_means
                                if ((((45 == next_op) or ((46 == next_op))) or ((47 == next_op))) or ((48 == next_op))):
                                    ip = (ip + 3)
                                else:
                                    ip = (ip + 2)
                            else:
                                ip = (ip + 2)
                            _hx_local_51 = self
                            _hx_local_52 = _hx_local_51.steps_done
                            _hx_local_51.steps_done = (_hx_local_52 + 1)
                            _hx_local_52
                            continue
                        else:
                            _this11 = self.assignStack
                            _this11.append(ip)
                            ip = (ip + 1)
                            continue
                    elif (30 == op_to_do):
                        _this12 = self.dataStack
                        x4 = forGL_DataItem(11,"",Math.PI,0)
                        _this12.append(x4)
                        _hx_local_54 = self
                        _hx_local_55 = _hx_local_54.steps_done
                        _hx_local_54.steps_done = (_hx_local_55 + 1)
                        _hx_local_55
                        ip = (ip + 1)
                        continue
                    elif (31 == op_to_do):
                        _this13 = self.dataStack
                        x5 = forGL_DataItem(11,"",python_lib_Random.random(),0)
                        _this13.append(x5)
                        _hx_local_57 = self
                        _hx_local_58 = _hx_local_57.steps_done
                        _hx_local_57.steps_done = (_hx_local_58 + 1)
                        _hx_local_58
                        ip = (ip + 1)
                        continue
                    elif ((18 == op_to_do) or ((19 == op_to_do))):
                        if (18 == op_to_do):
                            _this14 = self.old_opStackFrames
                            x6 = len(self.opStack)
                            _this14.append(x6)
                            while (0 < len(self.opStack)):
                                _this15 = self.old_opStack
                                _this16 = self.opStack
                                x7 = (None if ((len(_this16) == 0)) else _this16.pop(0))
                                _this15.append(x7)
                            _this17 = self.old_dataStackFrames
                            x8 = len(self.dataStack)
                            _this17.append(x8)
                            while (0 < len(self.dataStack)):
                                _this18 = self.old_dataStack
                                _this19 = self.dataStack
                                x9 = (None if ((len(_this19) == 0)) else _this19.pop(0))
                                _this18.append(x9)
                        else:
                            if (0 < len(self.opStack)):
                                ops_result1 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                def _hx_local_61():
                                    _hx_local_60 = ops_result1
                                    if (Std.isOfType(_hx_local_60,Int) or ((_hx_local_60 is None))):
                                        _hx_local_60
                                    else:
                                        raise "Class cast error"
                                    return _hx_local_60
                                if (_hx_local_61() < 0):
                                    self.intp_return_result = ops_result1
                                    break
                            num_to_do = 0
                            if (0 < len(self.old_opStackFrames)):
                                _this20 = self.old_opStackFrames
                                num_to_do = (None if ((len(_this20) == 0)) else _this20.pop())
                            while (0 < num_to_do):
                                _this21 = self.opStack
                                _this22 = self.old_opStack
                                x10 = (None if ((len(_this22) == 0)) else _this22.pop())
                                _this21.insert(0, x10)
                                num_to_do = (num_to_do - 1)
                            num_to_do = 0
                            if (0 < len(self.old_dataStackFrames)):
                                _this23 = self.old_dataStackFrames
                                num_to_do = (None if ((len(_this23) == 0)) else _this23.pop())
                            while (0 < num_to_do):
                                _this24 = self.dataStack
                                _this25 = self.old_dataStack
                                x11 = (None if ((len(_this25) == 0)) else _this25.pop())
                                _this24.insert(0, x11)
                                num_to_do = (num_to_do - 1)
                            if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                choice_idx = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                choice_name = (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).internal_token
                                if (13 == (self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_type):
                                    if (((("for" == choice_name) or (("if" == choice_name))) or (("switch" == choice_name))) or (("while" == choice_name))):
                                        if (("if" == choice_name) or (("while" == choice_name))):
                                            if ((0 == len(self.dataStack)) or ((10 != python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type))):
                                                forGL_ForGL_ui.error((("SYNTAX ERROR: " + Std.string(choice_name)) + " expression result is not Bool. Stopping.\n"))
                                                _hx_local_64 = self
                                                _hx_local_65 = _hx_local_64.run_text_line
                                                _hx_local_64.run_text_line = (_hx_local_65 + 1)
                                                _hx_local_65
                                                forGL_ForGL_ui.msg((("Error location (word number) is " + Std.string(ip)) + "\n"))
                                                _hx_local_66 = self
                                                _hx_local_67 = _hx_local_66.run_text_line
                                                _hx_local_66.run_text_line = (_hx_local_67 + 1)
                                                _hx_local_67
                                                _hx_local_68 = self
                                                _hx_local_69 = _hx_local_68.run_text_line
                                                _hx_local_68.run_text_line = (_hx_local_69 + self.nl_Parse.showWordsTable(self.runStack,True,True,False))
                                                _hx_local_68.run_text_line
                                                self.intp_return_result = -4
                                                break
                                            exp_bool = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                                            _this26 = self.dataStack
                                            if (len(_this26) != 0):
                                                _this26.pop()
                                            if (1 == exp_bool):
                                                ip = (ip + 1)
                                                continue
                                            else:
                                                ip = (Math.floor((self.runStack[choice_idx] if choice_idx >= 0 and choice_idx < len(self.runStack) else None).token_float) + 1)
                                                continue
                                        else:
                                            forGL_ForGL_ui.error((("INTERNAL ERROR: " + Std.string(choice_name)) + " not implemented. Stopping.\n"))
                                            _hx_local_71 = self
                                            _hx_local_72 = _hx_local_71.run_text_line
                                            _hx_local_71.run_text_line = (_hx_local_72 + 1)
                                            _hx_local_72
                                            self.intp_return_result = -10
                                            break
                                else:
                                    forGL_ForGL_ui.error("INTERNAL ERROR: Choice indicated but not referenced correctly. Stopping.\n")
                                    _hx_local_73 = self
                                    _hx_local_74 = _hx_local_73.run_text_line
                                    _hx_local_73.run_text_line = (_hx_local_74 + 1)
                                    _hx_local_74
                                    self.intp_return_result = -11
                                    break
                            if (0 < len(self.opStack)):
                                ops_result2 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns,True)
                                def _hx_local_76():
                                    _hx_local_75 = ops_result2
                                    if (Std.isOfType(_hx_local_75,Int) or ((_hx_local_75 is None))):
                                        _hx_local_75
                                    else:
                                        raise "Class cast error"
                                    return _hx_local_75
                                if (_hx_local_76() < 0):
                                    self.intp_return_result = ops_result2
                                    break
                    elif (not (((22 == op_to_do) or ((23 == op_to_do))))):
                        if ((26 == op_to_do) or ((27 == op_to_do))):
                            if (26 == op_to_do):
                                _this27 = self.old_opStackFrames
                                x12 = len(self.opStack)
                                _this27.append(x12)
                                while (0 < len(self.opStack)):
                                    _this28 = self.old_opStack
                                    _this29 = self.opStack
                                    x13 = (None if ((len(_this29) == 0)) else _this29.pop(0))
                                    _this28.append(x13)
                                _this30 = self.old_dataStackFrames
                                x14 = len(self.dataStack)
                                _this30.append(x14)
                                while (0 < len(self.dataStack)):
                                    _this31 = self.old_dataStack
                                    _this32 = self.dataStack
                                    x15 = (None if ((len(_this32) == 0)) else _this32.pop(0))
                                    _this31.append(x15)
                            else:
                                if (0 < len(self.opStack)):
                                    ops_result3 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                                    def _hx_local_78():
                                        _hx_local_77 = ops_result3
                                        if (Std.isOfType(_hx_local_77,Int) or ((_hx_local_77 is None))):
                                            _hx_local_77
                                        else:
                                            raise "Class cast error"
                                        return _hx_local_77
                                    if (_hx_local_78() < 0):
                                        self.intp_return_result = ops_result3
                                        break
                                if (0 < len(self.assignStack)):
                                    _this33 = self.assignStack
                                    r_idx = (None if ((len(_this33) == 0)) else _this33.pop())
                                    assign_op = (self.runStack[r_idx] if r_idx >= 0 and r_idx < len(self.runStack) else None).token_op_means
                                    self.runAssignment(self.runStack,self.dataStack,self.opStack,self.nouns,assign_op)
                                num_to_do1 = 0
                                if (0 < len(self.old_opStackFrames)):
                                    _this34 = self.old_opStackFrames
                                    num_to_do1 = (None if ((len(_this34) == 0)) else _this34.pop())
                                while (0 < num_to_do1):
                                    _this35 = self.opStack
                                    _this36 = self.old_opStack
                                    x16 = (None if ((len(_this36) == 0)) else _this36.pop())
                                    _this35.insert(0, x16)
                                    num_to_do1 = (num_to_do1 - 1)
                                num_to_do1 = 0
                                if (0 < len(self.old_dataStackFrames)):
                                    _this37 = self.old_dataStackFrames
                                    num_to_do1 = (None if ((len(_this37) == 0)) else _this37.pop())
                                while (0 < num_to_do1):
                                    _this38 = self.dataStack
                                    _this39 = self.old_dataStack
                                    x17 = (None if ((len(_this39) == 0)) else _this39.pop())
                                    _this38.insert(0, x17)
                                    num_to_do1 = (num_to_do1 - 1)
                                if (0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int):
                                    ip = ((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int - 1)
                                    _hx_local_81 = self
                                    _hx_local_82 = _hx_local_81.steps_done
                                    _hx_local_81.steps_done = (_hx_local_82 + 1)
                                    _hx_local_82
                                    continue
                                if (0.0 < (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float):
                                    ip = (ip + Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float))
                                    _hx_local_84 = self
                                    _hx_local_85 = _hx_local_84.steps_done
                                    _hx_local_84.steps_done = (_hx_local_85 + 1)
                                    _hx_local_85
                                    continue
                        else:
                            _this40 = self.opStack
                            _this40.append(ip)
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                            ops_result4 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                            def _hx_local_87():
                                _hx_local_86 = ops_result4
                                if (Std.isOfType(_hx_local_86,Int) or ((_hx_local_86 is None))):
                                    _hx_local_86
                                else:
                                    raise "Class cast error"
                                return _hx_local_86
                            if (_hx_local_87() < 0):
                                self.intp_return_result = ops_result4
                                break
                    _hx_local_88 = self
                    _hx_local_89 = _hx_local_88.steps_done
                    _hx_local_88.steps_done = (_hx_local_89 + 1)
                    _hx_local_89
                    ip = (ip + 1)
                    continue
            verb_pending = False
            if (((4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) or ((5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) or ((3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                verb_pending = True
                if (0 < len(self.opStack)):
                    apply_op = True
                    ip = (ip - 1)
            if apply_op:
                if (0 < len(self.opStack)):
                    ops_result5 = self.runOperators(self.runStack,self.dataStack,self.opStack,self.nouns)
                    def _hx_local_93():
                        _hx_local_92 = ops_result5
                        if (Std.isOfType(_hx_local_92,Int) or ((_hx_local_92 is None))):
                            _hx_local_92
                        else:
                            raise "Class cast error"
                        return _hx_local_92
                    if (_hx_local_93() < 0):
                        self.intp_return_result = ops_result5
                        break
                    ip = (ip + 1)
                    continue
            if (((4 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type) and ((5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))) and ((3 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type))):
                ip = (ip + 1)
                continue
            verb_move_ahead = 1
            if (5 != (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                is_call_style = False
                call_args = ""
                if ((ip + 2) < len(self.runStack)):
                    if ((2 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_type) and ((18 == python_internal_ArrayImpl._get(self.runStack, (ip + 1)).token_op_means))):
                        is_call_style = True
                        result = self.argsOrData((ip + 1),self.runStack,self.dataStack,self.opStack)
                        verb_move_ahead = result
                        call_args = self.argsOrData_Str()
                if (False == is_call_style):
                    if (0 < len(self.dataStack)):
                        call_args = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).toStr()
                    else:
                        result1 = self.argsOrData((ip + 1),self.runStack,self.dataStack,self.opStack)
                        verb_move_ahead = (result1 + 1)
                        call_args = self.argsOrData_Str()
                verb_name = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token
                if self.display_internal:
                    verb_name = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token
                if self.show_details:
                    msg_str = "\n"
                    if (0 < len(self.callStack)):
                        msg_str = hx_strings_Strings.insertAt(msg_str,(0 if ((msg_str is None)) else len(msg_str)),Std.string(self.arrToStrSep(self.callStack," > ")))
                    forGL_ForGL_ui.msg((((((Std.string(msg_str) + " > ") + Std.string(verb_name)) + " ( ") + Std.string(call_args)) + " )\n"))
                    _hx_local_96 = self
                    _hx_local_97 = _hx_local_96.run_text_line
                    _hx_local_96.run_text_line = (_hx_local_97 + 1)
                    _hx_local_97
                    _hx_local_98 = self
                    _hx_local_99 = _hx_local_98.run_text_line
                    _hx_local_98.run_text_line = (_hx_local_99 + 1)
                    _hx_local_99
                _this41 = self.callStack
                _this41.append(verb_name)
                self.addName(self.exportStack,verb_name)
            if (4 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                verb_text = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_str
                if (0 == ((0 if ((verb_text is None)) else len(verb_text)))):
                    forGL_ForGL_ui.error(("\nSYNTAX ERROR: No text for for Verb: " + Std.string((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).visible_token)))
                    ip = (ip + verb_move_ahead)
                    continue
                verb_tokens = self.nl_Parse.parse(verb_text,forGL_ParseStyle.PARSE_LEFT_TO_RIGHT,False)
                if (0 == len(verb_tokens)):
                    ip = (ip + verb_move_ahead)
                    continue
                self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                old_length = len(self.runStack)
                _hx_local_102 = self
                _hx_local_103 = _hx_local_102.run_text_line
                _hx_local_102.run_text_line = (_hx_local_103 + self.nl_Parse.resolveTokens(verb_tokens,self.nlDict,self.runStack,self.run_verbose))
                _hx_local_102.run_text_line
                self.repeat_found = self.nl_Parse.repeat_verb_found
                if (self.nl_Parse.left_groups != self.nl_Parse.right_groups):
                    forGL_ForGL_ui.error((((("\nSYNTAX ERROR: count of " + Std.string(self.nl_Parse.left_groups)) + " Left and ") + Std.string(self.nl_Parse.right_groups)) + " Right group symbols ( ) [ ] { } not same.\n"))
                    _hx_local_104 = self
                    _hx_local_105 = _hx_local_104.run_text_line
                    _hx_local_104.run_text_line = (_hx_local_105 + 1)
                    _hx_local_105
                    _hx_local_106 = self
                    _hx_local_107 = _hx_local_106.run_text_line
                    _hx_local_106.run_text_line = (_hx_local_107 + 1)
                    _hx_local_107
                self.nl_Parse.resolveAssigns(self.runStack)
                choice_result = -11
                choice_result = self.nl_Parse.resolveChoice(self.runStack)
                def _hx_local_109():
                    _hx_local_108 = choice_result
                    if (Std.isOfType(_hx_local_108,Int) or ((_hx_local_108 is None))):
                        _hx_local_108
                    else:
                        raise "Class cast error"
                    return _hx_local_108
                if (0 > _hx_local_109()):
                    self.intp_return_result = choice_result
                    break
                if (0 >= len(self.runStack)):
                    forGL_ForGL_ui.error("\nSYNTAX ERROR: Nothing to run. Stopping\n")
                    self.intp_return_result = -4
                    break
                if self.show_words_table:
                    _hx_local_110 = self
                    _hx_local_111 = _hx_local_110.run_text_line
                    _hx_local_110.run_text_line = (_hx_local_111 + self.nl_Parse.showWordsTable(self.runStack,self.show_words_table,False,False))
                    _hx_local_110.run_text_line
                elif self.export_as_code:
                    _hx_local_112 = self
                    _hx_local_113 = _hx_local_112.run_text_line
                    _hx_local_112.run_text_line = (_hx_local_113 + self.nl_Parse.showWordsTable(self.runStack,True,False,self.export_as_code))
                    _hx_local_112.run_text_line
                    j = 0
                    exp_text = ""
                    while (j < len(self.runStack)):
                        _hx_str = ""
                        if self.display_internal:
                            _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).internal_token
                            if ("" == _hx_str):
                                _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                        else:
                            _hx_str = (self.runStack[j] if j >= 0 and j < len(self.runStack) else None).visible_token
                        exp_text = (("null" if exp_text is None else exp_text) + HxOverrides.stringOrNull(((("null" if _hx_str is None else _hx_str) + " "))))
                        j = (j + 1)
                    _this42 = self.export_as_code_log
                    x18 = forGL_TypedTokens((self.runStack[j] if j >= 0 and j < len(self.runStack) else None).token_type,exp_text)
                    _this42.append(x18)
                _this43 = self.runStack
                x19 = forGL_NLToken("","","","",0.0,0,0,0,0)
                _this43.append(x19)
                rIdx = (len(self.runStack) - 1)
                new_length = len(self.runStack)
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_type = 5
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).internal_token = "return"
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).visible_token = "return"
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_int = ((ip + 1) + verb_move_ahead)
                (self.runStack[rIdx] if rIdx >= 0 and rIdx < len(self.runStack) else None).token_float = (new_length - old_length)
                _this44 = self.old_assignStackFrames
                x20 = len(self.assignStack)
                _this44.append(x20)
                while (0 < len(self.assignStack)):
                    _this45 = self.old_assignStack
                    _this46 = self.assignStack
                    x21 = (None if ((len(_this46) == 0)) else _this46.pop(0))
                    _this45.append(x21)
                _this47 = self.old_nounStackFrames
                x22 = len(self.nouns)
                _this47.append(x22)
                while (0 < len(self.nouns)):
                    _this48 = self.old_nounStack
                    _this49 = self.nouns
                    x23 = (None if ((len(_this49) == 0)) else _this49.pop(0))
                    _this48.append(x23)
                _this50 = self.old_opStackFrames
                x24 = len(self.opStack)
                _this50.append(x24)
                while (0 < len(self.opStack)):
                    _this51 = self.old_opStack
                    _this52 = self.opStack
                    x25 = (None if ((len(_this52) == 0)) else _this52.pop(0))
                    _this51.append(x25)
                ip = old_length
                continue
            elif (5 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                self.nl_Parse.saveNounValues(self.nlDict,self.runStack,self.nouns)
                num_to_do2 = len(self.nouns)
                while (0 < num_to_do2):
                    _this53 = self.nouns
                    if (len(_this53) != 0):
                        _this53.pop()
                    num_to_do2 = (num_to_do2 - 1)
                num_to_do2 = 0
                if (0 < len(self.old_assignStackFrames)):
                    _this54 = self.old_assignStackFrames
                    num_to_do2 = (None if ((len(_this54) == 0)) else _this54.pop())
                while (0 < num_to_do2):
                    _this55 = self.assignStack
                    _this56 = self.old_assignStack
                    x26 = (None if ((len(_this56) == 0)) else _this56.pop())
                    _this55.insert(0, x26)
                    num_to_do2 = (num_to_do2 - 1)
                num_to_do2 = 0
                if (0 < len(self.old_nounStackFrames)):
                    _this57 = self.old_nounStackFrames
                    num_to_do2 = (None if ((len(_this57) == 0)) else _this57.pop())
                while (0 < num_to_do2):
                    _this58 = self.nouns
                    _this59 = self.old_nounStack
                    x27 = (None if ((len(_this59) == 0)) else _this59.pop())
                    _this58.insert(0, x27)
                    num_to_do2 = (num_to_do2 - 1)
                num_to_do2 = 0
                if (0 < len(self.old_opStackFrames)):
                    _this60 = self.old_opStackFrames
                    num_to_do2 = (None if ((len(_this60) == 0)) else _this60.pop())
                while (0 < num_to_do2):
                    _this61 = self.opStack
                    _this62 = self.old_opStack
                    x28 = (None if ((len(_this62) == 0)) else _this62.pop())
                    _this61.insert(0, x28)
                    num_to_do2 = (num_to_do2 - 1)
                _this63 = self.callStack
                if (len(_this63) != 0):
                    _this63.pop()
                new_ip = (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_int
                num_to_remove = Math.floor((self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_float)
                num_to_do2 = num_to_remove
                while (0 < num_to_do2):
                    _this64 = self.runStack
                    if (len(_this64) != 0):
                        _this64.pop()
                    num_to_do2 = (num_to_do2 - 1)
                self.nl_Parse.updateNounValues(self.nlDict,self.runStack,self.nouns)
                if ((len(self.runStack) - 1) < new_ip):
                    break
                ip = new_ip
                continue
            elif (3 == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).token_type):
                if ("repeat" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                    if (self.repeat_limit < 0):
                        if (0 < len(self.dataStack)):
                            repeat_data_type = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_type
                            if (9 == repeat_data_type):
                                if (0 <= python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int):
                                    self.repeat_limit_found = True
                                    self.repeat_limit = python_internal_ArrayImpl._get(self.dataStack, (len(self.dataStack) - 1)).data_int
                        if (self.repeat_limit < 0):
                            self.repeat_limit = 0
                    _hx_local_121 = self
                    _hx_local_122 = _hx_local_121.repeat_count
                    _hx_local_121.repeat_count = (_hx_local_122 + 1)
                    _hx_local_122
                    if (self.repeat_count <= self.repeat_limit):
                        if self.repeat_limit_found:
                            _this65 = self.dataStack
                            if (len(_this65) != 0):
                                _this65.pop()
                        i = (len(self.nouns) - 1)
                        while (0 <= i):
                            nounIdx = (self.nouns[i] if i >= 0 and i < len(self.nouns) else None)
                            if (7 == (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type):
                                (self.runStack[nounIdx] if nounIdx >= 0 and nounIdx < len(self.runStack) else None).token_type = 0
                                python_internal_ArrayImpl.remove(self.nouns,nounIdx)
                            i = (i - 1)
                        if (0 < len(self.nouns)):
                            if self.show_stacks:
                                self.viewDataOpNouns(self.runStack,self.dataStack,self.opStack,self.nouns,self.dataOpNoun_text_line)
                        if (0 < len(self.opStack)):
                            forGL_ForGL_ui.warning((("WARNING: Doing Repeat with leftover Operators: " + Std.string(self.opStackToString(self.runStack,self.opStack))) + "\n"))
                            _hx_local_124 = self
                            _hx_local_125 = _hx_local_124.run_text_line
                            _hx_local_124.run_text_line = (_hx_local_125 + 1)
                            _hx_local_125
                        forGL_ForGL_ui.msg("\r")
                        forGL_ForGL_ui.msg((Std.string(self.repeat_count) + "\t"))
                        ip = 0
                        continue
                    elif self.repeat_limit_found:
                        _this66 = self.dataStack
                        if (len(_this66) != 0):
                            _this66.pop()
                elif (("show" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token) or (("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token))):
                    showing = True
                    if ("view" == (self.runStack[ip] if ip >= 0 and ip < len(self.runStack) else None).internal_token):
                        showing = False
                        forGL_ForGL_ui.msg("\n        Data  Stack\n")
                        _hx_local_126 = self
                        _hx_local_127 = _hx_local_126.run_text_line
                        _hx_local_126.run_text_line = (_hx_local_127 + 1)
                        _hx_local_127
                        _hx_local_128 = self
                        _hx_local_129 = _hx_local_128.run_text_line
                        _hx_local_128.run_text_line = (_hx_local_129 + 1)
                        _hx_local_129
                    i = (len(self.dataStack) - 1)
                    while (i >= 0):
                        dataIdx1 = i
                        dataStr = ""
                        if (9 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int)
                        elif (10 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = "false"
                            if (1 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_int):
                                dataStr = "true"
                        elif (11 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = Std.string((self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_float)
                        elif (8 == (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                            dataStr = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                            if showing:
                                dataStr = self.trimQuotes(dataStr)
                        else:
                            forGL_ForGL_ui.error(" \nINTERNAL ERROR: Data not Float, Integer, Bool or String\n")
                            _hx_local_130 = self
                            _hx_local_131 = _hx_local_130.run_text_line
                            _hx_local_130.run_text_line = (_hx_local_131 + 1)
                            _hx_local_131
                            _hx_local_132 = self
                            _hx_local_133 = _hx_local_132.run_text_line
                            _hx_local_132.run_text_line = (_hx_local_133 + 1)
                            _hx_local_133
                            i = (i - 1)
                            continue
                        if showing:
                            if (0 < ((0 if ((dataStr is None)) else len(dataStr)))):
                                self.show1Data(dataStr,self.show_text_line)
                            if self.export_as_code:
                                exp = dataStr
                                tmp = None
                                if (8 != (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_type):
                                    this1 = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                    tmp = (0 < ((0 if ((this1 is None)) else len(this1))))
                                else:
                                    tmp = False
                                if tmp:
                                    exp = (self.dataStack[dataIdx1] if dataIdx1 >= 0 and dataIdx1 < len(self.dataStack) else None).data_str
                                _this67 = self.export_as_code_log
                                x29 = forGL_TypedTokens(3,(("show ( " + ("null" if exp is None else exp)) + " )"))
                                _this67.append(x29)
                            _this68 = self.dataStack
                            if (len(_this68) != 0):
                                _this68.pop()
                            break
                        else:
                            forGL_ForGL_ui.msg((("null" if dataStr is None else dataStr) + "\n"))
                            _hx_local_135 = self
                            _hx_local_136 = _hx_local_135.run_text_line
                            _hx_local_135.run_text_line = (_hx_local_136 + 1)
                            _hx_local_136
                        i = (i - 1)
                    _this69 = self.callStack
                    if (len(_this69) != 0):
                        _this69.pop()
            if (0 >= verb_move_ahead):
                forGL_ForGL_ui.error((("INTERNAL ERROR: verb_move_ahead = " + Std.string(verb_move_ahead)) + "\n"))
                verb_move_ahead = 1
            ip = (ip + verb_move_ahead)
        self.intp_ip = ip
        forGL_ForGL_ui.outputBuffersUsed()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.run_text_line = None
        _hx_o.export_as_code = None
        _hx_o.export_as_code_log = None
        _hx_o.export_as_code_verb_name = None
        _hx_o.display_internal = None
        _hx_o.show_details = None
        _hx_o.show_words_table = None
        _hx_o.show_stacks = None
        _hx_o.show_stacks_Data_Only = None
        _hx_o.single_step = None
        _hx_o.delay_seconds_default = None
        _hx_o.delay_seconds = None
        _hx_o.nlDict = None
        _hx_o.stdin = None
        _hx_o.run_verbose = None
        _hx_o.ForGLData = None
        _hx_o.nl_Import_used = None
        _hx_o.nl_Import = None
        _hx_o.nl_Parse = None
        _hx_o.in_dictionary_file_name = None
        _hx_o.use_Built_In_Dictionary = None
        _hx_o.out_dictionary_file_name = None
        _hx_o.dataOpNoun_text_line = None
        _hx_o.steps_done = None
        _hx_o.steps_done_Verb = None
        _hx_o.intp_ip = None
        _hx_o.old_dataStackFrames = None
        _hx_o.old_dataStack = None
        _hx_o.old_opStackFrames = None
        _hx_o.old_opStack = None
        _hx_o.old_nounStackFrames = None
        _hx_o.old_nounStack = None
        _hx_o.old_assignStackFrames = None
        _hx_o.old_assignStack = None
        _hx_o.elapsed_intp_time = None
        _hx_o.user_def = None
        _hx_o.forgl_ver_major = None
        _hx_o.forgl_ver_minor = None
        _hx_o.forgl_ver_build = None
        _hx_o.forgl_ver_stability = None
        _hx_o.forgl_version = None
        _hx_o.prev_dataStackOut = None
        _hx_o.prev_opStackOut = None
        _hx_o.prev_nounStackOut = None
        _hx_o.prev_callStackOut = None
        _hx_o.view_DON_throttle = None
        _hx_o.last_view_DON_time = None
        _hx_o.prev_show1_data = None
        _hx_o.argsOrData_list = None
        _hx_o.start_session_time = None
        _hx_o.total_intp_time = None
        _hx_o.verb_to_run = None
        _hx_o.runStack = None
        _hx_o.dataStack = None
        _hx_o.opStack = None
        _hx_o.nouns = None
        _hx_o.callStack = None
        _hx_o.exportStack = None
        _hx_o.assignStack = None
        _hx_o.repeat_found = None
        _hx_o.repeat_count = None
        _hx_o.repeat_limit = None
        _hx_o.repeat_limit_found = None
        _hx_o.show_text_line = None
        _hx_o.start_intp_time = None
        _hx_o.intp_return_result = None


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "set_bigEndian", "readLine"]

    def readByte(self):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Input.hx", 'lineNumber': 53, 'className': "haxe.io.Input", 'methodName': "readByte"}))

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except BaseException as _g:
            None
            _g1 = haxe_Exception.caught(_g).unwrap()
            if Std.isOfType(_g1,haxe_io_Eof):
                e = _g1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise haxe_Exception.thrown(e)
            else:
                raise _g
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "throwEof"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise haxe_Exception.thrown("Write-only stream")

    def close(self):
        self.stream.close()

    def throwEof(self):
        self.wasEof = True
        raise haxe_Exception.thrown(haxe_io_Eof())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "close", "readLine"]


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "close", "readLine"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def close(self):
        self.impl.close()

    def readLine(self):
        return self.impl.readLine()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "set_bigEndian", "writeFullBytes", "writeString"]

    def writeByte(self,c):
        raise haxe_exceptions_NotImplementedException(None,None,_hx_AnonObject({'fileName': "haxe/io/Output.hx", 'lineNumber': 47, 'className': "haxe.io.Output", 'methodName': "writeByte"}))

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def close(self):
        self.stream.close()

    def flush(self):
        self.stream.flush()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise haxe_Exception.thrown("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "writeFullBytes", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None


class hx_strings_ansi__AnsiWriter_StringWriter:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringWriter"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["flush", "write"]


class hx_strings_ansi__AnsiWriter_OutputStringWriter:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.OutputStringWriter"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["flush", "write"]
    _hx_interfaces = [hx_strings_ansi__AnsiWriter_StringWriter]

    def __init__(self,out):
        self.out = out

    def flush(self):
        self.out.flush()

    def write(self,_hx_str):
        self.out.writeString(_hx_str)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None


class hx_strings_ansi_AnsiWriter:
    _hx_class_name = "hx.strings.ansi.AnsiWriter"
    __slots__ = ("_out",)
    _hx_fields = ["_out"]
    _hx_methods = ["get_out", "attr", "bg", "clearScreen", "clearLine", "cursor", "fg", "flush", "write"]

    def __init__(self,out):
        self._out = out

    def get_out(self):
        return self._out.out

    def attr(self,attr):
        self._out.write((("\x1B[" + Std.string(attr)) + "m"))
        return self

    def bg(self,color):
        self._out.write(((("\x1B[" + "4") + Std.string(color)) + "m"))
        return self

    def clearScreen(self):
        self._out.write(("\x1B[" + "2J"))
        return self

    def clearLine(self):
        self._out.write(("\x1B[" + "K"))
        return self

    def cursor(self,cmd):
        _hx_str = hx_strings_ansi_Ansi.cursor(cmd)
        self._out.write(_hx_str)
        return self

    def fg(self,color):
        self._out.write(((("\x1B[" + "3") + Std.string(color)) + "m"))
        return self

    def flush(self):
        self._out.flush()
        return self

    def write(self,_hx_str):
        self._out.write(_hx_str)
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._out = None


class forGL_ForGL_ui:
    _hx_class_name = "forGL.ForGL_ui"
    __slots__ = ()
    _hx_statics = ["system_name", "error_count_ui", "error_msgs_ui", "warning_count_ui", "warning_msgs_ui", "out_buffers", "DEFAULT_TYPE_COLOR", "COMMENT_COLOR", "DATA_COLOR", "NOUN_COLOR", "OP_COLOR", "VERB_COLOR", "VERB_BI_COLOR", "DEFAULT_COLOR", "SEPARATOR_COLOR", "current_line", "current_column", "home_line", "home_column", "blanks78", "stdin", "stdout", "writer", "setOut", "outputBuffersUsed", "eraseToLineEnd", "getCurrentPos", "hideCursor", "savePos", "goToPos", "goToHome", "eraseToDispEnd", "restorePos", "showCursor", "msg_call_count", "msg", "status_msgs", "status", "error", "warning", "getTypeColor", "enterYourVerb_return", "enterYourVerb", "enterYes", "init", "popUp"]

    @staticmethod
    def setOut(outputWhere = None):
        if (outputWhere is None):
            outputWhere = 0

    @staticmethod
    def outputBuffersUsed():
        pass

    @staticmethod
    def eraseToLineEnd(used):
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "K"))
        _this1 = _this
        _this1._out.flush()

    @staticmethod
    def getCurrentPos(line,column):
        line = forGL_ForGL_ui.current_line
        column = forGL_ForGL_ui.current_column

    @staticmethod
    def hideCursor():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "?25l"))

    @staticmethod
    def savePos():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "s"))

    @staticmethod
    def goToPos(line,column):
        _this = forGL_ForGL_ui.writer
        _this._out.write((((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H"))
        forGL_ForGL_ui.current_line = line
        forGL_ForGL_ui.current_column = column

    @staticmethod
    def goToHome():
        forGL_ForGL_ui.goToPos(forGL_ForGL_ui.home_line,forGL_ForGL_ui.home_column)

    @staticmethod
    def eraseToDispEnd():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "J"))

    @staticmethod
    def restorePos():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "u"))

    @staticmethod
    def showCursor():
        _this = forGL_ForGL_ui.writer
        _this._out.write(("\x1B[" + "?25h"))

    @staticmethod
    def msg(message,color = None,end_CR = None):
        if (color is None):
            color = 7
        if (end_CR is None):
            end_CR = False
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.msg_call_count
        _hx_local_0.msg_call_count = (_hx_local_1 + 1)
        _hx_local_1
        if (forGL_ForGL_ui.DEFAULT_COLOR == color):
            if (True == end_CR):
                _hx_str = Std.string(message)
                python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
            else:
                python_Lib.printString(Std.string(message))
        else:
            _this = forGL_ForGL_ui.writer
            _this._out.write(((("\x1B[" + "3") + Std.string(color)) + "m"))
            _this1 = _this
            _hx_str = Std.string(message)
            _this1._out.write(_hx_str)
            _this = _this1
            _this._out.flush()
            _this = forGL_ForGL_ui.writer
            _this._out.write(((("\x1B[" + "3") + Std.string(forGL_ForGL_ui.DEFAULT_COLOR)) + "m"))
            _this1 = _this
            _this1._out.flush()
            if (True == end_CR):
                _this = forGL_ForGL_ui.writer
                _this._out.write("\n")
                _this1 = _this
                _this1._out.flush()

    @staticmethod
    def status(message,color = None,end_CR = None,wait = None):
        if (color is None):
            color = 7
        if (end_CR is None):
            end_CR = False
        if (wait is None):
            wait = False
        show_msg = True
        if (0 == ((0 if ((message is None)) else len(message)))):
            forGL_ForGL_ui.status_msgs = ""
            end_CR = False
            wait = False
        else:
            forGL_ForGL_ui.status_msgs = hx_strings_Strings.insertAt(message,(0 if ((message is None)) else len(message)),Std.string(forGL_ForGL_ui.status_msgs))
        forGL_ForGL_ui.savePos()
        forGL_ForGL_ui.goToPos(2,7)
        forGL_ForGL_ui.eraseToLineEnd(0)
        if show_msg:
            forGL_ForGL_ui.msg(forGL_ForGL_ui.status_msgs,color,end_CR)
        if wait:
            Sys.getChar(False)
        forGL_ForGL_ui.restorePos()

    @staticmethod
    def error(message,color = None):
        if (color is None):
            color = 1
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.error_count_ui
        _hx_local_0.error_count_ui = (_hx_local_1 + 1)
        _hx_local_1
        _hx_str = forGL_ForGL_ui.error_msgs_ui
        forGL_ForGL_ui.error_msgs_ui = hx_strings_Strings.insertAt(forGL_ForGL_ui.error_msgs_ui,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(message))
        forGL_ForGL_ui.status("")
        forGL_ForGL_ui.msg(message,color)
        forGL_ForGL_ui.status(message,color,False,True)

    @staticmethod
    def warning(message,color = None):
        if (color is None):
            color = 3
        _hx_local_0 = forGL_ForGL_ui
        _hx_local_1 = _hx_local_0.warning_count_ui
        _hx_local_0.warning_count_ui = (_hx_local_1 + 1)
        _hx_local_1
        _hx_str = forGL_ForGL_ui.warning_msgs_ui
        forGL_ForGL_ui.warning_msgs_ui = hx_strings_Strings.insertAt(forGL_ForGL_ui.warning_msgs_ui,(0 if ((_hx_str is None)) else len(_hx_str)),Std.string(message))
        forGL_ForGL_ui.status("")
        forGL_ForGL_ui.msg(message,color)
        forGL_ForGL_ui.status(message,color,False,True)

    @staticmethod
    def getTypeColor(_hx_type):
        color = forGL_ForGL_ui.DEFAULT_TYPE_COLOR
        type1 = _hx_type
        if (type1 == 0):
            color = forGL_ForGL_ui.DEFAULT_TYPE_COLOR
        elif (type1 == 1):
            color = forGL_ForGL_ui.COMMENT_COLOR
        elif (type1 == 2):
            color = forGL_ForGL_ui.OP_COLOR
        elif (type1 == 3):
            color = forGL_ForGL_ui.VERB_BI_COLOR
        elif (type1 == 4):
            color = forGL_ForGL_ui.VERB_COLOR
        elif (type1 == 5):
            color = forGL_ForGL_ui.VERB_COLOR
        elif (type1 == 6):
            color = forGL_ForGL_ui.NOUN_COLOR
        elif (type1 == 7):
            color = forGL_ForGL_ui.NOUN_COLOR
        elif (type1 == 8):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 9):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 10):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 11):
            color = forGL_ForGL_ui.DATA_COLOR
        elif (type1 == 12):
            color = forGL_ForGL_ui.COMMENT_COLOR
        elif (type1 == 13):
            color = forGL_ForGL_ui.VERB_BI_COLOR
        else:
            pass
        return color

    @staticmethod
    def enterYourVerb():
        forGL_ForGL_ui.enterYourVerb_return = 0
        user_Verb = ""
        try:
            forGL_ForGL_ui.msg("Type  test_verb  OR  your Verb and hit Enter or only Enter to stop.\n")
            while True:
                char_code = Sys.getChar(True)
                if ((13 == char_code) or ((10 == char_code))):
                    break
                if (27 == char_code):
                    user_Verb = ""
                    break
                if (8 == char_code):
                    if (1 < ((0 if ((user_Verb is None)) else len(user_Verb)))):
                        user_Verb = (Std.string(user_Verb) + " ")
                        user_Verb = hx_strings_Strings.substr8(user_Verb,0,(((0 if ((user_Verb is None)) else len(user_Verb))) - 1))
                    continue
                user_Verb = (Std.string(user_Verb) + HxOverrides.stringOrNull("".join(map(chr,[char_code]))))
            user_Verb = hx_strings_Strings.trim(user_Verb,hx_strings_internal__Either2__Either2.a(" \t"))
            if (0 == ((0 if ((user_Verb is None)) else len(user_Verb)))):
                forGL_ForGL_ui.enterYourVerb_return = -1
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.warning((("\nINTERNAL ERROR: Exception in  UI.enterYourVerb():  stdin.readLine()  " + Std.string(e)) + "\n"))
            if ("Windows" == forGL_ForGL_ui.system_name):
                forGL_ForGL_ui.warning("If you see outline boxes  ▯▯▯  instead of expected text:\nIt usually means the font does not have the data for those characters.\nPlease try the forGL GUI application.")
            forGL_ForGL_ui.enterYourVerb_return = -11
        return user_Verb

    @staticmethod
    def enterYes():
        yes_entered = False
        ans = ""
        while (0 == ((0 if ((ans is None)) else len(ans)))):
            ans = forGL_ForGL_ui.stdin.readLine()
            ans = hx_strings_Strings.trim(ans,hx_strings_internal__Either2__Either2.a(" \t"))
            if (0 < ((0 if ((ans is None)) else len(ans)))):
                if (("Y" == hx_strings_Strings.charAt8(ans,0)) or (("y" == hx_strings_Strings.charAt8(ans,0)))):
                    yes_entered = True
                break
        return yes_entered

    @staticmethod
    def init():
        ret_val = 0
        return ret_val

    @staticmethod
    def popUp(msg):
        pass


class forGL_data_ForGL_data:
    _hx_class_name = "forGL.data.ForGL_data"
    __slots__ = ("actual_path_file", "actual_file_type", "data_call_count", "toml", "findWordDef_type", "replaceOrAddWord_replaced")
    _hx_fields = ["actual_path_file", "actual_file_type", "data_call_count", "toml", "findWordDef_type", "replaceOrAddWord_replaced"]
    _hx_methods = ["callCount", "init", "cleanUp", "loadFile", "getListOfWords", "findWordDef", "getDataErrors", "getDataWarnings", "renameFile", "saveToFile", "replaceOrAddWord"]

    def __init__(self):
        self.toml = None
        self.replaceOrAddWord_replaced = False
        self.findWordDef_type = 0
        self.data_call_count = 0
        self.actual_file_type = 0
        self.actual_path_file = ""

    def callCount(self):
        return self.data_call_count

    def init(self,path_file,file_type):
        result = 0
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.data_call_count
        _hx_local_0.data_call_count = (_hx_local_1 + 1)
        _hx_local_1
        self.toml = forGL_data_ForGL_toml()
        result = self.loadFile(path_file,file_type)
        return result

    def cleanUp(self):
        ret_val = 0
        try:
            self.toml.cleanUp()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.error((("\nINTERNAL ERROR: Exception in forGL_data.cleanUp(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    def loadFile(self,path_name,expected_type):
        ret_val = 0
        if (2 == expected_type):
            extension = HxString.substr(path_name,(len(path_name) - 5),5)
            if (".toml" != extension.lower()):
                forGL_ForGL_ui.error((((("ERROR: File extension not .toml : " + ("null" if path_name is None else path_name)) + " ") + ("null" if extension is None else extension)) + "\n"))
                ret_val = -3
            else:
                ret_val = self.toml.init(path_name,expected_type)
                if (0 == ret_val):
                    self.actual_file_type = self.toml.actual_file_type
                    self.actual_path_file = self.toml.actual_path_file
        return ret_val

    def getListOfWords(self,warn_if_not_unique = None):
        if (warn_if_not_unique is None):
            warn_if_not_unique = True
        wordList = self.toml.getWordList(warn_if_not_unique)
        return wordList

    def findWordDef(self,word_visible_name,rInfo):
        self.findWordDef_type = 0
        ret_val = self.toml.getWord(word_visible_name,rInfo)
        def _hx_local_1():
            _hx_local_0 = ret_val
            if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        if (0 == _hx_local_1()):
            self.findWordDef_type = self.toml.getWord_type
        return ret_val

    def getDataErrors(self):
        return self.toml.error_msgs

    def getDataWarnings(self):
        return self.toml.warning_msgs

    def renameFile(self,old_path_name,new_path_name):
        ret_val = 0
        try:
            sys_FileSystem.rename(old_path_name,new_path_name)
        except BaseException as _g:
            None
            ret_val = -11
        return ret_val

    def saveToFile(self,new_path_name):
        save_result = self.toml.saveData(new_path_name)
        return save_result

    def replaceOrAddWord(self,word_visible_name,word_type,rInfo):
        self.replaceOrAddWord_replaced = False
        replaceOrAdd_result = self.toml.changeOrAddWord(word_visible_name,word_type,rInfo)
        def _hx_local_1():
            _hx_local_0 = replaceOrAdd_result
            if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise "Class cast error"
            return _hx_local_0
        if (0 == _hx_local_1()):
            self.replaceOrAddWord_replaced = self.toml.changeOrAddWord_changed
        return replaceOrAdd_result

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.actual_path_file = None
        _hx_o.actual_file_type = None
        _hx_o.data_call_count = None
        _hx_o.toml = None
        _hx_o.findWordDef_type = None
        _hx_o.replaceOrAddWord_replaced = None


class forGL_data_ForGL_toml:
    _hx_class_name = "forGL.data.ForGL_toml"
    __slots__ = ("actual_path_file", "actual_file_type", "error_msgs", "warning_msgs", "data_call_count", "fReadHandle", "ws_chars", "fileLines", "comment_lines", "sections", "section_names", "word_list", "type_list", "built_in_list", "value_list", "getStr_type", "getStrML_end_line", "valid_str_ML", "getWord_type", "getWord_word_idx", "changeOrAddWord_changed", "changeOrAddWord_msgs")
    _hx_fields = ["actual_path_file", "actual_file_type", "error_msgs", "warning_msgs", "data_call_count", "fReadHandle", "ws_chars", "fileLines", "comment_lines", "sections", "section_names", "word_list", "type_list", "built_in_list", "value_list", "getStr_type", "getStrML_end_line", "valid_str_ML", "getWord_type", "getWord_word_idx", "changeOrAddWord_changed", "changeOrAddWord_msgs"]
    _hx_methods = ["callCount", "init", "cleanUp", "nameValidate", "getStr", "getStrML", "getWordList", "getWord", "changeOrAddWord", "saveData"]

    def __init__(self):
        self.fReadHandle = None
        self.changeOrAddWord_msgs = ""
        self.changeOrAddWord_changed = False
        self.getWord_word_idx = -1
        self.getWord_type = 0
        self.valid_str_ML = False
        self.getStrML_end_line = 0
        self.getStr_type = 0
        self.value_list = list()
        self.built_in_list = list()
        self.type_list = list()
        self.word_list = list()
        self.section_names = list()
        self.sections = list()
        self.comment_lines = 0
        self.fileLines = list()
        self.ws_chars = [hx_strings_Strings.charCodeAt8(" ",0), hx_strings_Strings.charCodeAt8("\t",0)]
        self.data_call_count = 0
        self.warning_msgs = list()
        self.error_msgs = list()
        self.actual_file_type = 0
        self.actual_path_file = ""

    def callCount(self):
        return self.data_call_count

    def init(self,path_file = None,file_type = None):
        if (path_file is None):
            path_file = "forGL_Dict.toml"
        ret_val = 0
        self.error_msgs = [""]
        _this = self.error_msgs
        if (len(_this) != 0):
            _this.pop()
        self.warning_msgs = [""]
        _this = self.warning_msgs
        if (len(_this) != 0):
            _this.pop()
        self.actual_path_file = path_file
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.data_call_count
        _hx_local_0.data_call_count = (_hx_local_1 + 1)
        _hx_local_1
        try:
            does_exist = sys_FileSystem.exists(self.actual_path_file)
            if (False == does_exist):
                does_exist = sys_FileSystem.exists(("../" + HxOverrides.stringOrNull(self.actual_path_file)))
                if (False == does_exist):
                    err_msg = (("ERROR: Path or File not found: " + Std.string(path_file)) + "\n")
                    _this = self.error_msgs
                    _this.append(err_msg)
                    forGL_ForGL_ui.error(err_msg)
                    return -3
                else:
                    self.actual_path_file = ("../" + HxOverrides.stringOrNull(self.actual_path_file))
            extension = HxString.substr(self.actual_path_file,(len(self.actual_path_file) - 5),5)
            if (".toml" != extension.lower()):
                err_msg = ((("ERROR: File extension not .toml : " + HxOverrides.stringOrNull(self.actual_path_file)) + ("null" if extension is None else extension)) + "\n")
                _this = self.error_msgs
                _this.append(err_msg)
                forGL_ForGL_ui.error(err_msg)
                return -3
            is_dir = sys_FileSystem.isDirectory(self.actual_path_file)
            if (True == is_dir):
                err_msg = (("ERROR: Directory found but should be a File: " + HxOverrides.stringOrNull(self.actual_path_file)) + "\n")
                forGL_ForGL_ui.error(err_msg)
                return -3
            self.fReadHandle = sys_io_File.read(self.actual_path_file,True)
            self.fileLines = [""]
            _this = self.fileLines
            if (len(_this) != 0):
                _this.pop()
            temp_line = ""
            try:
                while True:
                    temp_line = self.fReadHandle.readLine()
                    hx_strings_Strings.trim(temp_line)
                    _this = self.fileLines
                    _this.append(temp_line)
            except BaseException as _g:
                None
                if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                    raise _g
            self.fReadHandle.close()
            i = 0
            self.comment_lines = 0
            self.actual_file_type = 0
            found_file_type = False
            first_toml_table = -1
            while (i < len(self.fileLines)):
                this1 = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                if (0 == ((0 if ((this1 is None)) else len(this1)))):
                    i = (i + 1)
                    continue
                if ("#" == hx_strings_Strings.charAt8((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),0)):
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.comment_lines
                    _hx_local_3.comment_lines = (_hx_local_4 + 1)
                    _hx_local_4
                    i = (i + 1)
                    continue
                if ("[" == hx_strings_Strings.charAt8((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),0)):
                    _this = self.sections
                    _this.append(i)
                    _this1 = self.section_names
                    x = hx_strings_Strings.trim((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None),hx_strings_internal__Either2__Either2.a("[]"))
                    _this1.append(x)
                    if (first_toml_table < 0):
                        first_toml_table = i
                        if ("[forGL_dictionary]" == (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)):
                            self.actual_file_type = 2
                            found_file_type = True
                        else:
                            self.actual_file_type = 0
                            err_msg = (("ERROR: Unknown File type. Closing File. First section is: " + Std.string((self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None))) + "\n")
                            _this2 = self.error_msgs
                            _this2.append(err_msg)
                            forGL_ForGL_ui.error(err_msg)
                            self.cleanUp()
                            return -3
                        if found_file_type:
                            if (i != first_toml_table):
                                forGL_ForGL_ui.error("ERROR: [forGL_dictionary] is not first section in file.\n")
                            found_file_type = False
                i = (i + 1)
            if ((0 != file_type) and ((self.actual_file_type != file_type))):
                forGL_ForGL_ui.error("ERROR: Type of .toml file is not as expected.\n")
                ret_val = -3
            else:
                forGL_ForGL_ui.status((((Std.string(len(self.fileLines)) + " lines and ") + Std.string(self.comment_lines)) + " comment lines.\n"))
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            err_msg = (("\nINTERNAL ERROR: Exception in forGL_toml.init(): " + Std.string(e)) + " \n")
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            ret_val = -11
        def _hx_local_8():
            _hx_local_7 = ret_val
            if (Std.isOfType(_hx_local_7,Int) or ((_hx_local_7 is None))):
                _hx_local_7
            else:
                raise "Class cast error"
            return _hx_local_7
        tmp = (_hx_local_8() < 0)
        return ret_val

    def cleanUp(self):
        ret_val = 0
        try:
            self.fileLines = [""]
            _this = self.fileLines
            if (len(_this) != 0):
                _this.pop()
            self.comment_lines = 0
            self.sections = [0]
            _this = self.sections
            if (len(_this) != 0):
                _this.pop()
            self.section_names = [""]
            _this = self.section_names
            if (len(_this) != 0):
                _this.pop()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            err_msg = (("Exception in forGL_toml.cleanUp(): " + Std.string(e)) + " \n")
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            ret_val = -11
        return ret_val

    def nameValidate(self,in_name,check_reserved = None):
        if (check_reserved is None):
            check_reserved = True
        if (0 == ((0 if ((in_name is None)) else len(in_name)))):
            return False
        temp = in_name
        result = ""
        pieces = hx_strings_Strings.split8(temp,["'", "\"", " ", "\t", "\r", "\n", "\\"])
        i = 0
        while (i < len(pieces)):
            _hx_str = (pieces[i] if i >= 0 and i < len(pieces) else None)
            if (0 < ((0 if ((_hx_str is None)) else len(_hx_str)))):
                result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),(pieces[i] if i >= 0 and i < len(pieces) else None))
            i = (i + 1)
        if (((0 if ((result is None)) else len(result))) != ((0 if ((temp is None)) else len(temp)))):
            return False
        if check_reserved:
            pieces = hx_strings_Strings.split8(result,["+", "-", "*", "/", "%", "<=", "<", "==", "=", ">=", ">", "!=", "!", "?", "(", ")", "[", "]", "{", "}", ",", ".", ";", ":"])
            result = ""
            i = 0
            while (i < len(pieces)):
                _hx_str = (pieces[i] if i >= 0 and i < len(pieces) else None)
                if (0 < ((0 if ((_hx_str is None)) else len(_hx_str)))):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),(pieces[i] if i >= 0 and i < len(pieces) else None))
                i = (i + 1)
            if (((0 if ((result is None)) else len(result))) != ((0 if ((temp is None)) else len(temp)))):
                return False
        strT = hx_strings_Strings.charAt8(result,0)
        if (("0" <= strT) and ((strT <= "9"))):
            return False
        return True

    def getStr(self,in_str,get_type = None):
        if (get_type is None):
            get_type = False
        self.getStr_type = 0
        temp = in_str
        if (((0 if ((temp is None)) else len(temp))) <= 2):
            err_msg = "SYNTAX ERROR: Input string too small from getStr\n"
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            return ""
        i = 0
        while ((i < ((0 if ((temp is None)) else len(temp)))) and (("\"" != hx_strings_Strings.charAt8(temp,i)))):
            i = (i + 1)
        if (i >= ((0 if ((temp is None)) else len(temp)))):
            err_msg = "SYNTAX ERROR: Quote character not found in getStr\n"
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            return ""
        temp2 = hx_strings_Strings.substring8(temp,(i + 1))
        if (1 <= ((0 if ((temp2 is None)) else len(temp2)))):
            if ("\"" == hx_strings_Strings.charAt8(temp2,(((0 if ((temp2 is None)) else len(temp2))) - 1))):
                temp2 = hx_strings_Strings.substring8(temp2,0,(((0 if ((temp2 is None)) else len(temp2))) - 1))
        else:
            err_msg = "SYNTAX ERROR: Empty String from getStr 2\n"
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.error(err_msg)
            temp2 = ""
        if get_type:
            if (0 < ((0 if ((temp2 is None)) else len(temp2)))):
                if (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("operator")):
                    self.getStr_type = 2
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("noun")):
                    self.getStr_type = 6
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("verb")):
                    self.getStr_type = 4
                elif (hx_strings_Strings.toLowerCase8(temp2) == hx_strings_Strings.toLowerCase8("choice")):
                    self.getStr_type = 13
        return temp2

    def getStrML(self,word_type,in_str,start_line):
        err_msg = ""
        temp = ""
        result = ""
        self.getStrML_end_line = start_line
        self.valid_str_ML = False
        i = 0
        char_found = hx_strings_Strings.charAt8(in_str,i)
        while ("=" != char_found):
            if ("" == char_found):
                break
            i = (i + 1)
            char_found = hx_strings_Strings.charAt8(in_str,i)
        if ("" == char_found):
            err_msg = ("ERROR: getStrML = character not found at line " + Std.string(start_line))
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.status("")
            forGL_ForGL_ui.error(err_msg,1)
            return ""
        i = (i + 1)
        char_found = hx_strings_Strings.charAt8(in_str,i)
        while ("" != char_found):
            if ((" " != char_found) and (("\t" != char_found))):
                break
            i = (i + 1)
            char_found = hx_strings_Strings.charAt8(in_str,i)
        if ("" == char_found):
            err_msg = ("ERROR: getStrML no visible character after = at line " + Std.string(start_line))
            _this = self.error_msgs
            _this.append(err_msg)
            forGL_ForGL_ui.status("")
            forGL_ForGL_ui.error(err_msg,1)
            return ""
        is_first_quote = False
        is_triple_quote = False
        temp = hx_strings_Strings.substring8(in_str,i)
        if ("\"" == hx_strings_Strings.charAt8(temp,0)):
            is_first_quote = True
            if (3 <= ((0 if ((temp is None)) else len(temp)))):
                if (("\"" == hx_strings_Strings.charAt8(temp,1)) and (("\"" == hx_strings_Strings.charAt8(temp,2)))):
                    is_triple_quote = True
        if ((not is_triple_quote) and is_first_quote):
            getStr_result = self.getStr(temp)
            self.valid_str_ML = True
            return getStr_result
        if (not is_triple_quote):
            self.valid_str_ML = True
            result = temp
            if (4 == word_type):
                tempLines = list()
                current_line = (start_line + 1)
                while (current_line < len(self.fileLines)):
                    temp = (self.fileLines[current_line] if current_line >= 0 and current_line < len(self.fileLines) else None)
                    if ((0 < ((0 if ((temp is None)) else len(temp)))) and (("[" == hx_strings_Strings.charAt8(temp,0)))):
                        break
                    tempLines.append(temp)
                    self.getStrML_end_line = current_line
                    current_line = (current_line + 1)
                t = (len(tempLines) - 1)
                while (0 <= t):
                    temp = (tempLines[t] if t >= 0 and t < len(tempLines) else None)
                    if (0 < ((0 if ((temp is None)) else len(temp)))):
                        break
                    if (len(tempLines) != 0):
                        tempLines.pop()
                    t = (t - 1)
                t = 0
                while (t < len(tempLines)):
                    result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string((tempLines[t] if t >= 0 and t < len(tempLines) else None)))
                    t = (t + 1)
                    if (t == len(tempLines)):
                        break
                    result = (Std.string(result) + "\n")
            hx_strings_Strings.trim(result)
            return result
        temp = hx_strings_Strings.substring8(temp,3)
        current_line = start_line
        while ("\"\"\"" != hx_strings_Strings.right(temp,3)):
            result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string(temp))
            result = (Std.string(result) + "\n")
            current_line = (current_line + 1)
            if (len(self.fileLines) <= current_line):
                self.getStrML_end_line = current_line
                err_msg = "ERROR: Missing \"\"\" (3 double quote characters) at end.\n"
                _this = self.error_msgs
                _this.append(err_msg)
                forGL_ForGL_ui.status("")
                forGL_ForGL_ui.error(err_msg,1)
                return ""
            temp = (self.fileLines[current_line] if current_line >= 0 and current_line < len(self.fileLines) else None)
        temp = hx_strings_Strings.substring8(temp,0,(((0 if ((temp is None)) else len(temp))) - 3))
        result = hx_strings_Strings.insertAt(result,(0 if ((result is None)) else len(result)),Std.string(temp))
        self.getStrML_end_line = current_line
        self.valid_str_ML = True
        return result

    def getWordList(self,warn_not_unique = None):
        if (warn_not_unique is None):
            warn_not_unique = True
        i = 0
        ret_list = list()
        if (0 < len(self.word_list)):
            i = 0
            while (i < len(self.word_list)):
                x = (self.word_list[i] if i >= 0 and i < len(self.word_list) else None)
                ret_list.append(x)
                i = (i + 1)
            return ret_list
        k = 0
        k_limit = 0
        line_num = "0"
        line_limit = (len(self.fileLines) - 1)
        line_buf = ""
        word_type = 0
        word_name = ""
        built_in_name = ""
        value = ""
        while (i < len(self.sections)):
            word_type = 0
            word_name = ""
            built_in_name = ""
            value = ""
            k = (self.sections[i] if i >= 0 and i < len(self.sections) else None)
            if (i < ((len(self.sections) - 1))):
                k_limit = (python_internal_ArrayImpl._get(self.sections, (i + 1)) - 1)
            else:
                k_limit = line_limit
            k = (k + 1)
            while (k <= k_limit):
                line_buf = (self.fileLines[k] if k >= 0 and k < len(self.fileLines) else None)
                line_num = Std.string((k + 1))
                if ("word_type" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 9)) else hx_strings_Strings.substring8(line_buf,0,9)))):
                    temp_word_type_str = self.getStr(line_buf,True)
                    if (0 != self.getStr_type):
                        word_type = self.getStr_type
                    else:
                        warn_msg = (((("WARNING: Invalid word type: " + Std.string(temp_word_type_str)) + " at line ") + ("null" if line_num is None else line_num)) + " found. Skipping to next word.\n")
                        _this = self.warning_msgs
                        _this.append(warn_msg)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg,1,False,True)
                        break
                elif ("name" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 4)) else hx_strings_Strings.substring8(line_buf,0,4)))):
                    if (0 == word_type):
                        warn_msg1 = (("WARNING: word_type needs to be before name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this1 = self.warning_msgs
                        _this1.append(warn_msg1)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg1,1,False,True)
                        break
                    temp_name = self.getStr(line_buf)
                    valid_name = False
                    if (0 < ((0 if ((temp_name is None)) else len(temp_name)))):
                        if (2 == word_type):
                            valid_name = self.nameValidate(temp_name,False)
                        else:
                            valid_name = self.nameValidate(temp_name)
                        if (valid_name and warn_not_unique):
                            n = 0
                            word_name_lower = hx_strings_Strings.toLowerCase8(temp_name)
                            while (n < len(self.word_list)):
                                if (hx_strings_Strings.toLowerCase8((self.word_list[n] if n >= 0 and n < len(self.word_list) else None)) == word_name_lower):
                                    break
                                n = (n + 1)
                            if (n < len(self.word_list)):
                                warn_msg2 = (((("\nWARNING: word_name " + Std.string(temp_name)) + " at line ") + ("null" if line_num is None else line_num)) + " is not unique. Spelling matches earlier word.\n")
                                _this2 = self.warning_msgs
                                _this2.append(warn_msg2)
                                forGL_ForGL_ui.status("")
                                forGL_ForGL_ui.status(warn_msg2,1,False,True)
                                break
                    if valid_name:
                        word_name = temp_name
                    else:
                        warn_msg3 = (((("WARNING: Invalid name: " + Std.string(temp_name)) + " at line ") + ("null" if line_num is None else line_num)) + ". Skipping.\n")
                        _this3 = self.warning_msgs
                        _this3.append(warn_msg3)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg3,1,False,True)
                        break
                elif ("built_in_name" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 13)) else hx_strings_Strings.substring8(line_buf,0,13)))):
                    if (0 == word_type):
                        warn_msg4 = (("WARNING: word_type needs to be before built_in_name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this4 = self.warning_msgs
                        _this4.append(warn_msg4)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg4,1,False,True)
                        break
                    if (0 == ((0 if ((word_name is None)) else len(word_name)))):
                        warn_msg5 = (("WARNING: name needs to be before built_in_name at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this5 = self.warning_msgs
                        _this5.append(warn_msg5)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg5,1,False,True)
                        break
                    temp_built_in_name = self.getStr(line_buf)
                    valid_built_in_name = False
                    if (0 < ((0 if ((temp_built_in_name is None)) else len(temp_built_in_name)))):
                        if (2 == word_type):
                            valid_built_in_name = self.nameValidate(temp_built_in_name,False)
                        else:
                            valid_built_in_name = self.nameValidate(temp_built_in_name)
                    if valid_built_in_name:
                        built_in_name = temp_built_in_name
                    else:
                        warn_msg6 = (((("WARNING: Invalid built in name: " + Std.string(temp_built_in_name)) + " at line ") + ("null" if line_num is None else line_num)) + " found. Skipping to next word.\n")
                        _this6 = self.warning_msgs
                        _this6.append(warn_msg6)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg6,1,False,True)
                        break
                elif ("value" == ((line_buf if ((((0 if ((line_buf is None)) else len(line_buf))) <= 5)) else hx_strings_Strings.substring8(line_buf,0,5)))):
                    if (0 == word_type):
                        warn_msg7 = (("WARNING: word_type needs to be before value at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this7 = self.warning_msgs
                        _this7.append(warn_msg7)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg7,1,False,True)
                        break
                    if (0 == ((0 if ((word_name is None)) else len(word_name)))):
                        warn_msg8 = (("WARNING: name needs to be before value at line " + ("null" if line_num is None else line_num)) + " Skipping to next word.\n")
                        _this8 = self.warning_msgs
                        _this8.append(warn_msg8)
                        forGL_ForGL_ui.status("")
                        forGL_ForGL_ui.status(warn_msg8,1,False,True)
                        break
                    temp_value = self.getStrML(word_type,line_buf,k)
                    if self.valid_str_ML:
                        value = temp_value
                        if (k_limit <= self.getStrML_end_line):
                            k = k_limit
                        else:
                            k = self.getStrML_end_line
                else:
                    tmp = ((((0 if ((line_buf is None)) else len(line_buf))) >= 9) and (("#" != hx_strings_Strings.charAt8(line_buf,0))))
                if (((k_limit <= k) and ((0 != word_type))) and ((0 < ((0 if ((word_name is None)) else len(word_name)))))):
                    if ("" == built_in_name):
                        if (2 == word_type):
                            err_msg = (((("\nERROR: Operator word_name " + Std.string(word_name)) + " near line ") + ("null" if line_num is None else line_num)) + " missing built_in_name.\n")
                            _this9 = self.error_msgs
                            _this9.append(err_msg)
                            forGL_ForGL_ui.status("")
                            forGL_ForGL_ui.error(err_msg,1)
                            break
                        built_in_name = hx_strings_Strings.toLowerCase8(word_name)
                    _this10 = self.type_list
                    _this10.append(word_type)
                    _this11 = self.word_list
                    _this11.append(word_name)
                    _this12 = self.built_in_list
                    _this12.append(built_in_name)
                    _this13 = self.value_list
                    _this13.append(value)
                k = (k + 1)
            i = (i + 1)
        i = 0
        while (i < len(self.word_list)):
            x = (self.word_list[i] if i >= 0 and i < len(self.word_list) else None)
            ret_list.append(x)
            i = (i + 1)
        return ret_list

    def getWord(self,word_visible_name,rInfo):
        ret_val = 0
        self.getWord_type = 0
        self.getWord_word_idx = -1
        rInfo.resolve_op_meaning = 0
        rInfo.resolve_out_token = ""
        rInfo.resolve_use_out = False
        rInfo.resolve_token_noun_data = 0
        rInfo.resolve_str = ""
        rInfo.resolve_float = 0.0
        rInfo.resolve_int = 0
        n = 0
        word_name_lower = hx_strings_Strings.toLowerCase8(word_visible_name)
        while (n < len(self.word_list)):
            if ((self.word_list[n] if n >= 0 and n < len(self.word_list) else None) == word_visible_name):
                break
            if (hx_strings_Strings.toLowerCase8((self.word_list[n] if n >= 0 and n < len(self.word_list) else None)) == word_name_lower):
                break
            n = (n + 1)
        if (n < len(self.word_list)):
            self.getWord_word_idx = n
            word_type = (self.type_list[n] if n >= 0 and n < len(self.type_list) else None)
            if (2 == word_type):
                self.getWord_type = 2
                rInfo.resolve_use_out = True
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (6 == word_type):
                self.getWord_type = 6
                rInfo.resolve_token_noun_data = 8
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (4 == word_type):
                self.getWord_type = 4
                rInfo.resolve_str = (self.value_list[n] if n >= 0 and n < len(self.value_list) else None)
            elif (13 == word_type):
                self.getWord_type = 13
                rInfo.resolve_use_out = True
            else:
                forGL_ForGL_ui.error("INTERNAL ERROR: Unexpected word type in getWord.",1)
            rInfo.resolve_out_token = (self.built_in_list[n] if n >= 0 and n < len(self.built_in_list) else None)
        else:
            ret_val = -3
        return ret_val

    def changeOrAddWord(self,word_visible_name,word_type,rInfo):
        ret_val = 0
        self.changeOrAddWord_changed = False
        self.changeOrAddWord_msgs = ""
        get_rInfo = forGL_ResolveInfo()
        value = ""
        idx = -1
        getWord_result = self.getWord(word_visible_name,get_rInfo)
        if (4 == word_type):
            value = rInfo.resolve_str
        elif (6 == word_type):
            if (8 == rInfo.resolve_token_noun_data):
                value = rInfo.resolve_str
                if (((((0 if ((value is None)) else len(value))) < 2) or (("\"" != hx_strings_Strings.charAt8(value,0)))) or (("\"" != hx_strings_Strings.charAt8(value,(((0 if ((value is None)) else len(value))) - 1))))):
                    value = (("\"" + Std.string(value)) + "\"")
            elif (11 == rInfo.resolve_token_noun_data):
                value = Std.string(rInfo.resolve_float)
            elif (9 == rInfo.resolve_token_noun_data):
                value = Std.string(rInfo.resolve_int)
            elif (10 == rInfo.resolve_token_noun_data):
                if (1 == rInfo.resolve_int):
                    value = "true"
                else:
                    value = "false"
            else:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.changeOrAddWord_msgs
                _hx_local_0.changeOrAddWord_msgs = (Std.string(_hx_local_1) + HxOverrides.stringOrNull(((("INTERNAL ERROR: Noun type not recognized: " + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr(rInfo.resolve_token_noun_data))) + "\n"))))
                _hx_local_0.changeOrAddWord_msgs
                value = "0"
                ret_val = -11
        def _hx_local_3():
            _hx_local_2 = getWord_result
            if (Std.isOfType(_hx_local_2,Int) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise "Class cast error"
            return _hx_local_2
        if (0 == _hx_local_3()):
            self.changeOrAddWord_changed = True
            idx = self.getWord_word_idx
            python_internal_ArrayImpl._set(self.type_list, idx, word_type)
            python_internal_ArrayImpl._set(self.word_list, idx, word_visible_name)
            if ((2 == word_type) or ((13 == word_type))):
                python_internal_ArrayImpl._set(self.built_in_list, idx, rInfo.resolve_out_token)
            else:
                python_internal_ArrayImpl._set(self.value_list, idx, value)
        else:
            _this = self.word_list
            _this.append(word_visible_name)
            _this = self.type_list
            _this.append(word_type)
            if ((2 == word_type) or ((13 == word_type))):
                _this = self.built_in_list
                x = rInfo.resolve_out_token
                _this.append(x)
                value = ""
            else:
                _this = self.built_in_list
                _this.append("")
            _this = self.value_list
            _this.append(value)
        return ret_val

    def saveData(self,new_path_name):
        ret_val = 0
        try:
            out_file = sys_io_File.write(new_path_name,False)
            line = ""
            word_idx = -1
            word_type_idx = -1
            name_idx = -1
            built_in_idx = -1
            value_idx = -1
            found_name = False
            temp_name = ""
            temp_type = 0
            temp_built_in = ""
            temp_value = ""
            rInfo = forGL_ResolveInfo()
            words_to_do = self.getWordList(False)
            if (0 == len(words_to_do)):
                return 0
            i = 0
            while (i < len(self.fileLines)):
                line = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                if ((0 == ((0 if ((line is None)) else len(line)))) or (("#" == hx_strings_Strings.charAt8(line,0)))):
                    i = (i + 1)
                    continue
                if ("word_type" == ((line if ((((0 if ((line is None)) else len(line))) <= 9)) else hx_strings_Strings.substring8(line,0,9)))):
                    word_idx = -1
                    name_idx = -1
                    built_in_idx = -1
                    value_idx = -1
                    word_type_idx = i
                    self.getStr(line,True)
                    temp_type = self.getStr_type
                elif ("name" == ((line if ((((0 if ((line is None)) else len(line))) <= 4)) else hx_strings_Strings.substring8(line,0,4)))):
                    name_idx = i
                    temp_name = self.getStr(line)
                    getWord_result = self.getWord(temp_name,rInfo)
                    def _hx_local_2():
                        _hx_local_1 = getWord_result
                        if (Std.isOfType(_hx_local_1,Int) or ((_hx_local_1 is None))):
                            _hx_local_1
                        else:
                            raise "Class cast error"
                        return _hx_local_1
                    if (0 == _hx_local_2()):
                        word_idx = self.getWord_word_idx
                        found_name = True
                elif ("built_in_name" == ((line if ((((0 if ((line is None)) else len(line))) <= 13)) else hx_strings_Strings.substring8(line,0,13)))):
                    built_in_idx = i
                elif ("value" == ((line if ((((0 if ((line is None)) else len(line))) <= 5)) else hx_strings_Strings.substring8(line,0,5)))):
                    value_idx = i
                else:
                    i = (i + 1)
                    continue
                if ((0 <= built_in_idx) or ((0 <= value_idx))):
                    if found_name:
                        if (2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"operator\"")
                        elif (6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"noun\"")
                        elif (4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"verb\"")
                        elif (13 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                            python_internal_ArrayImpl._set(self.fileLines, word_type_idx, "word_type = \"choice\"")
                        python_internal_ArrayImpl._set(self.fileLines, name_idx, (("name = \"" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "\""))
                        if ((2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)) or ((13 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)))):
                            python_internal_ArrayImpl._set(self.fileLines, built_in_idx, (("built_in_name = \"" + Std.string((self.built_in_list[word_idx] if word_idx >= 0 and word_idx < len(self.built_in_list) else None))) + "\""))
                        else:
                            python_internal_ArrayImpl._set(self.fileLines, value_idx, ("value = " + Std.string((self.value_list[word_idx] if word_idx >= 0 and word_idx < len(self.value_list) else None))))
                        python_internal_ArrayImpl.remove(words_to_do,temp_name)
                        temp_name = ""
                        found_name = False
                i = (i + 1)
            i = 0
            while (i < len(self.fileLines)):
                line = (self.fileLines[i] if i >= 0 and i < len(self.fileLines) else None)
                out_file.writeString((Std.string(line) + "\n"))
                i = (i + 1)
            out_file.flush()
            word_name = ""
            k = 0
            i = 0
            while (i < len(words_to_do)):
                word_name = (words_to_do[i] if i >= 0 and i < len(words_to_do) else None)
                k = 0
                while (k < len(self.word_list)):
                    if (word_name == (self.word_list[k] if k >= 0 and k < len(self.word_list) else None)):
                        word_idx = k
                        break
                    k = (k + 1)
                if (len(self.word_list) <= k):
                    line = (("# INTERNAL ERROR: Expected word " + Std.string((words_to_do[i] if i >= 0 and i < len(words_to_do) else None))) + " not found.")
                    out_file.writeString((Std.string(line) + "\n"))
                    i = (i + 1)
                    continue
                out_file.writeString("\n")
                line = (("[_" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "_]")
                out_file.writeString((Std.string(line) + "\n"))
                line = "word_type = \""
                if (2 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "operator\"")
                elif (6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "noun\"")
                elif (4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "verb\"")
                elif (13 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)):
                    line = (Std.string(line) + "choice\"")
                else:
                    line = ((("# INTERNAL ERROR: word " + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + " has invalid word_type : ") + HxOverrides.stringOrNull(forGL_NLTypeAs.nlTypeAsStr((self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None))))
                    out_file.writeString((Std.string(line) + "\n"))
                    i = (i + 1)
                    continue
                out_file.writeString((Std.string(line) + "\n"))
                line = (("name = \"" + Std.string((self.word_list[word_idx] if word_idx >= 0 and word_idx < len(self.word_list) else None))) + "\"")
                out_file.writeString((Std.string(line) + "\n"))
                if ((6 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)) or ((4 == (self.type_list[word_idx] if word_idx >= 0 and word_idx < len(self.type_list) else None)))):
                    line = ("value = " + Std.string((self.value_list[word_idx] if word_idx >= 0 and word_idx < len(self.value_list) else None)))
                else:
                    line = (("built_in_name = \"" + Std.string((self.built_in_list[word_idx] if word_idx >= 0 and word_idx < len(self.built_in_list) else None))) + "\"")
                out_file.writeString((Std.string(line) + "\n"))
                i = (i + 1)
            out_file.flush()
            out_file.close()
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            forGL_ForGL_ui.msg((("\nException in saveData(): " + Std.string(e)) + " \n"))
            ret_val = -11
        return ret_val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.actual_path_file = None
        _hx_o.actual_file_type = None
        _hx_o.error_msgs = None
        _hx_o.warning_msgs = None
        _hx_o.data_call_count = None
        _hx_o.fReadHandle = None
        _hx_o.ws_chars = None
        _hx_o.fileLines = None
        _hx_o.comment_lines = None
        _hx_o.sections = None
        _hx_o.section_names = None
        _hx_o.word_list = None
        _hx_o.type_list = None
        _hx_o.built_in_list = None
        _hx_o.value_list = None
        _hx_o.getStr_type = None
        _hx_o.getStrML_end_line = None
        _hx_o.valid_str_ML = None
        _hx_o.getWord_type = None
        _hx_o.getWord_word_idx = None
        _hx_o.changeOrAddWord_changed = None
        _hx_o.changeOrAddWord_msgs = None


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "get_message", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def get_message(self):
        return str(self)

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___nativeStack = None
        _hx_o._hx___skipStack = None
        _hx_o._hx___nativeException = None
        _hx_o._hx___previousException = None


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value

    def unwrap(self):
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["get", "update"]
    _hx_statics = ["make"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def get(self):
        return ((self.a2 << 16) | self.a1)

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    @staticmethod
    def make(b):
        a = haxe_crypto_Adler32()
        a.update(b,0,b.length)
        return a.get()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString", "toString"]
    _hx_statics = ["alloc", "ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g = 0
        _g1 = self.base.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i], i)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise haxe_Exception.thrown("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None


class haxe_crypto_Crc32:
    _hx_class_name = "haxe.crypto.Crc32"
    __slots__ = ()
    _hx_statics = ["make"]

    @staticmethod
    def make(data):
        c_crc = -1
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp = (((c_crc ^ b[i])) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
        return (c_crc ^ -1)


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None


class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.posInfos = None


class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = bytearray()

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        _this.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    __slots__ = ()
    _hx_statics = ["addTrailingSlash"]

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex = None
        c2 = None
        if (startIndex is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i = path.rfind("\\", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("\\"))) if ((i == -1)) else (i + 1))
            check = path.find("\\", startLeft, len(path))
            c2 = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.array = None
        _hx_o.current = None


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.array = None

class haxe_macro_StringLiteralKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.StringLiteralKind"
    _hx_constructs = ["DoubleQuotes", "SingleQuotes"]
haxe_macro_StringLiteralKind.DoubleQuotes = haxe_macro_StringLiteralKind("DoubleQuotes", 0, ())
haxe_macro_StringLiteralKind.SingleQuotes = haxe_macro_StringLiteralKind("SingleQuotes", 1, ())

class haxe_macro_Constant(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Constant"
    _hx_constructs = ["CInt", "CFloat", "CString", "CIdent", "CRegexp"]

    @staticmethod
    def CInt(v,s = None):
        return haxe_macro_Constant("CInt", 0, (v,s))

    @staticmethod
    def CFloat(f,s = None):
        return haxe_macro_Constant("CFloat", 1, (f,s))

    @staticmethod
    def CString(s,kind = None):
        return haxe_macro_Constant("CString", 2, (s,kind))

    @staticmethod
    def CIdent(s):
        return haxe_macro_Constant("CIdent", 3, (s,))

    @staticmethod
    def CRegexp(r,opt):
        return haxe_macro_Constant("CRegexp", 4, (r,opt))

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn", "OpNullCoal"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, (op,))
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, ())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, ())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, ())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, ())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, ())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, ())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, ())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, ())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, ())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, ())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, ())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, ())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, ())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, ())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, ())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, ())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, ())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, ())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, ())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, ())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, ())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, ())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, ())
haxe_macro_Binop.OpNullCoal = haxe_macro_Binop("OpNullCoal", 24, ())

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits", "OpSpread"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, ())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, ())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, ())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, ())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, ())
haxe_macro_Unop.OpSpread = haxe_macro_Unop("OpSpread", 5, ())

class haxe_macro_EFieldKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.EFieldKind"
    _hx_constructs = ["Normal", "Safe"]
haxe_macro_EFieldKind.Normal = haxe_macro_EFieldKind("Normal", 0, ())
haxe_macro_EFieldKind.Safe = haxe_macro_EFieldKind("Safe", 1, ())

class haxe_macro_FunctionKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.FunctionKind"
    _hx_constructs = ["FAnonymous", "FNamed", "FArrow"]

    @staticmethod
    def FNamed(name,inlined = None):
        return haxe_macro_FunctionKind("FNamed", 1, (name,inlined))
haxe_macro_FunctionKind.FAnonymous = haxe_macro_FunctionKind("FAnonymous", 0, ())
haxe_macro_FunctionKind.FArrow = haxe_macro_FunctionKind("FArrow", 2, ())

class haxe_macro_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ExprDef"
    _hx_constructs = ["EConst", "EArray", "EBinop", "EField", "EParenthesis", "EObjectDecl", "EArrayDecl", "ECall", "ENew", "EUnop", "EVars", "EFunction", "EBlock", "EFor", "EIf", "EWhile", "ESwitch", "ETry", "EReturn", "EBreak", "EContinue", "EUntyped", "EThrow", "ECast", "EDisplay", "ETernary", "ECheckType", "EMeta", "EIs"]

    @staticmethod
    def EConst(c):
        return haxe_macro_ExprDef("EConst", 0, (c,))

    @staticmethod
    def EArray(e1,e2):
        return haxe_macro_ExprDef("EArray", 1, (e1,e2))

    @staticmethod
    def EBinop(op,e1,e2):
        return haxe_macro_ExprDef("EBinop", 2, (op,e1,e2))

    @staticmethod
    def EField(e,field,kind = None):
        return haxe_macro_ExprDef("EField", 3, (e,field,kind))

    @staticmethod
    def EParenthesis(e):
        return haxe_macro_ExprDef("EParenthesis", 4, (e,))

    @staticmethod
    def EObjectDecl(fields):
        return haxe_macro_ExprDef("EObjectDecl", 5, (fields,))

    @staticmethod
    def EArrayDecl(values):
        return haxe_macro_ExprDef("EArrayDecl", 6, (values,))

    @staticmethod
    def ECall(e,params):
        return haxe_macro_ExprDef("ECall", 7, (e,params))

    @staticmethod
    def ENew(t,params):
        return haxe_macro_ExprDef("ENew", 8, (t,params))

    @staticmethod
    def EUnop(op,postFix,e):
        return haxe_macro_ExprDef("EUnop", 9, (op,postFix,e))

    @staticmethod
    def EVars(vars):
        return haxe_macro_ExprDef("EVars", 10, (vars,))

    @staticmethod
    def EFunction(kind,f):
        return haxe_macro_ExprDef("EFunction", 11, (kind,f))

    @staticmethod
    def EBlock(exprs):
        return haxe_macro_ExprDef("EBlock", 12, (exprs,))

    @staticmethod
    def EFor(it,expr):
        return haxe_macro_ExprDef("EFor", 13, (it,expr))

    @staticmethod
    def EIf(econd,eif,eelse):
        return haxe_macro_ExprDef("EIf", 14, (econd,eif,eelse))

    @staticmethod
    def EWhile(econd,e,normalWhile):
        return haxe_macro_ExprDef("EWhile", 15, (econd,e,normalWhile))

    @staticmethod
    def ESwitch(e,cases,edef):
        return haxe_macro_ExprDef("ESwitch", 16, (e,cases,edef))

    @staticmethod
    def ETry(e,catches):
        return haxe_macro_ExprDef("ETry", 17, (e,catches))

    @staticmethod
    def EReturn(e = None):
        return haxe_macro_ExprDef("EReturn", 18, (e,))

    @staticmethod
    def EUntyped(e):
        return haxe_macro_ExprDef("EUntyped", 21, (e,))

    @staticmethod
    def EThrow(e):
        return haxe_macro_ExprDef("EThrow", 22, (e,))

    @staticmethod
    def ECast(e,t):
        return haxe_macro_ExprDef("ECast", 23, (e,t))

    @staticmethod
    def EDisplay(e,displayKind):
        return haxe_macro_ExprDef("EDisplay", 24, (e,displayKind))

    @staticmethod
    def ETernary(econd,eif,eelse):
        return haxe_macro_ExprDef("ETernary", 25, (econd,eif,eelse))

    @staticmethod
    def ECheckType(e,t):
        return haxe_macro_ExprDef("ECheckType", 26, (e,t))

    @staticmethod
    def EMeta(s,e):
        return haxe_macro_ExprDef("EMeta", 27, (s,e))

    @staticmethod
    def EIs(e,t):
        return haxe_macro_ExprDef("EIs", 28, (e,t))
haxe_macro_ExprDef.EBreak = haxe_macro_ExprDef("EBreak", 19, ())
haxe_macro_ExprDef.EContinue = haxe_macro_ExprDef("EContinue", 20, ())

class haxe_macro_DisplayKind(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.DisplayKind"
    _hx_constructs = ["DKCall", "DKDot", "DKStructure", "DKMarked", "DKPattern"]

    @staticmethod
    def DKPattern(outermost):
        return haxe_macro_DisplayKind("DKPattern", 4, (outermost,))
haxe_macro_DisplayKind.DKCall = haxe_macro_DisplayKind("DKCall", 0, ())
haxe_macro_DisplayKind.DKDot = haxe_macro_DisplayKind("DKDot", 1, ())
haxe_macro_DisplayKind.DKStructure = haxe_macro_DisplayKind("DKStructure", 2, ())
haxe_macro_DisplayKind.DKMarked = haxe_macro_DisplayKind("DKMarked", 3, ())

class haxe_macro_ComplexType(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.ComplexType"
    _hx_constructs = ["TPath", "TFunction", "TAnonymous", "TParent", "TExtend", "TOptional", "TNamed", "TIntersection"]

    @staticmethod
    def TPath(p):
        return haxe_macro_ComplexType("TPath", 0, (p,))

    @staticmethod
    def TFunction(args,ret):
        return haxe_macro_ComplexType("TFunction", 1, (args,ret))

    @staticmethod
    def TAnonymous(fields):
        return haxe_macro_ComplexType("TAnonymous", 2, (fields,))

    @staticmethod
    def TParent(t):
        return haxe_macro_ComplexType("TParent", 3, (t,))

    @staticmethod
    def TExtend(p,fields):
        return haxe_macro_ComplexType("TExtend", 4, (p,fields))

    @staticmethod
    def TOptional(t):
        return haxe_macro_ComplexType("TOptional", 5, (t,))

    @staticmethod
    def TNamed(n,t):
        return haxe_macro_ComplexType("TNamed", 6, (n,t))

    @staticmethod
    def TIntersection(tl):
        return haxe_macro_ComplexType("TIntersection", 7, (tl,))


class hx_strings__AnyAsString_AnyAsString_Impl_:
    _hx_class_name = "hx.strings._AnyAsString.AnyAsString_Impl_"
    __slots__ = ()
    _hx_statics = ["fromBool", "fromAny"]

    @staticmethod
    def fromBool(value):
        if value:
            return "true"
        else:
            return "false"

    @staticmethod
    def fromAny(value):
        return Std.string(value)


class hx_strings__Char_CharCaseMapper:
    _hx_class_name = "hx.strings._Char.CharCaseMapper"
    __slots__ = ("mapU2L", "mapL2U")
    _hx_fields = ["mapU2L", "mapL2U"]
    _hx_methods = ["_addCaseMapping", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase"]

    def __init__(self):
        self.mapL2U = haxe_ds_IntMap()
        self.mapU2L = haxe_ds_IntMap()
        self._addCaseMapping(97,65)
        self._addCaseMapping(98,66)
        self._addCaseMapping(99,67)
        self._addCaseMapping(100,68)
        self._addCaseMapping(101,69)
        self._addCaseMapping(102,70)
        self._addCaseMapping(103,71)
        self._addCaseMapping(104,72)
        self._addCaseMapping(105,73)
        self._addCaseMapping(106,74)
        self._addCaseMapping(107,75)
        self._addCaseMapping(108,76)
        self._addCaseMapping(109,77)
        self._addCaseMapping(110,78)
        self._addCaseMapping(111,79)
        self._addCaseMapping(112,80)
        self._addCaseMapping(113,81)
        self._addCaseMapping(114,82)
        self._addCaseMapping(115,83)
        self._addCaseMapping(116,84)
        self._addCaseMapping(117,85)
        self._addCaseMapping(118,86)
        self._addCaseMapping(119,87)
        self._addCaseMapping(120,88)
        self._addCaseMapping(121,89)
        self._addCaseMapping(122,90)
        self._addCaseMapping(224,192)
        self._addCaseMapping(225,193)
        self._addCaseMapping(226,194)
        self._addCaseMapping(227,195)
        self._addCaseMapping(228,196)
        self._addCaseMapping(229,197)
        self._addCaseMapping(230,198)
        self._addCaseMapping(231,199)
        self._addCaseMapping(232,200)
        self._addCaseMapping(233,201)
        self._addCaseMapping(234,202)
        self._addCaseMapping(235,203)
        self._addCaseMapping(236,204)
        self._addCaseMapping(237,205)
        self._addCaseMapping(238,206)
        self._addCaseMapping(239,207)
        self._addCaseMapping(240,208)
        self._addCaseMapping(241,209)
        self._addCaseMapping(242,210)
        self._addCaseMapping(243,211)
        self._addCaseMapping(244,212)
        self._addCaseMapping(245,213)
        self._addCaseMapping(246,214)
        self._addCaseMapping(248,216)
        self._addCaseMapping(249,217)
        self._addCaseMapping(250,218)
        self._addCaseMapping(251,219)
        self._addCaseMapping(252,220)
        self._addCaseMapping(253,221)
        self._addCaseMapping(254,222)
        self._addCaseMapping(255,376)
        self._addCaseMapping(257,256)
        self._addCaseMapping(259,258)
        self._addCaseMapping(261,260)
        self._addCaseMapping(263,262)
        self._addCaseMapping(265,264)
        self._addCaseMapping(267,266)
        self._addCaseMapping(269,268)
        self._addCaseMapping(271,270)
        self._addCaseMapping(273,272)
        self._addCaseMapping(275,274)
        self._addCaseMapping(277,276)
        self._addCaseMapping(279,278)
        self._addCaseMapping(281,280)
        self._addCaseMapping(283,282)
        self._addCaseMapping(285,284)
        self._addCaseMapping(287,286)
        self._addCaseMapping(289,288)
        self._addCaseMapping(291,290)
        self._addCaseMapping(293,292)
        self._addCaseMapping(295,294)
        self._addCaseMapping(297,296)
        self._addCaseMapping(299,298)
        self._addCaseMapping(301,300)
        self._addCaseMapping(303,302)
        self._addCaseMapping(305,73)
        self._addCaseMapping(307,306)
        self._addCaseMapping(309,308)
        self._addCaseMapping(311,310)
        self._addCaseMapping(314,313)
        self._addCaseMapping(316,315)
        self._addCaseMapping(318,317)
        self._addCaseMapping(320,319)
        self._addCaseMapping(322,321)
        self._addCaseMapping(324,323)
        self._addCaseMapping(326,325)
        self._addCaseMapping(328,327)
        self._addCaseMapping(331,330)
        self._addCaseMapping(333,332)
        self._addCaseMapping(335,334)
        self._addCaseMapping(337,336)
        self._addCaseMapping(339,338)
        self._addCaseMapping(341,340)
        self._addCaseMapping(343,342)
        self._addCaseMapping(345,344)
        self._addCaseMapping(347,346)
        self._addCaseMapping(349,348)
        self._addCaseMapping(351,350)
        self._addCaseMapping(353,352)
        self._addCaseMapping(355,354)
        self._addCaseMapping(357,356)
        self._addCaseMapping(359,358)
        self._addCaseMapping(361,360)
        self._addCaseMapping(363,362)
        self._addCaseMapping(365,364)
        self._addCaseMapping(367,366)
        self._addCaseMapping(369,368)
        self._addCaseMapping(371,370)
        self._addCaseMapping(373,372)
        self._addCaseMapping(375,374)
        self._addCaseMapping(378,377)
        self._addCaseMapping(380,379)
        self._addCaseMapping(382,381)
        self._addCaseMapping(387,386)
        self._addCaseMapping(389,388)
        self._addCaseMapping(392,391)
        self._addCaseMapping(396,395)
        self._addCaseMapping(402,401)
        self._addCaseMapping(409,408)
        self._addCaseMapping(417,416)
        self._addCaseMapping(419,418)
        self._addCaseMapping(421,420)
        self._addCaseMapping(424,423)
        self._addCaseMapping(429,428)
        self._addCaseMapping(432,431)
        self._addCaseMapping(436,435)
        self._addCaseMapping(438,437)
        self._addCaseMapping(441,440)
        self._addCaseMapping(445,444)
        self._addCaseMapping(454,452)
        self._addCaseMapping(457,455)
        self._addCaseMapping(460,458)
        self._addCaseMapping(462,461)
        self._addCaseMapping(464,463)
        self._addCaseMapping(466,465)
        self._addCaseMapping(468,467)
        self._addCaseMapping(470,469)
        self._addCaseMapping(472,471)
        self._addCaseMapping(474,473)
        self._addCaseMapping(476,475)
        self._addCaseMapping(479,478)
        self._addCaseMapping(481,480)
        self._addCaseMapping(483,482)
        self._addCaseMapping(485,484)
        self._addCaseMapping(487,486)
        self._addCaseMapping(489,488)
        self._addCaseMapping(491,490)
        self._addCaseMapping(493,492)
        self._addCaseMapping(495,494)
        self._addCaseMapping(499,497)
        self._addCaseMapping(501,500)
        self._addCaseMapping(507,506)
        self._addCaseMapping(509,508)
        self._addCaseMapping(511,510)
        self._addCaseMapping(513,512)
        self._addCaseMapping(515,514)
        self._addCaseMapping(517,516)
        self._addCaseMapping(519,518)
        self._addCaseMapping(521,520)
        self._addCaseMapping(523,522)
        self._addCaseMapping(525,524)
        self._addCaseMapping(527,526)
        self._addCaseMapping(529,528)
        self._addCaseMapping(531,530)
        self._addCaseMapping(533,532)
        self._addCaseMapping(535,534)
        self._addCaseMapping(595,385)
        self._addCaseMapping(596,390)
        self._addCaseMapping(599,394)
        self._addCaseMapping(600,398)
        self._addCaseMapping(601,399)
        self._addCaseMapping(603,400)
        self._addCaseMapping(608,403)
        self._addCaseMapping(611,404)
        self._addCaseMapping(616,407)
        self._addCaseMapping(617,406)
        self._addCaseMapping(623,412)
        self._addCaseMapping(626,413)
        self._addCaseMapping(629,415)
        self._addCaseMapping(643,425)
        self._addCaseMapping(648,430)
        self._addCaseMapping(650,433)
        self._addCaseMapping(651,434)
        self._addCaseMapping(658,439)
        self._addCaseMapping(924,181)
        self._addCaseMapping(940,902)
        self._addCaseMapping(941,904)
        self._addCaseMapping(942,905)
        self._addCaseMapping(943,906)
        self._addCaseMapping(945,913)
        self._addCaseMapping(946,914)
        self._addCaseMapping(947,915)
        self._addCaseMapping(948,916)
        self._addCaseMapping(949,917)
        self._addCaseMapping(950,918)
        self._addCaseMapping(951,919)
        self._addCaseMapping(952,920)
        self._addCaseMapping(953,921)
        self._addCaseMapping(954,922)
        self._addCaseMapping(955,923)
        self._addCaseMapping(956,924)
        self._addCaseMapping(957,925)
        self._addCaseMapping(958,926)
        self._addCaseMapping(959,927)
        self._addCaseMapping(960,928)
        self._addCaseMapping(961,929)
        self._addCaseMapping(963,931)
        self._addCaseMapping(964,932)
        self._addCaseMapping(965,933)
        self._addCaseMapping(966,934)
        self._addCaseMapping(967,935)
        self._addCaseMapping(968,936)
        self._addCaseMapping(969,937)
        self._addCaseMapping(970,938)
        self._addCaseMapping(971,939)
        self._addCaseMapping(972,908)
        self._addCaseMapping(973,910)
        self._addCaseMapping(974,911)
        self._addCaseMapping(995,994)
        self._addCaseMapping(997,996)
        self._addCaseMapping(999,998)
        self._addCaseMapping(1001,1000)
        self._addCaseMapping(1003,1002)
        self._addCaseMapping(1005,1004)
        self._addCaseMapping(1007,1006)
        self._addCaseMapping(1072,1040)
        self._addCaseMapping(1073,1041)
        self._addCaseMapping(1074,1042)
        self._addCaseMapping(1075,1043)
        self._addCaseMapping(1076,1044)
        self._addCaseMapping(1077,1045)
        self._addCaseMapping(1078,1046)
        self._addCaseMapping(1079,1047)
        self._addCaseMapping(1080,1048)
        self._addCaseMapping(1081,1049)
        self._addCaseMapping(1082,1050)
        self._addCaseMapping(1083,1051)
        self._addCaseMapping(1084,1052)
        self._addCaseMapping(1085,1053)
        self._addCaseMapping(1086,1054)
        self._addCaseMapping(1087,1055)
        self._addCaseMapping(1088,1056)
        self._addCaseMapping(1089,1057)
        self._addCaseMapping(1090,1058)
        self._addCaseMapping(1091,1059)
        self._addCaseMapping(1092,1060)
        self._addCaseMapping(1093,1061)
        self._addCaseMapping(1094,1062)
        self._addCaseMapping(1095,1063)
        self._addCaseMapping(1096,1064)
        self._addCaseMapping(1097,1065)
        self._addCaseMapping(1098,1066)
        self._addCaseMapping(1099,1067)
        self._addCaseMapping(1100,1068)
        self._addCaseMapping(1101,1069)
        self._addCaseMapping(1102,1070)
        self._addCaseMapping(1103,1071)
        self._addCaseMapping(1105,1025)
        self._addCaseMapping(1106,1026)
        self._addCaseMapping(1107,1027)
        self._addCaseMapping(1108,1028)
        self._addCaseMapping(1109,1029)
        self._addCaseMapping(1110,1030)
        self._addCaseMapping(1111,1031)
        self._addCaseMapping(1112,1032)
        self._addCaseMapping(1113,1033)
        self._addCaseMapping(1114,1034)
        self._addCaseMapping(1115,1035)
        self._addCaseMapping(1116,1036)
        self._addCaseMapping(1118,1038)
        self._addCaseMapping(1119,1039)
        self._addCaseMapping(1121,1120)
        self._addCaseMapping(1123,1122)
        self._addCaseMapping(1125,1124)
        self._addCaseMapping(1127,1126)
        self._addCaseMapping(1129,1128)
        self._addCaseMapping(1131,1130)
        self._addCaseMapping(1133,1132)
        self._addCaseMapping(1135,1134)
        self._addCaseMapping(1137,1136)
        self._addCaseMapping(1139,1138)
        self._addCaseMapping(1141,1140)
        self._addCaseMapping(1143,1142)
        self._addCaseMapping(1145,1144)
        self._addCaseMapping(1147,1146)
        self._addCaseMapping(1149,1148)
        self._addCaseMapping(1151,1150)
        self._addCaseMapping(1153,1152)
        self._addCaseMapping(1169,1168)
        self._addCaseMapping(1171,1170)
        self._addCaseMapping(1173,1172)
        self._addCaseMapping(1175,1174)
        self._addCaseMapping(1177,1176)
        self._addCaseMapping(1179,1178)
        self._addCaseMapping(1181,1180)
        self._addCaseMapping(1183,1182)
        self._addCaseMapping(1185,1184)
        self._addCaseMapping(1187,1186)
        self._addCaseMapping(1189,1188)
        self._addCaseMapping(1191,1190)
        self._addCaseMapping(1193,1192)
        self._addCaseMapping(1195,1194)
        self._addCaseMapping(1197,1196)
        self._addCaseMapping(1199,1198)
        self._addCaseMapping(1201,1200)
        self._addCaseMapping(1203,1202)
        self._addCaseMapping(1205,1204)
        self._addCaseMapping(1207,1206)
        self._addCaseMapping(1209,1208)
        self._addCaseMapping(1211,1210)
        self._addCaseMapping(1213,1212)
        self._addCaseMapping(1215,1214)
        self._addCaseMapping(1218,1217)
        self._addCaseMapping(1220,1219)
        self._addCaseMapping(1224,1223)
        self._addCaseMapping(1228,1227)
        self._addCaseMapping(1233,1232)
        self._addCaseMapping(1235,1234)
        self._addCaseMapping(1237,1236)
        self._addCaseMapping(1239,1238)
        self._addCaseMapping(1241,1240)
        self._addCaseMapping(1243,1242)
        self._addCaseMapping(1245,1244)
        self._addCaseMapping(1247,1246)
        self._addCaseMapping(1249,1248)
        self._addCaseMapping(1251,1250)
        self._addCaseMapping(1253,1252)
        self._addCaseMapping(1255,1254)
        self._addCaseMapping(1257,1256)
        self._addCaseMapping(1259,1258)
        self._addCaseMapping(1263,1262)
        self._addCaseMapping(1265,1264)
        self._addCaseMapping(1267,1266)
        self._addCaseMapping(1269,1268)
        self._addCaseMapping(1273,1272)
        self._addCaseMapping(1377,1329)
        self._addCaseMapping(1378,1330)
        self._addCaseMapping(1379,1331)
        self._addCaseMapping(1380,1332)
        self._addCaseMapping(1381,1333)
        self._addCaseMapping(1382,1334)
        self._addCaseMapping(1383,1335)
        self._addCaseMapping(1384,1336)
        self._addCaseMapping(1385,1337)
        self._addCaseMapping(1386,1338)
        self._addCaseMapping(1387,1339)
        self._addCaseMapping(1388,1340)
        self._addCaseMapping(1389,1341)
        self._addCaseMapping(1390,1342)
        self._addCaseMapping(1391,1343)
        self._addCaseMapping(1392,1344)
        self._addCaseMapping(1393,1345)
        self._addCaseMapping(1394,1346)
        self._addCaseMapping(1395,1347)
        self._addCaseMapping(1396,1348)
        self._addCaseMapping(1397,1349)
        self._addCaseMapping(1398,1350)
        self._addCaseMapping(1399,1351)
        self._addCaseMapping(1400,1352)
        self._addCaseMapping(1401,1353)
        self._addCaseMapping(1402,1354)
        self._addCaseMapping(1403,1355)
        self._addCaseMapping(1404,1356)
        self._addCaseMapping(1405,1357)
        self._addCaseMapping(1406,1358)
        self._addCaseMapping(1407,1359)
        self._addCaseMapping(1408,1360)
        self._addCaseMapping(1409,1361)
        self._addCaseMapping(1410,1362)
        self._addCaseMapping(1411,1363)
        self._addCaseMapping(1412,1364)
        self._addCaseMapping(1413,1365)
        self._addCaseMapping(1414,1366)
        self._addCaseMapping(4304,4256)
        self._addCaseMapping(4305,4257)
        self._addCaseMapping(4306,4258)
        self._addCaseMapping(4307,4259)
        self._addCaseMapping(4308,4260)
        self._addCaseMapping(4309,4261)
        self._addCaseMapping(4310,4262)
        self._addCaseMapping(4311,4263)
        self._addCaseMapping(4312,4264)
        self._addCaseMapping(4313,4265)
        self._addCaseMapping(4314,4266)
        self._addCaseMapping(4315,4267)
        self._addCaseMapping(4316,4268)
        self._addCaseMapping(4317,4269)
        self._addCaseMapping(4318,4270)
        self._addCaseMapping(4319,4271)
        self._addCaseMapping(4320,4272)
        self._addCaseMapping(4321,4273)
        self._addCaseMapping(4322,4274)
        self._addCaseMapping(4323,4275)
        self._addCaseMapping(4324,4276)
        self._addCaseMapping(4325,4277)
        self._addCaseMapping(4326,4278)
        self._addCaseMapping(4327,4279)
        self._addCaseMapping(4328,4280)
        self._addCaseMapping(4329,4281)
        self._addCaseMapping(4330,4282)
        self._addCaseMapping(4331,4283)
        self._addCaseMapping(4332,4284)
        self._addCaseMapping(4333,4285)
        self._addCaseMapping(4334,4286)
        self._addCaseMapping(4335,4287)
        self._addCaseMapping(4336,4288)
        self._addCaseMapping(4337,4289)
        self._addCaseMapping(4338,4290)
        self._addCaseMapping(4339,4291)
        self._addCaseMapping(4340,4292)
        self._addCaseMapping(4341,4293)
        self._addCaseMapping(7681,7680)
        self._addCaseMapping(7683,7682)
        self._addCaseMapping(7685,7684)
        self._addCaseMapping(7687,7686)
        self._addCaseMapping(7689,7688)
        self._addCaseMapping(7691,7690)
        self._addCaseMapping(7693,7692)
        self._addCaseMapping(7695,7694)
        self._addCaseMapping(7697,7696)
        self._addCaseMapping(7699,7698)
        self._addCaseMapping(7701,7700)
        self._addCaseMapping(7703,7702)
        self._addCaseMapping(7705,7704)
        self._addCaseMapping(7707,7706)
        self._addCaseMapping(7709,7708)
        self._addCaseMapping(7711,7710)
        self._addCaseMapping(7713,7712)
        self._addCaseMapping(7715,7714)
        self._addCaseMapping(7717,7716)
        self._addCaseMapping(7719,7718)
        self._addCaseMapping(7721,7720)
        self._addCaseMapping(7723,7722)
        self._addCaseMapping(7725,7724)
        self._addCaseMapping(7727,7726)
        self._addCaseMapping(7729,7728)
        self._addCaseMapping(7731,7730)
        self._addCaseMapping(7733,7732)
        self._addCaseMapping(7735,7734)
        self._addCaseMapping(7737,7736)
        self._addCaseMapping(7739,7738)
        self._addCaseMapping(7741,7740)
        self._addCaseMapping(7743,7742)
        self._addCaseMapping(7745,7744)
        self._addCaseMapping(7747,7746)
        self._addCaseMapping(7749,7748)
        self._addCaseMapping(7751,7750)
        self._addCaseMapping(7753,7752)
        self._addCaseMapping(7755,7754)
        self._addCaseMapping(7757,7756)
        self._addCaseMapping(7759,7758)
        self._addCaseMapping(7761,7760)
        self._addCaseMapping(7763,7762)
        self._addCaseMapping(7765,7764)
        self._addCaseMapping(7767,7766)
        self._addCaseMapping(7769,7768)
        self._addCaseMapping(7771,7770)
        self._addCaseMapping(7773,7772)
        self._addCaseMapping(7775,7774)
        self._addCaseMapping(7777,7776)
        self._addCaseMapping(7779,7778)
        self._addCaseMapping(7781,7780)
        self._addCaseMapping(7783,7782)
        self._addCaseMapping(7785,7784)
        self._addCaseMapping(7787,7786)
        self._addCaseMapping(7789,7788)
        self._addCaseMapping(7791,7790)
        self._addCaseMapping(7793,7792)
        self._addCaseMapping(7795,7794)
        self._addCaseMapping(7797,7796)
        self._addCaseMapping(7799,7798)
        self._addCaseMapping(7801,7800)
        self._addCaseMapping(7803,7802)
        self._addCaseMapping(7805,7804)
        self._addCaseMapping(7807,7806)
        self._addCaseMapping(7809,7808)
        self._addCaseMapping(7811,7810)
        self._addCaseMapping(7813,7812)
        self._addCaseMapping(7815,7814)
        self._addCaseMapping(7817,7816)
        self._addCaseMapping(7819,7818)
        self._addCaseMapping(7821,7820)
        self._addCaseMapping(7823,7822)
        self._addCaseMapping(7825,7824)
        self._addCaseMapping(7827,7826)
        self._addCaseMapping(7829,7828)
        self._addCaseMapping(7841,7840)
        self._addCaseMapping(7843,7842)
        self._addCaseMapping(7845,7844)
        self._addCaseMapping(7847,7846)
        self._addCaseMapping(7849,7848)
        self._addCaseMapping(7851,7850)
        self._addCaseMapping(7853,7852)
        self._addCaseMapping(7855,7854)
        self._addCaseMapping(7857,7856)
        self._addCaseMapping(7859,7858)
        self._addCaseMapping(7861,7860)
        self._addCaseMapping(7863,7862)
        self._addCaseMapping(7865,7864)
        self._addCaseMapping(7867,7866)
        self._addCaseMapping(7869,7868)
        self._addCaseMapping(7871,7870)
        self._addCaseMapping(7873,7872)
        self._addCaseMapping(7875,7874)
        self._addCaseMapping(7877,7876)
        self._addCaseMapping(7879,7878)
        self._addCaseMapping(7881,7880)
        self._addCaseMapping(7883,7882)
        self._addCaseMapping(7885,7884)
        self._addCaseMapping(7887,7886)
        self._addCaseMapping(7889,7888)
        self._addCaseMapping(7891,7890)
        self._addCaseMapping(7893,7892)
        self._addCaseMapping(7895,7894)
        self._addCaseMapping(7897,7896)
        self._addCaseMapping(7899,7898)
        self._addCaseMapping(7901,7900)
        self._addCaseMapping(7903,7902)
        self._addCaseMapping(7905,7904)
        self._addCaseMapping(7907,7906)
        self._addCaseMapping(7909,7908)
        self._addCaseMapping(7911,7910)
        self._addCaseMapping(7913,7912)
        self._addCaseMapping(7915,7914)
        self._addCaseMapping(7917,7916)
        self._addCaseMapping(7919,7918)
        self._addCaseMapping(7921,7920)
        self._addCaseMapping(7923,7922)
        self._addCaseMapping(7925,7924)
        self._addCaseMapping(7927,7926)
        self._addCaseMapping(7929,7928)
        self._addCaseMapping(7936,7944)
        self._addCaseMapping(7937,7945)
        self._addCaseMapping(7938,7946)
        self._addCaseMapping(7939,7947)
        self._addCaseMapping(7940,7948)
        self._addCaseMapping(7941,7949)
        self._addCaseMapping(7942,7950)
        self._addCaseMapping(7943,7951)
        self._addCaseMapping(7952,7960)
        self._addCaseMapping(7953,7961)
        self._addCaseMapping(7954,7962)
        self._addCaseMapping(7955,7963)
        self._addCaseMapping(7956,7964)
        self._addCaseMapping(7957,7965)
        self._addCaseMapping(7968,7976)
        self._addCaseMapping(7969,7977)
        self._addCaseMapping(7970,7978)
        self._addCaseMapping(7971,7979)
        self._addCaseMapping(7972,7980)
        self._addCaseMapping(7973,7981)
        self._addCaseMapping(7974,7982)
        self._addCaseMapping(7975,7983)
        self._addCaseMapping(7984,7992)
        self._addCaseMapping(7985,7993)
        self._addCaseMapping(7986,7994)
        self._addCaseMapping(7987,7995)
        self._addCaseMapping(7988,7996)
        self._addCaseMapping(7989,7997)
        self._addCaseMapping(7990,7998)
        self._addCaseMapping(7991,7999)
        self._addCaseMapping(8000,8008)
        self._addCaseMapping(8001,8009)
        self._addCaseMapping(8002,8010)
        self._addCaseMapping(8003,8011)
        self._addCaseMapping(8004,8012)
        self._addCaseMapping(8005,8013)
        self._addCaseMapping(8017,8025)
        self._addCaseMapping(8019,8027)
        self._addCaseMapping(8021,8029)
        self._addCaseMapping(8023,8031)
        self._addCaseMapping(8032,8040)
        self._addCaseMapping(8033,8041)
        self._addCaseMapping(8034,8042)
        self._addCaseMapping(8035,8043)
        self._addCaseMapping(8036,8044)
        self._addCaseMapping(8037,8045)
        self._addCaseMapping(8038,8046)
        self._addCaseMapping(8039,8047)
        self._addCaseMapping(8064,8072)
        self._addCaseMapping(8065,8073)
        self._addCaseMapping(8066,8074)
        self._addCaseMapping(8067,8075)
        self._addCaseMapping(8068,8076)
        self._addCaseMapping(8069,8077)
        self._addCaseMapping(8070,8078)
        self._addCaseMapping(8071,8079)
        self._addCaseMapping(8080,8088)
        self._addCaseMapping(8081,8089)
        self._addCaseMapping(8082,8090)
        self._addCaseMapping(8083,8091)
        self._addCaseMapping(8084,8092)
        self._addCaseMapping(8085,8093)
        self._addCaseMapping(8086,8094)
        self._addCaseMapping(8087,8095)
        self._addCaseMapping(8096,8104)
        self._addCaseMapping(8097,8105)
        self._addCaseMapping(8098,8106)
        self._addCaseMapping(8099,8107)
        self._addCaseMapping(8100,8108)
        self._addCaseMapping(8101,8109)
        self._addCaseMapping(8102,8110)
        self._addCaseMapping(8103,8111)
        self._addCaseMapping(8112,8120)
        self._addCaseMapping(8113,8121)
        self._addCaseMapping(8144,8152)
        self._addCaseMapping(8145,8153)
        self._addCaseMapping(8160,8168)
        self._addCaseMapping(8161,8169)
        self._addCaseMapping(9424,9398)
        self._addCaseMapping(9425,9399)
        self._addCaseMapping(9426,9400)
        self._addCaseMapping(9427,9401)
        self._addCaseMapping(9428,9402)
        self._addCaseMapping(9429,9403)
        self._addCaseMapping(9430,9404)
        self._addCaseMapping(9431,9405)
        self._addCaseMapping(9432,9406)
        self._addCaseMapping(9433,9407)
        self._addCaseMapping(9434,9408)
        self._addCaseMapping(9435,9409)
        self._addCaseMapping(9436,9410)
        self._addCaseMapping(9437,9411)
        self._addCaseMapping(9438,9412)
        self._addCaseMapping(9439,9413)
        self._addCaseMapping(9440,9414)
        self._addCaseMapping(9441,9415)
        self._addCaseMapping(9442,9416)
        self._addCaseMapping(9443,9417)
        self._addCaseMapping(9444,9418)
        self._addCaseMapping(9445,9419)
        self._addCaseMapping(9446,9420)
        self._addCaseMapping(9447,9421)
        self._addCaseMapping(9448,9422)
        self._addCaseMapping(9449,9423)
        self._addCaseMapping(65345,65313)
        self._addCaseMapping(65346,65314)
        self._addCaseMapping(65347,65315)
        self._addCaseMapping(65348,65316)
        self._addCaseMapping(65349,65317)
        self._addCaseMapping(65350,65318)
        self._addCaseMapping(65351,65319)
        self._addCaseMapping(65352,65320)
        self._addCaseMapping(65353,65321)
        self._addCaseMapping(65354,65322)
        self._addCaseMapping(65355,65323)
        self._addCaseMapping(65356,65324)
        self._addCaseMapping(65357,65325)
        self._addCaseMapping(65358,65326)
        self._addCaseMapping(65359,65327)
        self._addCaseMapping(65360,65328)
        self._addCaseMapping(65361,65329)
        self._addCaseMapping(65362,65330)
        self._addCaseMapping(65363,65331)
        self._addCaseMapping(65364,65332)
        self._addCaseMapping(65365,65333)
        self._addCaseMapping(65366,65334)
        self._addCaseMapping(65367,65335)
        self._addCaseMapping(65368,65336)
        self._addCaseMapping(65369,65337)
        self._addCaseMapping(65370,65338)

    def _addCaseMapping(self,lowerChar,upperChar):
        if (not (upperChar in self.mapU2L.h)):
            self.mapU2L.set(upperChar,lowerChar)
        if (not (lowerChar in self.mapL2U.h)):
            self.mapL2U.set(lowerChar,upperChar)

    def isLowerCase(self,ch):
        return (ch in self.mapL2U.h)

    def isUpperCase(self,ch):
        return (ch in self.mapU2L.h)

    def toLowerCase(self,ch):
        lowerChar = self.mapU2L.h.get(ch,None)
        if (lowerChar is None):
            return ch
        else:
            return lowerChar

    def toUpperCase(self,ch):
        upperChar = self.mapL2U.h.get(ch,None)
        if (upperChar is None):
            return ch
        else:
            return upperChar

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mapU2L = None
        _hx_o.mapL2U = None


class hx_strings__Char_Char_Impl_:
    _hx_class_name = "hx.strings._Char.Char_Impl_"
    __slots__ = ()
    _hx_statics = ["CHAR_CASE_MAPPER", "BACKSPACE", "TAB", "LF", "CR", "ESC", "SPACE", "EXCLAMATION_MARK", "DOUBLE_QUOTE", "HASH", "DOLLAR", "AMPERSAND", "SINGLE_QUOTE", "BRACKET_ROUND_LEFT", "BRACKET_ROUND_RIGHT", "ASTERISK", "PLUS", "COMMA", "MINUS", "DOT", "SLASH", "ZERO", "ONE", "TWO", "TRHEE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON", "LOWER_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "BRACKET_SQUARE_LEFT", "BACKSLASH", "BRACKET_SQUARE_RIGHT", "CARET", "UNDERSCORE", "BRACKET_CURLY_LEFT", "PIPE", "BRACKET_CURLY_RIGHT", "fromString", "of", "op_plus_string", "op_plus_string2", "op_plus", "isAscii", "isAsciiAlpha", "isAsciiAlphanumeric", "isAsciiControl", "isAsciiPrintable", "isDigit", "isEOF", "isSpace", "isUTF8", "isWhitespace", "isLowerCase", "isUpperCase", "toLowerCase", "toUpperCase", "toInt", "toString"]

    @staticmethod
    def fromString(_hx_str):
        return hx_strings_Strings.charCodeAt8(_hx_str,0)

    @staticmethod
    def of(ch):
        return ch

    @staticmethod
    def op_plus_string(ch,other):
        return (HxOverrides.stringOrNull("".join(map(chr,[ch]))) + ("null" if other is None else other))

    @staticmethod
    def op_plus_string2(_hx_str,ch):
        return (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull("".join(map(chr,[ch]))))

    @staticmethod
    def op_plus(ch,other):
        return (ch + other)

    @staticmethod
    def isAscii(this1):
        if (this1 > -1):
            return (this1 < 128)
        else:
            return False

    @staticmethod
    def isAsciiAlpha(this1):
        if (not (((this1 > 64) and ((this1 < 91))))):
            if (this1 > 96):
                return (this1 < 123)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiAlphanumeric(this1):
        if (not ((((this1 > 64) and ((this1 < 91))) or (((this1 > 96) and ((this1 < 123))))))):
            if (this1 > 47):
                return (this1 < 58)
            else:
                return False
        else:
            return True

    @staticmethod
    def isAsciiControl(this1):
        if (not (((this1 > -1) and ((this1 < 32))))):
            return (this1 == 127)
        else:
            return True

    @staticmethod
    def isAsciiPrintable(this1):
        if (this1 > 31):
            return (this1 < 127)
        else:
            return False

    @staticmethod
    def isDigit(this1):
        if (this1 > 47):
            return (this1 < 58)
        else:
            return False

    @staticmethod
    def isEOF(this1):
        return (this1 == -1)

    @staticmethod
    def isSpace(this1):
        return (this1 == 32)

    @staticmethod
    def isUTF8(this1):
        if (this1 > -1):
            return (this1 < 1114112)
        else:
            return False

    @staticmethod
    def isWhitespace(this1):
        if (not (((this1 > 8) and ((this1 < 14))))):
            return (this1 == 32)
        else:
            return True

    @staticmethod
    def isLowerCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h)

    @staticmethod
    def isUpperCase(this1):
        return (this1 in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)

    @staticmethod
    def toLowerCase(this1):
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        if (lowerChar is None):
            return this1
        else:
            return lowerChar

    @staticmethod
    def toUpperCase(this1):
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        if (upperChar is None):
            return this1
        else:
            return upperChar

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        return "".join(map(chr,[this1]))


class hx_strings_CharIterator:
    _hx_class_name = "hx.strings.CharIterator"
    __slots__ = ("index", "line", "col", "currChar", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx")
    _hx_fields = ["index", "line", "col", "currChar", "prevBuffer", "prevBufferPrevIdx", "prevBufferNextIdx"]
    _hx_methods = ["get_current", "get_pos", "hasPrev", "prev", "hasNext", "next", "getChar", "isEOF"]
    _hx_statics = ["fromString", "fromArray", "fromInput", "fromIterator"]

    def __init__(self,prevBufferSize):
        self.prevBufferNextIdx = -1
        self.prevBufferPrevIdx = -1
        self.currChar = -1
        self.col = 0
        self.line = 0
        self.index = -1
        self.prevBuffer = (hx_strings_internal__RingBuffer_RingBufferImpl((prevBufferSize + 1)) if ((prevBufferSize > 0)) else None)

    def get_current(self):
        if (self.index > -1):
            return self.currChar
        else:
            return None

    def get_pos(self):
        return hx_strings_CharPos(self.index,self.line,self.col)

    def hasPrev(self):
        return (self.prevBufferPrevIdx > -1)

    def prev(self):
        if (self.prevBufferPrevIdx <= -1):
            raise haxe_Exception.thrown(haxe_io_Eof())
        prevChar = self.prevBuffer.get(self.prevBufferPrevIdx)
        self.currChar = prevChar.char
        self.index = prevChar.index
        self.line = prevChar.line
        self.col = prevChar.col
        self.prevBufferNextIdx = ((self.prevBufferPrevIdx + 1) if (((self.prevBufferPrevIdx + 1) < self.prevBuffer.length)) else -1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.prevBufferPrevIdx
        _hx_local_0.prevBufferPrevIdx = (_hx_local_1 - 1)
        _hx_local_1
        return self.currChar

    def hasNext(self):
        if (self.prevBufferNextIdx > -1):
            return True
        else:
            return (not self.isEOF())

    def next(self):
        if (self.prevBufferNextIdx > -1):
            prevChar = self.prevBuffer.get(self.prevBufferNextIdx)
            self.currChar = prevChar.char
            self.index = prevChar.index
            self.line = prevChar.line
            self.col = prevChar.col
            self.prevBufferPrevIdx = (self.prevBufferNextIdx - 1)
            self.prevBufferNextIdx = ((self.prevBufferNextIdx + 1) if (((self.prevBufferNextIdx + 1) < self.prevBuffer.length)) else -1)
            return self.currChar
        if self.isEOF():
            raise haxe_Exception.thrown(haxe_io_Eof())
        if ((self.currChar == 10) or ((self.currChar < 0))):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.line
            _hx_local_0.line = (_hx_local_1 + 1)
            _hx_local_1
            self.col = 0
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.index
        _hx_local_2.index = (_hx_local_3 + 1)
        _hx_local_3
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.col
        _hx_local_4.col = (_hx_local_5 + 1)
        _hx_local_5
        self.currChar = self.getChar()
        if (self.prevBuffer is not None):
            self.prevBuffer.add(hx_strings__CharIterator_CharWithPos(self.currChar,self.index,self.col,self.line))
            self.prevBufferPrevIdx = (self.prevBuffer.length - 2)
            self.prevBufferNextIdx = -1
        return self.currChar

    def getChar(self):
        raise haxe_Exception.thrown("Not implemented")

    def isEOF(self):
        raise haxe_Exception.thrown("Not implemented")

    @staticmethod
    def fromString(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_StringCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromArray(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_ArrayCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromInput(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_InputCharIterator(chars,prevBufferSize)

    @staticmethod
    def fromIterator(chars,prevBufferSize = None):
        if (prevBufferSize is None):
            prevBufferSize = 0
        if (chars is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        return hx_strings__CharIterator_IteratorCharIterator(chars,prevBufferSize)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None
        _hx_o.currChar = None
        _hx_o.prevBuffer = None
        _hx_o.prevBufferPrevIdx = None
        _hx_o.prevBufferNextIdx = None


class hx_strings_CharPos:
    _hx_class_name = "hx.strings.CharPos"
    __slots__ = ("index", "line", "col")
    _hx_fields = ["index", "line", "col"]
    _hx_methods = ["toString"]

    def __init__(self,index,line,col):
        self.index = index
        self.line = line
        self.col = col

    def toString(self):
        return (((((("CharPos[index=" + Std.string(self.index)) + ", line=") + Std.string(self.line)) + ", col=") + Std.string(self.col)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.line = None
        _hx_o.col = None


class hx_strings__CharIterator_CharWithPos(hx_strings_CharPos):
    _hx_class_name = "hx.strings._CharIterator.CharWithPos"
    __slots__ = ("char",)
    _hx_fields = ["char"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharPos


    def __init__(self,char,index,line,col):
        self.char = None
        super().__init__(index,line,col)
        self.char = char

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.char = None


class hx_strings_internal__RingBuffer_RingBufferImpl:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferImpl"
    __slots__ = ("buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size")
    _hx_fields = ["buffer", "bufferStartIdx", "bufferEndIdx", "bufferMaxIdx", "length", "size"]
    _hx_methods = ["add", "get", "iterator", "toArray"]

    def __init__(self,size):
        self.length = 0
        self.bufferEndIdx = -1
        self.bufferStartIdx = 0
        if (size < 1):
            raise haxe_Exception.thrown("[size] must be > 0")
        self.buffer = ([None]*size)
        self.size = size
        self.bufferMaxIdx = (size - 1)

    def add(self,item):
        if (self.length == self.size):
            self.bufferEndIdx = self.bufferStartIdx
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bufferStartIdx
            _hx_local_0.bufferStartIdx = (_hx_local_1 + 1)
            _hx_local_1
            if (self.bufferStartIdx > self.bufferMaxIdx):
                self.bufferStartIdx = 0
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufferEndIdx
            _hx_local_2.bufferEndIdx = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.length
            _hx_local_4.length = (_hx_local_5 + 1)
            _hx_local_5
        self.buffer[self.bufferEndIdx] = item

    def get(self,index):
        if ((index < 0) or ((index > self.bufferMaxIdx))):
            raise haxe_Exception.thrown((("[index] " + Std.string(index)) + " is out of bound"))
        realIdx = (self.bufferStartIdx + index)
        if (realIdx > self.bufferMaxIdx):
            realIdx = (realIdx - self.length)
        return self.buffer[realIdx]

    def iterator(self):
        return hx_strings_internal__RingBuffer_RingBufferIterator(self)

    def toArray(self):
        arr = list()
        i = self.iterator()
        while i.hasNext():
            i1 = i.next()
            arr.append(i1)
        return arr

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.bufferStartIdx = None
        _hx_o.bufferEndIdx = None
        _hx_o.bufferMaxIdx = None
        _hx_o.length = None
        _hx_o.size = None


class hx_strings__CharIterator_NullCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.NullCharIterator"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["isEOF"]
    _hx_statics = ["INSTANCE"]
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self):
        super().__init__(0)

    def isEOF(self):
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class hx_strings__CharIterator_ArrayCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.ArrayCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (len(chars) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return python_internal_ArrayImpl._get(self.chars, self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None


class hx_strings__CharIterator_IteratorCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.IteratorCharIterator"
    __slots__ = ("chars",)
    _hx_fields = ["chars"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars

    def isEOF(self):
        return (not self.chars.hasNext())

    def getChar(self):
        return self.chars.next()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None


class hx_strings__CharIterator_InputCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.InputCharIterator"
    __slots__ = ("byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable")
    _hx_fields = ["byteIndex", "input", "currCharIndex", "nextChar", "nextCharAvailable"]
    _hx_methods = ["isEOF", "getChar", "readUtf8Char", "readUtf8MultiSequenceByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.input = None
        self.nextCharAvailable = None
        self.nextChar = -1
        self.currCharIndex = -1
        self.byteIndex = 0
        super().__init__(prevBufferSize)
        self.input = chars

    def isEOF(self):
        if (self.nextCharAvailable == None):
            try:
                byte1 = self.input.readByte()
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.byteIndex
                _hx_local_0.byteIndex = (_hx_local_1 + 1)
                _hx_local_1
                tmp = None
                if (byte1 <= 127):
                    tmp = byte1
                else:
                    byte1 = (byte1 & -129)
                    byte1 = (byte1 & -65)
                    totalBytes = 2
                    isBit6Set = (1 == (((byte1 >> 5) & 1)))
                    isBit5Set = False
                    if isBit6Set:
                        byte1 = (byte1 & -33)
                        totalBytes = (totalBytes + 1)
                        isBit5Set = (1 == (((byte1 >> 4) & 1)))
                        if isBit5Set:
                            byte1 = (byte1 & -17)
                            totalBytes = (totalBytes + 1)
                            if (1 == (((byte1 >> 3) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
                    result = (byte1 << ((6 * ((totalBytes - 1)))))
                    byte = self.input.readByte()
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.byteIndex
                    _hx_local_8.byteIndex = (_hx_local_9 + 1)
                    _hx_local_9
                    if (1 != (((byte >> 7) & 1))):
                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    if (1 == (((byte >> 6) & 1))):
                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                    byte2 = (byte & -129)
                    result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
                    if isBit6Set:
                        byte = self.input.readByte()
                        _hx_local_11 = self
                        _hx_local_12 = _hx_local_11.byteIndex
                        _hx_local_11.byteIndex = (_hx_local_12 + 1)
                        _hx_local_12
                        if (1 != (((byte >> 7) & 1))):
                            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                        if (1 == (((byte >> 6) & 1))):
                            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                        byte3 = (byte & -129)
                        result = (result + ((byte3 << ((6 * ((totalBytes - 3)))))))
                        if isBit5Set:
                            byte = self.input.readByte()
                            _hx_local_14 = self
                            _hx_local_15 = _hx_local_14.byteIndex
                            _hx_local_14.byteIndex = (_hx_local_15 + 1)
                            _hx_local_15
                            if (1 != (((byte >> 7) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            if (1 == (((byte >> 6) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            byte4 = (byte & -129)
                            result = (result + ((byte4 << ((6 * ((totalBytes - 4)))))))
                    if ((self.index == 0) and ((result == 65279))):
                        byte1 = self.input.readByte()
                        _hx_local_17 = self
                        _hx_local_18 = _hx_local_17.byteIndex
                        _hx_local_17.byteIndex = (_hx_local_18 + 1)
                        _hx_local_18
                        if (byte1 <= 127):
                            tmp = byte1
                        else:
                            byte1 = (byte1 & -129)
                            byte1 = (byte1 & -65)
                            totalBytes = 2
                            isBit6Set = (1 == (((byte1 >> 5) & 1)))
                            isBit5Set = False
                            if isBit6Set:
                                byte1 = (byte1 & -33)
                                totalBytes = (totalBytes + 1)
                                isBit5Set = (1 == (((byte1 >> 4) & 1)))
                                if isBit5Set:
                                    byte1 = (byte1 & -17)
                                    totalBytes = (totalBytes + 1)
                                    if (1 == (((byte1 >> 3) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
                            result1 = (byte1 << ((6 * ((totalBytes - 1)))))
                            byte = self.input.readByte()
                            _hx_local_25 = self
                            _hx_local_26 = _hx_local_25.byteIndex
                            _hx_local_25.byteIndex = (_hx_local_26 + 1)
                            _hx_local_26
                            if (1 != (((byte >> 7) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            if (1 == (((byte >> 6) & 1))):
                                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                            byte2 = (byte & -129)
                            result1 = (result1 + ((byte2 << ((6 * ((totalBytes - 2)))))))
                            if isBit6Set:
                                byte = self.input.readByte()
                                _hx_local_28 = self
                                _hx_local_29 = _hx_local_28.byteIndex
                                _hx_local_28.byteIndex = (_hx_local_29 + 1)
                                _hx_local_29
                                if (1 != (((byte >> 7) & 1))):
                                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                if (1 == (((byte >> 6) & 1))):
                                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                byte3 = (byte & -129)
                                result1 = (result1 + ((byte3 << ((6 * ((totalBytes - 3)))))))
                                if isBit5Set:
                                    byte = self.input.readByte()
                                    _hx_local_31 = self
                                    _hx_local_32 = _hx_local_31.byteIndex
                                    _hx_local_31.byteIndex = (_hx_local_32 + 1)
                                    _hx_local_32
                                    if (1 != (((byte >> 7) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                    if (1 == (((byte >> 6) & 1))):
                                        raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                                    byte4 = (byte & -129)
                                    result1 = (result1 + ((byte4 << ((6 * ((totalBytes - 4)))))))
                            tmp = (self.readUtf8Char() if (((self.index == 0) and ((result1 == 65279)))) else result1)
                    else:
                        tmp = result
                self.nextChar = tmp
                self.nextCharAvailable = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof):
                    self.nextCharAvailable = False
                else:
                    raise _g
        return (self.nextCharAvailable != True)

    def getChar(self):
        if (self.index != self.currCharIndex):
            self.currCharIndex = self.index
            self.nextCharAvailable = None
            return self.nextChar
        return self.currChar

    def readUtf8Char(self):
        byte1 = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (byte1 <= 127):
            return byte1
        byte1 = (byte1 & -129)
        byte1 = (byte1 & -65)
        totalBytes = 2
        isBit6Set = (1 == (((byte1 >> 5) & 1)))
        isBit5Set = False
        if isBit6Set:
            byte1 = (byte1 & -33)
            totalBytes = (totalBytes + 1)
            isBit5Set = (1 == (((byte1 >> 4) & 1)))
            if isBit5Set:
                byte1 = (byte1 & -17)
                totalBytes = (totalBytes + 1)
                if (1 == (((byte1 >> 3) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte1)) + "]!"))
        result = (byte1 << ((6 * ((totalBytes - 1)))))
        byte = self.input.readByte()
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.byteIndex
        _hx_local_8.byteIndex = (_hx_local_9 + 1)
        _hx_local_9
        if (1 != (((byte >> 7) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        byte2 = (byte & -129)
        result = (result + ((byte2 << ((6 * ((totalBytes - 2)))))))
        if isBit6Set:
            byte = self.input.readByte()
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.byteIndex
            _hx_local_11.byteIndex = (_hx_local_12 + 1)
            _hx_local_12
            if (1 != (((byte >> 7) & 1))):
                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
            if (1 == (((byte >> 6) & 1))):
                raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
            byte3 = (byte & -129)
            result = (result + ((byte3 << ((6 * ((totalBytes - 3)))))))
            if isBit5Set:
                byte = self.input.readByte()
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.byteIndex
                _hx_local_14.byteIndex = (_hx_local_15 + 1)
                _hx_local_15
                if (1 != (((byte >> 7) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                if (1 == (((byte >> 6) & 1))):
                    raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
                byte4 = (byte & -129)
                result = (result + ((byte4 << ((6 * ((totalBytes - 4)))))))
        if ((self.index == 0) and ((result == 65279))):
            return self.readUtf8Char()
        return result

    def readUtf8MultiSequenceByte(self):
        byte = self.input.readByte()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.byteIndex
        _hx_local_0.byteIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (1 != (((byte >> 7) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        if (1 == (((byte >> 6) & 1))):
            raise haxe_Exception.thrown((((("Valid UTF-8 multi-sequence byte expected at position [" + Std.string(self.byteIndex)) + "] but found byte with value [") + Std.string(byte)) + "]!"))
        return (byte & -129)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.byteIndex = None
        _hx_o.input = None
        _hx_o.currCharIndex = None
        _hx_o.nextChar = None
        _hx_o.nextCharAvailable = None


class hx_strings__CharIterator_StringCharIterator(hx_strings_CharIterator):
    _hx_class_name = "hx.strings._CharIterator.StringCharIterator"
    __slots__ = ("chars", "charsMaxIndex")
    _hx_fields = ["chars", "charsMaxIndex"]
    _hx_methods = ["isEOF", "getChar"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hx_strings_CharIterator


    def __init__(self,chars,prevBufferSize):
        self.charsMaxIndex = None
        self.chars = None
        super().__init__(prevBufferSize)
        self.chars = chars
        self.charsMaxIndex = (((0 if ((chars is None)) else len(chars))) - 1)

    def isEOF(self):
        return (self.index >= self.charsMaxIndex)

    def getChar(self):
        return HxString.charCodeAt(self.chars,self.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.chars = None
        _hx_o.charsMaxIndex = None


class hx_strings_Pattern:
    _hx_class_name = "hx.strings.Pattern"
    __slots__ = ("pattern", "options", "ereg")
    _hx_fields = ["pattern", "options", "ereg"]
    _hx_methods = ["matcher", "replace", "remove", "split"]
    _hx_statics = ["__meta__", "compile"]

    def __init__(self,pattern,options):
        self.pattern = pattern
        self.options = options
        self.ereg = EReg(pattern,options)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.options
        _hx_local_0.options = (("null" if _hx_local_1 is None else _hx_local_1) + "u")
        _hx_local_0.options

    def matcher(self,_hx_str):
        return hx_strings__Pattern_MatcherImpl(self.ereg,self.pattern,self.options,_hx_str)

    def replace(self,_hx_str,replaceWith):
        return self.ereg.replace(_hx_str,replaceWith)

    def remove(self,_hx_str):
        return self.ereg.replace(_hx_str,"")

    def split(self,_hx_str):
        return self.ereg.split(_hx_str)

    @staticmethod
    def compile(pattern,options = None):
        if (options is None):
            return hx_strings_Pattern(pattern,"")
        _g = options
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 0):
            _hx_str = _g.params[0]
            str1 = hx_strings_Strings.toLowerCase8(_hx_str)
            if ((str1 is None) or ((len(str1) == 0))):
                tmp = str1
            else:
                def _hx_local_0(ch):
                    return "".join(map(chr,[ch]))
                def _hx_local_1(ch):
                    if (not (((ch == hx_strings_Strings.charCodeAt8("i",0)) or ((ch == hx_strings_Strings.charCodeAt8("m",0)))))):
                        return (ch == hx_strings_Strings.charCodeAt8("g",0))
                    else:
                        return True
                _this = list(map(_hx_local_0,list(filter(_hx_local_1,hx_strings_Strings.toChars(str1)))))
                tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this])
        elif (tmp1 == 1):
            opt = _g.params[0]
            tmp = Std.string(opt)
        elif (tmp1 == 2):
            arr = _g.params[0]
            def _hx_local_2(m):
                return (m is not None)
            _this = list(filter(_hx_local_2,arr))
            tmp = "".join([python_Boot.toString1(x1,'') for x1 in _this])
        else:
            pass
        return hx_strings_Pattern(pattern,tmp)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.options = None
        _hx_o.ereg = None


class hx_strings_Matcher:
    _hx_class_name = "hx.strings.Matcher"
    __slots__ = ()
    _hx_methods = ["iterate", "map", "matched", "matchedPos", "matches", "matchesInRegion", "reset", "substringAfterMatch", "substringBeforeMatch"]
    _hx_statics = ["__meta__"]


class hx_strings__Pattern_MatcherImpl:
    _hx_class_name = "hx.strings._Pattern.MatcherImpl"
    __slots__ = ("ereg", "isMatch", "str")
    _hx_fields = ["ereg", "isMatch", "str"]
    _hx_methods = ["reset", "iterate", "map", "matched", "matches", "matchesInRegion", "matchedPos", "substringAfterMatch", "substringBeforeMatch", "_cloneEReg"]
    _hx_interfaces = [hx_strings_Matcher]

    def __init__(self,ereg,pattern,options,_hx_str):
        self.isMatch = None
        clone = Type.createEmptyInstance(EReg)
        value = Reflect.field(ereg,"pattern")
        setattr(clone,(("_hx_" + "pattern") if (("pattern" in python_Boot.keywords)) else (("_hx_" + "pattern") if (((((len("pattern") > 2) and ((ord("pattern"[0]) == 95))) and ((ord("pattern"[1]) == 95))) and ((ord("pattern"[(len("pattern") - 1)]) != 95)))) else "pattern")),value)
        value = Reflect.field(ereg,"global")
        setattr(clone,(("_hx_" + "global") if (("global" in python_Boot.keywords)) else (("_hx_" + "global") if (((((len("global") > 2) and ((ord("global"[0]) == 95))) and ((ord("global"[1]) == 95))) and ((ord("global"[(len("global") - 1)]) != 95)))) else "global")),value)
        self.ereg = clone
        self.str = _hx_str

    def reset(self,_hx_str):
        self.str = _hx_str
        self.isMatch = None
        return self

    def iterate(self,onMatch):
        startAt = 0
        while self.ereg.matchSub(self.str,startAt):
            self.isMatch = True
            _this = self.ereg
            matchedPos_pos = _this.matchObj.start()
            matchedPos_len = (_this.matchObj.end() - _this.matchObj.start())
            onMatch(self)
            startAt = (matchedPos_pos + matchedPos_len)
        self.isMatch = False

    def map(self,mapper):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(ereg):
                _gthis.isMatch = True
                return mapper(_gthis)
            return self.ereg.map(self.str,_hx_local_0)
        return _hx_local_1()

    def matched(self,n = None):
        if (n is None):
            n = 0
        if (not self.matches()):
            raise haxe_Exception.thrown("No string matched")
        result = self.ereg.matchObj.group(n)
        return result

    def matches(self):
        if (self.isMatch is None):
            _this = self.ereg
            _this.matchObj = python_lib_Re.search(_this.pattern,self.str)
            self.isMatch = (_this.matchObj is not None)
        return self.isMatch

    def matchesInRegion(self,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        def _hx_local_1():
            def _hx_local_0():
                self.isMatch = self.ereg.matchSub(self.str,pos,_hx_len)
                return self.isMatch
            return _hx_local_0()
        return _hx_local_1()

    def matchedPos(self):
        if (not self.matches()):
            raise haxe_Exception.thrown("No string matched")
        _this = self.ereg
        return _hx_AnonObject({'pos': _this.matchObj.start(), 'len': (_this.matchObj.end() - _this.matchObj.start())})

    def substringAfterMatch(self):
        if (not self.matches()):
            return ""
        _this = self.ereg
        return HxString.substr(_this.matchObj.string,_this.matchObj.end(),None)

    def substringBeforeMatch(self):
        if (not self.matches()):
            return ""
        _this = self.ereg
        return HxString.substr(_this.matchObj.string,0,_this.matchObj.start())

    def _cloneEReg(self,_hx_from,pattern,options):
        clone = Type.createEmptyInstance(EReg)
        value = Reflect.field(_hx_from,"pattern")
        setattr(clone,(("_hx_" + "pattern") if (("pattern" in python_Boot.keywords)) else (("_hx_" + "pattern") if (((((len("pattern") > 2) and ((ord("pattern"[0]) == 95))) and ((ord("pattern"[1]) == 95))) and ((ord("pattern"[(len("pattern") - 1)]) != 95)))) else "pattern")),value)
        value = Reflect.field(_hx_from,"global")
        setattr(clone,(("_hx_" + "global") if (("global" in python_Boot.keywords)) else (("_hx_" + "global") if (((((len("global") > 2) and ((ord("global"[0]) == 95))) and ((ord("global"[1]) == 95))) and ((ord("global"[(len("global") - 1)]) != 95)))) else "global")),value)
        return clone

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ereg = None
        _hx_o.isMatch = None
        _hx_o.str = None


class hx_strings__String8_String8_Impl_:
    _hx_class_name = "hx.strings._String8.String8_Impl_"
    __slots__ = ()
    _hx_statics = ["get_length"]
    length = None

    @staticmethod
    def get_length(this1):
        if (this1 is None):
            return 0
        else:
            return len(this1)


class hx_strings_StringBuilder:
    _hx_class_name = "hx.strings.StringBuilder"
    __slots__ = ("sb", "pre", "len")
    _hx_fields = ["sb", "pre", "len"]
    _hx_methods = ["get_length", "add", "addChar", "addAll", "clear", "isEmpty", "newLine", "insert", "insertChar", "insertAll", "asOutput", "toString"]
    _hx_statics = ["__meta__"]

    def __init__(self,initialContent = None):
        self.len = 0
        self.pre = None
        self.sb = StringBuf()
        if (initialContent is not None):
            self.add(initialContent)

    def get_length(self):
        return self.len

    def add(self,item):
        _this = self.sb
        s = Std.string(("null" if ((item is None)) else item))
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
        _hx_local_0.len
        return self

    def addChar(self,ch):
        _this = self.sb
        s = "".join(map(chr,[ch]))
        _this.b.write(s)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def addAll(self,items):
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 + (0 if ((item is None)) else len(item)))
            _hx_local_1.len
        return self

    def clear(self):
        self.pre = None
        self.sb = StringBuf()
        self.len = 0
        return self

    def isEmpty(self):
        return (self.len == 0)

    def newLine(self):
        self.sb.b.write("\n")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 + 1)
        _hx_local_1
        return self

    def insert(self,pos,item):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.add(item)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            self.pre.insert(0, item)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
            _hx_local_0.len
            return self
        pre_len = 0
        if (self.pre is not None):
            pre = self.pre
            i = len(pre)
            _g = 0
            _g1 = len(pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (pre[i] if i >= 0 and i < len(pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    pre.insert((i + 1), item)
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.len
                    _hx_local_2.len = (_hx_local_3 + (0 if ((item is None)) else len(item)))
                    _hx_local_2.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((pre[i] if i >= 0 and i < len(pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    pre.insert((i + 1), item)
                    pre.insert((i + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + (0 if ((item is None)) else len(item)))
                    _hx_local_4.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            self.add(item)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        _this = self.sb
        s = Std.string(item)
        _this.b.write(s)
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.len
        _hx_local_6.len = (_hx_local_7 + (0 if ((item is None)) else len(item)))
        _hx_local_6.len
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def insertChar(self,pos,ch):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addChar(ch)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            _this = self.pre
            x = "".join(map(chr,[ch]))
            _this.insert(0, x)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.len
            _hx_local_0.len = (_hx_local_1 + 1)
            _hx_local_1
            return self
        pre_len = 0
        if (self.pre is not None):
            pre = self.pre
            i = len(pre)
            _g = 0
            _g1 = len(pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (pre[i] if i >= 0 and i < len(pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    x = "".join(map(chr,[ch]))
                    pre.insert((i + 1), x)
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.len
                    _hx_local_2.len = (_hx_local_3 + 1)
                    _hx_local_3
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((pre[i] if i >= 0 and i < len(pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    x1 = "".join(map(chr,[ch]))
                    pre.insert((i + 1), x1)
                    pre.insert((i + 2), (preSplitted[1] if 1 < len(preSplitted) else None))
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.len
                    _hx_local_4.len = (_hx_local_5 + 1)
                    _hx_local_5
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            self.addChar(ch)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        self.addChar(ch)
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def insertAll(self,pos,items):
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must not be negative")
        if (pos > self.len):
            raise haxe_Exception.thrown("[pos] must not be greater than this.length")
        if (pos == self.len):
            self.addAll(items)
            return self
        if (pos == 0):
            if (self.pre is None):
                self.pre = []
            pre = self.pre
            i = len(items)
            while True:
                tmp = i
                i = (i - 1)
                if (not ((tmp > 0))):
                    break
                item = (items[i] if i >= 0 and i < len(items) else None)
                pre.insert(0, item)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.len
                _hx_local_0.len = (_hx_local_1 + (0 if ((item is None)) else len(item)))
                _hx_local_0.len
            return self
        pre_len = 0
        if (self.pre is not None):
            pre = self.pre
            i = len(pre)
            _g = 0
            _g1 = len(pre)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _hx_str = (pre[i] if i >= 0 and i < len(pre) else None)
                next_pre_len = (pre_len + ((0 if ((_hx_str is None)) else len(_hx_str))))
                if (next_pre_len == pos):
                    j = len(items)
                    while True:
                        tmp = j
                        j = (j - 1)
                        if (not ((tmp > 0))):
                            break
                        item = (items[j] if j >= 0 and j < len(items) else None)
                        pre.insert((i + 1), item)
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.len
                        _hx_local_2.len = (_hx_local_3 + (0 if ((item is None)) else len(item)))
                        _hx_local_2.len
                    return self
                if (next_pre_len > pos):
                    preSplitted = hx_strings_Strings.splitAt((pre[i] if i >= 0 and i < len(pre) else None),[(pos - pre_len)])
                    python_internal_ArrayImpl._set(pre, i, (preSplitted[0] if 0 < len(preSplitted) else None))
                    pre.insert((i + 1), (preSplitted[1] if 1 < len(preSplitted) else None))
                    j1 = len(items)
                    while True:
                        tmp1 = j1
                        j1 = (j1 - 1)
                        if (not ((tmp1 > 0))):
                            break
                        item1 = (items[j1] if j1 >= 0 and j1 < len(items) else None)
                        pre.insert((i + 1), item1)
                        _hx_local_4 = self
                        _hx_local_5 = _hx_local_4.len
                        _hx_local_4.len = (_hx_local_5 + (0 if ((item1 is None)) else len(item1)))
                        _hx_local_4.len
                    return self
                pre_len = next_pre_len
        if (self.sb.get_length() == 0):
            _g = 0
            while (_g < len(items)):
                item = (items[_g] if _g >= 0 and _g < len(items) else None)
                _g = (_g + 1)
                self.add(item)
            return self
        sbSplitted = hx_strings_Strings.splitAt(self.sb.b.getvalue(),[(pos - pre_len)])
        self.sb = StringBuf()
        _this = self.sb
        s = Std.string((sbSplitted[0] if 0 < len(sbSplitted) else None))
        _this.b.write(s)
        _g = 0
        while (_g < len(items)):
            item = (items[_g] if _g >= 0 and _g < len(items) else None)
            _g = (_g + 1)
            _this = self.sb
            s = Std.string(item)
            _this.b.write(s)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.len
            _hx_local_8.len = (_hx_local_9 + (0 if ((item is None)) else len(item)))
            _hx_local_8.len
        _this = self.sb
        s = Std.string((sbSplitted[1] if 1 < len(sbSplitted) else None))
        _this.b.write(s)
        return self

    def asOutput(self):
        return hx_strings__StringBuilder_OutputWrapper(self)

    def toString(self):
        if (self.pre is None):
            return self.sb.b.getvalue()
        _this = self.pre
        _hx_str = (HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _this])) + HxOverrides.stringOrNull(self.sb.b.getvalue()))
        self.clear()
        self.add(_hx_str)
        return _hx_str

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.pre = None
        _hx_o.len = None


class hx_strings__StringBuilder_OutputWrapper(haxe_io_Output):
    _hx_class_name = "hx.strings._StringBuilder.OutputWrapper"
    __slots__ = ("sb", "bo")
    _hx_fields = ["sb", "bo"]
    _hx_methods = ["flush", "writeByte", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,sb):
        self.bo = None
        self.sb = sb

    def flush(self):
        if ((self.bo is not None) and ((len(self.bo.b.b) > 0))):
            self.sb.add(self.bo.getBytes().toString())

    def writeByte(self,c):
        if (self.bo is None):
            self.bo = haxe_io_BytesOutput()
        self.bo.writeByte(c)

    def writeString(self,_hx_str,encoding = None):
        self.flush()
        self.sb.add(_hx_str)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sb = None
        _hx_o.bo = None


class hx_strings_internal_OS:
    _hx_class_name = "hx.strings.internal.OS"
    __slots__ = ()
    _hx_statics = ["isWindows"]


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field1) if (hasattr(o,field1)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name

class hx_strings_internal__Either3__Either3(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either3._Either3"
    _hx_constructs = ["a", "b", "c"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either3__Either3("a", 0, (v,))

    @staticmethod
    def b(v):
        return hx_strings_internal__Either3__Either3("b", 1, (v,))

    @staticmethod
    def c(v):
        return hx_strings_internal__Either3__Either3("c", 2, (v,))


class hx_strings_Strings:
    _hx_class_name = "hx.strings.Strings"
    __slots__ = ()
    _hx_statics = ["REGEX_ANSI_ESC", "REGEX_HTML_UNESCAPE", "REGEX_SPLIT_LINES", "REGEX_REMOVE_XML_TAGS", "POS_NOT_FOUND", "NEW_LINE_NIX", "NEW_LINE_WIN", "NEW_LINE", "_length", "_getNotFoundDefault", "_charCodeAt8Unsafe", "_splitAsciiWordsUnsafe", "ansiToHtml", "appendIfMissing", "base64Encode", "base64Decode", "charAt8", "charCodeAt8", "compact", "contains", "containsOnly", "containsAll", "containsAllIgnoreCase", "containsAny", "containsAnyIgnoreCase", "containsNone", "containsNoneIgnoreCase", "containsWhitespaces", "countMatches", "countMatchesIgnoreCase", "compare", "compareIgnoreCase", "diff", "diffAt", "ellipsizeLeft", "ellipsizeMiddle", "ellipsizeRight", "endsWith", "endsWithAny", "endsWithAnyIgnoreCase", "endsWithIgnoreCase", "equals", "equalsIgnoreCase", "filter", "filterChars", "getFuzzyDistance", "getLevenshteinDistance", "getLongestCommonSubstring", "hashCode", "htmlDecode", "htmlEncode", "insertAt", "ifBlank", "ifEmpty", "ifNull", "indentLines", "indexOf8", "isBlank", "isDigits", "isEmpty", "isNotBlank", "isNotEmpty", "isLowerCase", "isUpperCase", "iterate", "iterateChars", "lastIndexOf8", "length8", "left", "lpad", "map", "prependIfMissing", "quoteDouble", "quoteSingle", "removeAfter", "removeAfterLast", "removeAfterIgnoreCase", "removeAfterLastIgnoreCase", "removeAt", "removeBefore", "removeBeforeLast", "removeBeforeIgnoreCase", "removeBeforeLastIgnoreCase", "removeAll", "removeFirst", "removeFirstIgnoreCase", "removeAnsi", "removeLeading", "removeTags", "removeTrailing", "repeat", "replaceAll", "replaceFirst", "replaceFirstIgnoreCase", "reverse", "right", "rpad", "split8", "splitAt", "splitEvery", "splitLines", "startsWith", "startsWithAny", "startsWithAnyIgnoreCase", "startsWithIgnoreCase", "substr8", "substring8", "substringAfter", "substringAfterIgnoreCase", "substringBetween", "substringBetweenIgnoreCase", "substringAfterLast", "substringAfterLastIgnoreCase", "substringBefore", "substringBeforeIgnoreCase", "substringBeforeLast", "substringBeforeLastIgnoreCase", "toBool", "toBytes", "toChar", "toCharIterator", "toChars", "toPattern", "toEReg", "toFloat", "toFloatOrNull", "toHex", "toInt", "toIntOrNull", "toLowerCase8", "toLowerCaseFirstChar", "toLowerCamel", "toLowerHyphen", "toLowerUnderscore", "toTitle", "toUpperCamel", "toUpperUnderscore", "toString", "toUpperCase8", "toUpperCaseFirstChar", "trim", "trimRight", "trimLeft", "trimLines", "trimToNull", "trimToEmpty", "truncate", "urlDecode", "urlEncode", "wrap"]

    @staticmethod
    def _length(_hx_str):
        return len(_hx_str)

    @staticmethod
    def _getNotFoundDefault(_hx_str,notFoundDefault):
        notFoundDefault1 = notFoundDefault
        if (notFoundDefault1 == 1):
            return None
        elif (notFoundDefault1 == 2):
            return ""
        elif (notFoundDefault1 == 3):
            return _hx_str
        else:
            pass

    @staticmethod
    def _charCodeAt8Unsafe(_hx_str,pos):
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def _splitAsciiWordsUnsafe(_hx_str):
        words = list()
        currentWord = hx_strings_StringBuilder()
        chars = hx_strings_Strings.toChars(_hx_str)
        _hx_len = len(chars)
        lastIndex = (_hx_len - 1)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = (chars[i] if i >= 0 and i < len(chars) else None)
            if (((ch > 64) and ((ch < 91))) or (((ch > 96) and ((ch < 123))))):
                chNext = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                currentWord.addChar(ch)
                if ((chNext > 47) and ((chNext < 58))):
                    x = currentWord.toString()
                    words.append(x)
                    currentWord.clear()
                elif (ch in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    if ((chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h) and ((len(chars) > ((i + 2))))):
                        if (not (python_internal_ArrayImpl._get(chars, (i + 2)) in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h)):
                            x1 = currentWord.toString()
                            words.append(x1)
                            currentWord.clear()
                elif (chNext in hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h):
                    x2 = currentWord.toString()
                    words.append(x2)
                    currentWord.clear()
            elif ((ch > 47) and ((ch < 58))):
                currentWord.addChar(ch)
                chNext1 = (python_internal_ArrayImpl._get(chars, (i + 1)) if ((i < lastIndex)) else -1)
                if (not (((chNext1 > 47) and ((chNext1 < 58))))):
                    x3 = currentWord.toString()
                    words.append(x3)
                    currentWord.clear()
            elif (currentWord.len > 0):
                x4 = currentWord.toString()
                words.append(x4)
                currentWord.clear()
        if (currentWord.len > 0):
            x = currentWord.toString()
            words.append(x)
        return words

    @staticmethod
    def ansiToHtml(_hx_str,renderMethod = None,initialState = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (renderMethod is None):
            renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
        styleOrClassAttribute = None
        styleOrClassAttribute1 = renderMethod.index
        if (styleOrClassAttribute1 == 0):
            styleOrClassAttribute = "style"
        elif (styleOrClassAttribute1 == 1):
            styleOrClassAttribute = "class"
        elif (styleOrClassAttribute1 == 2):
            cb = renderMethod.params[0]
            styleOrClassAttribute = "class"
        else:
            pass
        sb = hx_strings_StringBuilder()
        if ((initialState is not None) and ((((((initialState.fgcolor is not None) or ((initialState.bgcolor is not None))) or initialState.bold) or initialState.underline) or initialState.blink))):
            sb.add((("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")).add(initialState.toCSS(renderMethod)).add("\">")
        effectiveState = hx_strings_AnsiState(initialState)
        strLenMinus1 = (((0 if ((_hx_str is None)) else len(_hx_str))) - 1)
        i = -1
        lookAhead = hx_strings_StringBuilder()
        while (i < strLenMinus1):
            i = (i + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            if (((ch == 27) and ((i < strLenMinus1))) and ((HxString.charCodeAt(_hx_str,(i + 1)) == 91))):
                lookAhead.clear()
                currentState = hx_strings_AnsiState(effectiveState)
                currentGraphicModeParam = 0
                isValidEscapeSequence = False
                i = (i + 1)
                while (i < strLenMinus1):
                    i = (i + 1)
                    ch2 = HxString.charCodeAt(_hx_str,i)
                    lookAhead.addChar(ch2)
                    ch21 = ch2
                    if (ch21 == 48):
                        currentGraphicModeParam = (currentGraphicModeParam * 10)
                    elif (ch21 == 49):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 1)
                    elif (ch21 == 50):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 2)
                    elif (ch21 == 51):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 3)
                    elif (ch21 == 52):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 4)
                    elif (ch21 == 53):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 5)
                    elif (ch21 == 54):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 6)
                    elif (ch21 == 55):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 7)
                    elif (ch21 == 56):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 8)
                    elif (ch21 == 57):
                        currentGraphicModeParam = ((currentGraphicModeParam * 10) + 9)
                    elif (ch21 == 59):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        currentGraphicModeParam = 0
                    elif (ch21 == 109):
                        currentState.setGraphicModeParameter(currentGraphicModeParam)
                        if (((((effectiveState.fgcolor is not None) or ((effectiveState.bgcolor is not None))) or effectiveState.bold) or effectiveState.underline) or effectiveState.blink):
                            sb.add("</span>")
                        if (((((currentState.fgcolor is not None) or ((currentState.bgcolor is not None))) or currentState.bold) or currentState.underline) or currentState.blink):
                            sb.add((("<span " + ("null" if styleOrClassAttribute is None else styleOrClassAttribute)) + "=\"")).add(currentState.toCSS(renderMethod)).add("\">")
                        effectiveState = currentState
                        isValidEscapeSequence = True
                        break
                    else:
                        break
                if (not isValidEscapeSequence):
                    sb.addChar(27).add("[").add(Std.string(lookAhead))
            else:
                sb.addChar(ch)
        if (((((effectiveState.fgcolor is not None) or ((effectiveState.bgcolor is not None))) or effectiveState.bold) or effectiveState.underline) or effectiveState.blink):
            sb.add("</span>")
        return sb.toString()

    @staticmethod
    def appendIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (Std.string(_hx_str) + Std.string(suffix))
        if hx_strings_Strings.endsWith(_hx_str,suffix):
            return _hx_str
        return (Std.string(_hx_str) + Std.string(suffix))

    @staticmethod
    def base64Encode(plain):
        if (plain is None):
            return None
        return haxe_crypto_Base64.encode((None if ((plain is None)) else haxe_io_Bytes.ofString(plain)))

    @staticmethod
    def base64Decode(encoded):
        if (encoded is None):
            return None
        return haxe_crypto_Base64.decode(encoded).toString()

    @staticmethod
    def charAt8(_hx_str,pos,resultIfOutOfBound = None):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = ""
        if ((((_hx_str is None) or ((len(_hx_str) == 0))) or ((pos < 0))) or ((pos >= ((0 if ((_hx_str is None)) else len(_hx_str)))))):
            return resultIfOutOfBound
        return ("" if (((pos < 0) or ((pos >= len(_hx_str))))) else _hx_str[pos])

    @staticmethod
    def charCodeAt8(_hx_str,pos,resultIfOutOfBound = None):
        if (resultIfOutOfBound is None):
            resultIfOutOfBound = -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (((strLen == 0) or ((pos < 0))) or ((pos >= strLen))):
            return resultIfOutOfBound
        return HxString.charCodeAt(_hx_str,pos)

    @staticmethod
    def compact(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        needWhiteSpace = False
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            char = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((char > 8) and ((char < 14))) or ((char == 32))):
                if (sb.len != 0):
                    needWhiteSpace = True
                continue
            elif needWhiteSpace:
                sb.addChar(32)
                needWhiteSpace = False
            sb.addChar(char)
        return sb.toString()

    @staticmethod
    def contains(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if (searchFor == ""):
            return True
        startIndex = None
        return (((searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))) > -1)

    @staticmethod
    def containsOnly(searchIn,allowedChars):
        if ((searchIn is None) or ((len(searchIn) == 0))):
            return True
        if (allowedChars is None):
            return False
        allowedCharsArray = None
        _g = allowedChars
        allowedCharsArray1 = _g.index
        if (allowedCharsArray1 == 0):
            _hx_str = _g.params[0]
            allowedCharsArray = hx_strings_Strings.toChars(_hx_str)
        elif (allowedCharsArray1 == 1):
            chars = _g.params[0]
            allowedCharsArray = chars
        else:
            pass
        _g = 0
        _g1 = hx_strings_Strings.toChars(searchIn)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (python_internal_ArrayImpl.indexOf(allowedCharsArray,ch,None) < 0):
                return False
        return True

    @staticmethod
    def containsAll(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if ((searchIn is None) or ((candidate is None))):
                tmp = False
            elif (candidate == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(candidate) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,candidate,startIndex))) > -1)
            if (not tmp):
                return False
        return True

    @staticmethod
    def containsAllIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            tmp = None
            if ((searchIn is None) or ((searchFor1 is None))):
                tmp = False
            elif (searchFor1 == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(searchFor1) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor1,startIndex))) > -1)
            if (not tmp):
                return False
        return True

    @staticmethod
    def containsAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            tmp = None
            if ((searchIn is None) or ((candidate is None))):
                tmp = False
            elif (candidate == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(candidate) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,candidate,startIndex))) > -1)
            if tmp:
                return True
        return False

    @staticmethod
    def containsAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = searchIn.lower()
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            searchFor1 = candidate.lower()
            tmp = None
            if ((searchIn is None) or ((searchFor1 is None))):
                tmp = False
            elif (searchFor1 == ""):
                tmp = True
            else:
                startIndex = None
                tmp = (((searchIn.find(searchFor1) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor1,startIndex))) > -1)
            if tmp:
                return True
        return False

    @staticmethod
    def containsNone(searchIn,searchFor):
        return (not hx_strings_Strings.containsAny(searchIn,searchFor))

    @staticmethod
    def containsNoneIgnoreCase(searchIn,searchFor):
        return (not hx_strings_Strings.containsAnyIgnoreCase(searchIn,searchFor))

    @staticmethod
    def containsWhitespaces(searchIn):
        if (searchIn is None):
            return False
        _g = 0
        _g1 = hx_strings_Strings.toChars(searchIn)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or ((ch == 32))):
                return True
        return False

    @staticmethod
    def countMatches(searchIn,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def countMatchesIgnoreCase(searchIn,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))) or ((startAt >= len(searchIn)))):
            return 0
        if (startAt < 0):
            startAt = 0
        searchIn = searchIn.lower()
        searchFor = searchFor.lower()
        count = 0
        foundAt = ((startAt - 1) if ((startAt > -1)) else 0)
        while True:
            startIndex = (foundAt + 1)
            foundAt = (searchIn.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(searchIn,searchFor,startIndex))
            if (not ((foundAt > -1))):
                break
            count = (count + 1)
        return count

    @staticmethod
    def compare(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        if (_hx_str > other):
            return 1
        elif (_hx_str == other):
            return 0
        else:
            return -1

    @staticmethod
    def compareIgnoreCase(_hx_str,other):
        if (_hx_str is None):
            if (other is None):
                return 0
            else:
                return -1
        if (other is None):
            if (_hx_str is None):
                return 0
            else:
                return 1
        str1 = hx_strings_Strings.toLowerCase8(_hx_str)
        other1 = hx_strings_Strings.toLowerCase8(other)
        if (str1 > other1):
            return 1
        elif (str1 == other1):
            return 0
        else:
            return -1

    @staticmethod
    def diff(left,right):
        diff = hx_strings_StringDiff()
        diff.at = hx_strings_Strings.diffAt(left,right)
        diff.left = hx_strings_Strings.substr8(left,diff.at)
        diff.right = hx_strings_Strings.substr8(right,diff.at)
        return diff

    @staticmethod
    def diffAt(_hx_str,other):
        if (_hx_str == other):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        otherLen = (0 if ((other is None)) else len(other))
        if ((strLen == 0) or ((otherLen == 0))):
            return 0
        checkLen = (otherLen if ((strLen > otherLen)) else strLen)
        _g = 0
        _g1 = checkLen
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxString.charCodeAt(_hx_str,i) != HxString.charCodeAt(other,i)):
                return i
        return checkLen

    @staticmethod
    def ellipsizeLeft(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        return (("null" if ellipsis is None else ellipsis) + Std.string(hx_strings_Strings.right(_hx_str,(maxLength - ellipsisLen))))

    @staticmethod
    def ellipsizeMiddle(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        maxStrLen = (maxLength - ellipsisLen)
        leftLen = Math.floor(((maxStrLen / 2) + 0.5))
        rightLen = (maxStrLen - leftLen)
        return ((Std.string((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= leftLen)) else hx_strings_Strings.substring8(_hx_str,0,leftLen))) + ("null" if ellipsis is None else ellipsis)) + Std.string(hx_strings_Strings.right(_hx_str,rightLen)))

    @staticmethod
    def ellipsizeRight(_hx_str,maxLength,ellipsis = None):
        if (ellipsis is None):
            ellipsis = "..."
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        ellipsisLen = (0 if ((ellipsis is None)) else len(ellipsis))
        if (maxLength < ellipsisLen):
            raise haxe_Exception.thrown(("[maxLength] must not be smaller than " + Std.string(ellipsisLen)))
        _hx_len = (maxLength - ellipsisLen)
        return (Std.string((_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len)) else hx_strings_Strings.substring8(_hx_str,0,_hx_len))) + ("null" if ellipsis is None else ellipsis))

    @staticmethod
    def endsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        return searchIn.endswith(searchFor)

    @staticmethod
    def endsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.endsWith(searchIn,candidate)):
                return True
        return False

    @staticmethod
    def endsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.endsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))):
                return True
        return False

    @staticmethod
    def endsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        return hx_strings_Strings.endsWith(searchIn.lower(),searchFor.lower())

    @staticmethod
    def equals(_hx_str,other):
        return (_hx_str == other)

    @staticmethod
    def equalsIgnoreCase(_hx_str,other):
        return (hx_strings_Strings.toLowerCase8(_hx_str) == hx_strings_Strings.toLowerCase8(other))

    @staticmethod
    def filter(_hx_str,_hx_filter,separator = None):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = list(filter(_hx_filter,hx_strings_Strings.split8(_hx_str,[separator])))
        return separator.join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def filterChars(_hx_str,_hx_filter):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(ch):
            return "".join(map(chr,[ch]))
        _this = list(map(_hx_local_0,list(filter(_hx_filter,hx_strings_Strings.toChars(_hx_str)))))
        return "".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def getFuzzyDistance(left,right):
        if (((left is None) or ((len(left) == 0))) or (((right is None) or ((len(right) == 0))))):
            return 0
        left = hx_strings_Strings.toLowerCase8(left)
        right = hx_strings_Strings.toLowerCase8(right)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftLastMatchAt = -100
        rightLastMatchAt = -100
        score = 0
        _g = 0
        _g1 = len(leftChars)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            leftChar = (leftChars[leftIdx] if leftIdx >= 0 and leftIdx < len(leftChars) else None)
            _g2 = ((rightLastMatchAt + 1) if ((rightLastMatchAt > -1)) else 0)
            _g3 = len(rightChars)
            while (_g2 < _g3):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                rightChar = (rightChars[rightIdx] if rightIdx >= 0 and rightIdx < len(rightChars) else None)
                if (leftChar == rightChar):
                    score = (score + 1)
                    if ((leftLastMatchAt == ((leftIdx - 1))) and ((rightLastMatchAt == ((rightIdx - 1))))):
                        score = (score + 2)
                    leftLastMatchAt = leftIdx
                    rightLastMatchAt = rightIdx
                    break
        return score

    @staticmethod
    def getLevenshteinDistance(left,right):
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if (leftLen == 0):
            return rightLen
        if (rightLen == 0):
            return leftLen
        if (leftLen > rightLen):
            tmp = left
            left = right
            right = tmp
            tmpLen = leftLen
            leftLen = rightLen
            rightLen = tmpLen
        prevCosts = list()
        costs = list()
        _g = 0
        _g1 = (leftLen + 1)
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            prevCosts.append(leftIdx)
            costs.append(0)
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        def _hx_local_0(a,b):
            if (a > b):
                return b
            else:
                return a
        _hx_min = _hx_local_0
        _g = 1
        _g1 = (rightLen + 1)
        while (_g < _g1):
            rightIdx = _g
            _g = (_g + 1)
            rightChar = python_internal_ArrayImpl._get(rightChars, (rightIdx - 1))
            python_internal_ArrayImpl._set(costs, 0, rightIdx)
            _g2 = 1
            _g3 = (leftLen + 1)
            while (_g2 < _g3):
                leftIdx = _g2
                _g2 = (_g2 + 1)
                leftIdxMinus1 = (leftIdx - 1)
                cost = (0 if (((leftChars[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(leftChars) else None) == rightChar)) else 1)
                python_internal_ArrayImpl._set(costs, leftIdx, _hx_min(_hx_min(((costs[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(costs) else None) + 1),((prevCosts[leftIdx] if leftIdx >= 0 and leftIdx < len(prevCosts) else None) + 1)),((prevCosts[leftIdxMinus1] if leftIdxMinus1 >= 0 and leftIdxMinus1 < len(prevCosts) else None) + cost)))
            tmp = prevCosts
            prevCosts = costs
            costs = tmp
        return (prevCosts[leftLen] if leftLen >= 0 and leftLen < len(prevCosts) else None)

    @staticmethod
    def getLongestCommonSubstring(left,right):
        if ((left is None) or ((right is None))):
            return None
        leftLen = (0 if ((left is None)) else len(left))
        rightLen = (0 if ((right is None)) else len(right))
        if ((leftLen == 0) or ((rightLen == 0))):
            return ""
        leftChars = hx_strings_Strings.toChars(left)
        rightChars = hx_strings_Strings.toChars(right)
        leftSubStartAt = 0
        leftSubLen = 0
        _g = 0
        _g1 = leftLen
        while (_g < _g1):
            leftIdx = _g
            _g = (_g + 1)
            _g2 = 0
            _g3 = rightLen
            while (_g2 < _g3):
                rightIdx = _g2
                _g2 = (_g2 + 1)
                currLen = 0
                while (python_internal_ArrayImpl._get(leftChars, (leftIdx + currLen)) == python_internal_ArrayImpl._get(rightChars, (rightIdx + currLen))):
                    currLen = (currLen + 1)
                    if (((leftIdx + currLen) >= leftLen) or (((rightIdx + currLen) >= rightLen))):
                        break
                if (currLen > leftSubLen):
                    leftSubLen = currLen
                    leftSubStartAt = leftIdx
        return hx_strings_Strings.substr8(left,leftSubStartAt,leftSubLen)

    @staticmethod
    def hashCode(_hx_str,algo = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return 0
        if (algo is None):
            algo = hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC
        if (algo is None):
            return hash(_hx_str)
        else:
            tmp = algo.index
            if (tmp == 1):
                return haxe_crypto_Adler32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 2):
                return haxe_crypto_Crc32.make((None if ((_hx_str is None)) else haxe_io_Bytes.ofString(_hx_str)))
            elif (tmp == 3):
                hc = 5381
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = (((((((((((hc << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) ^ ch)) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            elif (tmp == 4):
                hc = 0
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = ((((((((((hc << 5)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            elif (tmp == 5):
                hc = 0
                _g = 0
                _g1 = hx_strings_Strings.toChars(_hx_str)
                while (_g < len(_g1)):
                    ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                    _g = (_g + 1)
                    hc = (((((((((((((hc << 6)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + (((((hc << 16)) + (2 ** 31)) % (2 ** 32) - (2 ** 31)))) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) - hc) + (2 ** 31)) % (2 ** 32) - (2 ** 31)) + ch) + (2 ** 31)) % (2 ** 32) - (2 ** 31))
                return hc
            else:
                return hash(_hx_str)

    @staticmethod
    def htmlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        _this = hx_strings_Strings.REGEX_HTML_UNESCAPE
        def _hx_local_2():
            def _hx_local_1(m):
                match = m.matched()
                match1 = match
                _hx_local_0 = len(match1)
                if (_hx_local_0 == 5):
                    if (match1 == "&amp;"):
                        return "&"
                    else:
                        number = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        if (number is None):
                            raise haxe_Exception.thrown(("Invalid HTML value " + ("null" if match is None else match)))
                        return "".join(map(chr,[number]))
                elif (_hx_local_0 == 4):
                    if (match1 == "&gt;"):
                        return ">"
                    elif (match1 == "&lt;"):
                        return "<"
                    else:
                        number = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        if (number is None):
                            raise haxe_Exception.thrown(("Invalid HTML value " + ("null" if match is None else match)))
                        return "".join(map(chr,[number]))
                elif (_hx_local_0 == 6):
                    if (match1 == "&apos;"):
                        return "'"
                    elif (match1 == "&nbsp;"):
                        return " "
                    elif (match1 == "&quot;"):
                        return "\""
                    else:
                        number = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                        if (number is None):
                            raise haxe_Exception.thrown(("Invalid HTML value " + ("null" if match is None else match)))
                        return "".join(map(chr,[number]))
                else:
                    number = Std.parseInt(hx_strings_Strings.substr8(match,2,(((0 if ((match is None)) else len(match))) - 3)))
                    if (number is None):
                        raise haxe_Exception.thrown(("Invalid HTML value " + ("null" if match is None else match)))
                    return "".join(map(chr,[number]))
            return hx_strings__Pattern_MatcherImpl(_this.ereg,_this.pattern,_this.options,_hx_str).map(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def htmlEncode(_hx_str,escapeQuotes = None):
        if (escapeQuotes is None):
            escapeQuotes = False
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        isFirstSpace = True
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            ch = HxString.charCodeAt(_hx_str,i)
            ch1 = ch
            if (ch1 == 32):
                if isFirstSpace:
                    sb.add(" ")
                    isFirstSpace = False
                else:
                    sb.add("&nbsp;")
            elif (ch1 == 34):
                sb.add(("&quot;" if escapeQuotes else "\""))
            elif (ch1 == 38):
                sb.add("&amp;")
            elif (ch1 == 39):
                sb.add(("&#039;" if escapeQuotes else "'"))
            elif (ch1 == 60):
                sb.add("&lt;")
            elif (ch1 == 62):
                sb.add("&gt;")
            elif (ch > 127):
                sb.add("&#").add(Std.string(ch)).add(";")
            else:
                sb.addChar(ch)
            if (ch != 32):
                isFirstSpace = True
        return sb.toString()

    @staticmethod
    def insertAt(_hx_str,pos,insertion):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (pos < 0):
            pos = (strLen + pos)
        if ((pos < 0) or ((pos > strLen))):
            raise haxe_Exception.thrown("Absolute value of [pos] must be <= str.length")
        if ((insertion is None) or ((len(insertion) == 0))):
            return _hx_str
        return ((Std.string(hx_strings_Strings.substring8(_hx_str,0,pos)) + Std.string(insertion)) + Std.string(hx_strings_Strings.substring8(_hx_str,pos)))

    @staticmethod
    def ifBlank(_hx_str,fallback):
        if (True if ((_hx_str is None)) else (len(StringTools.trim(_hx_str)) == 0)):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifEmpty(_hx_str,fallback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def ifNull(_hx_str,fallback):
        if (_hx_str is None):
            return fallback
        else:
            return _hx_str

    @staticmethod
    def indentLines(_hx_str,indentWith):
        if (_hx_str is None):
            return None
        if ((len(_hx_str) == 0) or (((indentWith is None) or ((len(indentWith) == 0))))):
            return _hx_str
        isFirstLine = True
        sb = hx_strings_StringBuilder()
        _g = 0
        _g1 = hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)
        while (_g < len(_g1)):
            line = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if isFirstLine:
                isFirstLine = False
            else:
                sb.newLine()
            sb.add(indentWith)
            sb.add(line)
        return sb.toString()

    @staticmethod
    def indexOf8(_hx_str,searchFor,startAt = None):
        if (startAt is None):
            startAt = 0
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt < 0):
            startAt = 0
        if (searchForLen == 0):
            if (startAt == 0):
                return 0
            if ((startAt > 0) and ((startAt < strLen))):
                return startAt
            return strLen
        if (startAt >= strLen):
            return -1
        if (startAt is None):
            return _hx_str.find(searchFor)
        else:
            return HxString.indexOfImpl(_hx_str,searchFor,startAt)

    @staticmethod
    def isBlank(_hx_str):
        if (_hx_str is None):
            return True
        else:
            return (len(StringTools.trim(_hx_str)) == 0)

    @staticmethod
    def isDigits(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = HxString.charCodeAt(_hx_str,i)
            if (not (((this1 > 47) and ((this1 < 58))))):
                return False
        return True

    @staticmethod
    def isEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) == 0)
        else:
            return True

    @staticmethod
    def isNotBlank(_hx_str):
        if (_hx_str is not None):
            return (len(StringTools.trim(_hx_str)) > 0)
        else:
            return False

    @staticmethod
    def isNotEmpty(_hx_str):
        if (_hx_str is not None):
            return (len(_hx_str) > 0)
        else:
            return False

    @staticmethod
    def isLowerCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toLowerCase8(_hx_str))

    @staticmethod
    def isUpperCase(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        return (_hx_str == hx_strings_Strings.toUpperCase8(_hx_str))

    @staticmethod
    def iterate(_hx_str,callback,separator = None):
        if (separator is None):
            separator = ""
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = hx_strings_Strings.split8(_hx_str,[separator])
        while (_g < len(_g1)):
            sub = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            callback(sub)

    @staticmethod
    def iterateChars(_hx_str,callback):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return
        _g = 0
        _g1 = (0 if ((_hx_str is None)) else len(_hx_str))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            callback(HxString.charCodeAt(_hx_str,i))

    @staticmethod
    def lastIndexOf8(_hx_str,searchFor,startAt = None):
        if ((_hx_str is None) or ((searchFor is None))):
            return -1
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        searchForLen = (0 if ((searchFor is None)) else len(searchFor))
        if (startAt is None):
            startAt = strLen
        if (searchForLen == 0):
            if (startAt < 0):
                return 0
            if (startAt > strLen):
                return strLen
            return startAt
        if (startAt < 0):
            return -1
        elif (startAt >= strLen):
            startAt = (strLen - 1)
        strNeedsUTF8Workaround = (len(_hx_str) != strLen)
        searchForNeedsUTF8Workaround = (len(searchFor) != searchForLen)
        if (searchForNeedsUTF8Workaround and (not strNeedsUTF8Workaround)):
            return -1
        searchForChars = hx_strings_Strings.toChars(searchFor)
        startAt = (startAt + ((searchForLen - 1)))
        searchForPosToCheck = (searchForLen - 1)
        strPos = strLen
        while True:
            tmp = strPos
            strPos = (strPos - 1)
            if (not ((tmp > 0))):
                break
            if (strPos > startAt):
                continue
            strCh = HxString.charCodeAt(_hx_str,strPos)
            if (strCh == (searchForChars[searchForPosToCheck] if searchForPosToCheck >= 0 and searchForPosToCheck < len(searchForChars) else None)):
                if (searchForPosToCheck == 0):
                    return strPos
                searchForPosToCheck = (searchForPosToCheck - 1)
            else:
                searchForPosToCheck = (searchForLen - 1)
        return -1

    @staticmethod
    def length8(_hx_str):
        if (_hx_str is None):
            return 0
        return len(_hx_str)

    @staticmethod
    def left(_hx_str,_hx_len):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= _hx_len):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,0,_hx_len)

    @staticmethod
    def lpad(_hx_str,targetLength,padStr = None,canOverflow = None):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        sb = [_hx_str]
        padLen = (0 if ((padStr is None)) else len(padStr))
        while (strLen < targetLength):
            sb.insert(0, padStr)
            strLen = (strLen + padLen)
        if canOverflow:
            return "".join([python_Boot.toString1(x1,'') for x1 in sb])
        return hx_strings_Strings.right("".join([python_Boot.toString1(x1,'') for x1 in sb]),targetLength)

    @staticmethod
    def map(_hx_str,mapper,separator = None):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (separator is None):
            raise haxe_Exception.thrown("[separator] must not be null")
        return list(map(mapper,hx_strings_Strings.split8(_hx_str,[separator])))

    @staticmethod
    def prependIfMissing(_hx_str,suffix):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return (("null" if suffix is None else suffix) + Std.string(_hx_str))
        if hx_strings_Strings.startsWith(_hx_str,suffix):
            return _hx_str
        return (("null" if suffix is None else suffix) + Std.string(_hx_str))

    @staticmethod
    def quoteDouble(_hx_str):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return "\"\""
        tmp = None
        if (_hx_str is None):
            tmp = False
        else:
            startIndex = None
            tmp = (((_hx_str.find("\"") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"\"",startIndex))) > -1)
        if (not tmp):
            return (("\"" + Std.string(_hx_str)) + "\"")
        return (("\"" + Std.string(hx_strings_Strings.replaceAll(_hx_str,"\"","\\\""))) + "\"")

    @staticmethod
    def quoteSingle(_hx_str):
        if (_hx_str is None):
            return None
        if (len(_hx_str) == 0):
            return "''"
        tmp = None
        if (_hx_str is None):
            tmp = False
        else:
            startIndex = None
            tmp = (((_hx_str.find("'") if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,"'",startIndex))) > -1)
        if (not tmp):
            return (("'" + Std.string(_hx_str)) + "'")
        return (("'" + Std.string(hx_strings_Strings.replaceAll(_hx_str,"'","\\'"))) + "'")

    @staticmethod
    def removeAfter(_hx_str,searchFor):
        return hx_strings_Strings.substringBefore(_hx_str,searchFor)

    @staticmethod
    def removeAfterLast(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLast(_hx_str,searchFor)

    @staticmethod
    def removeAfterIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAfterLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringBeforeLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAt(_hx_str,pos,length):
        if (((_hx_str is None) or ((len(_hx_str) == 0))) or ((length < 1))):
            return _hx_str
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (pos < 0):
            pos = (strLen + pos)
        if (pos < 0):
            raise haxe_Exception.thrown("[pos] must be smaller than -1 * str.length")
        if ((pos + length) >= strLen):
            return hx_strings_Strings.substring8(_hx_str,0,pos)
        return (Std.string(hx_strings_Strings.substring8(_hx_str,0,pos)) + Std.string(hx_strings_Strings.substring8(_hx_str,(pos + length))))

    @staticmethod
    def removeBefore(_hx_str,searchFor):
        return hx_strings_Strings.substringAfter(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLast(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLast(_hx_str,searchFor)

    @staticmethod
    def removeBeforeIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeBeforeLastIgnoreCase(_hx_str,searchFor):
        return hx_strings_Strings.substringAfterLastIgnoreCase(_hx_str,searchFor)

    @staticmethod
    def removeAll(searchIn,searchFor):
        return hx_strings_Strings.replaceAll(searchIn,searchFor,"")

    @staticmethod
    def removeFirst(searchIn,searchFor):
        return hx_strings_Strings.replaceFirst(searchIn,searchFor,"")

    @staticmethod
    def removeFirstIgnoreCase(searchIn,searchFor):
        return hx_strings_Strings.replaceFirstIgnoreCase(searchIn,searchFor,"")

    @staticmethod
    def removeAnsi(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.REGEX_ANSI_ESC.ereg.replace(_hx_str,"")

    @staticmethod
    def removeLeading(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while hx_strings_Strings.startsWith(searchIn,searchFor):
            searchIn = HxString.substring(searchIn,len(searchFor),len(searchIn))
        return searchIn

    @staticmethod
    def removeTags(xml):
        if ((xml is None) or ((len(xml) == 0))):
            return xml
        return hx_strings_Strings.REGEX_REMOVE_XML_TAGS.ereg.replace(xml,"")

    @staticmethod
    def removeTrailing(searchIn,searchFor):
        if (((searchIn is None) or ((len(searchIn) == 0))) or (((searchFor is None) or ((len(searchFor) == 0))))):
            return searchIn
        while hx_strings_Strings.endsWith(searchIn,searchFor):
            searchIn = HxString.substring(searchIn,0,(len(searchIn) - len(searchFor)))
        return searchIn

    @staticmethod
    def repeat(_hx_str,count,separator = None):
        if (separator is None):
            separator = ""
        if (_hx_str is None):
            return None
        if (count < 1):
            return ""
        if (count == 1):
            return _hx_str
        _g = []
        _g1 = 0
        _g2 = count
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(_hx_str)
        return separator.join([python_Boot.toString1(x1,'') for x1 in _g])

    @staticmethod
    def replaceAll(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        return StringTools.replace(searchIn,searchFor,replaceWith)

    @staticmethod
    def replaceFirst(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn,searchFor)
        return ((Std.string(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + Std.string(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def replaceFirstIgnoreCase(searchIn,searchFor,replaceWith):
        if (((searchIn is None) or (((searchIn is None) or ((len(searchIn) == 0))))) or ((searchFor is None))):
            return searchIn
        if (replaceWith is None):
            replaceWith = "null"
        searchFor = searchFor.lower()
        foundAt = None
        if (len(searchFor) == 0):
            if (((0 if ((searchIn is None)) else len(searchIn))) > 1):
                foundAt = 1
            else:
                return searchIn
        else:
            foundAt = hx_strings_Strings.indexOf8(searchIn.lower(),searchFor)
        return ((Std.string(hx_strings_Strings.substr8(searchIn,0,foundAt)) + ("null" if replaceWith is None else replaceWith)) + Std.string(hx_strings_Strings.substr8(searchIn,(foundAt + ((0 if ((searchFor is None)) else len(searchFor)))))))

    @staticmethod
    def reverse(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        chars = hx_strings_Strings.split8(_hx_str,[""])
        chars.reverse()
        return "".join([python_Boot.toString1(x1,'') for x1 in chars])

    @staticmethod
    def right(_hx_str,_hx_len):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return hx_strings_Strings.substring8(_hx_str,(((0 if ((_hx_str is None)) else len(_hx_str))) - _hx_len))

    @staticmethod
    def rpad(_hx_str,targetLength,padStr = None,canOverflow = None):
        if (padStr is None):
            padStr = " "
        if (canOverflow is None):
            canOverflow = True
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((_hx_str is None) or ((strLen > targetLength))):
            return _hx_str
        if ((padStr is None) or ((len(padStr) == 0))):
            padStr = " "
        padLen = (0 if ((padStr is None)) else len(padStr))
        sb = hx_strings_StringBuilder(_hx_str)
        while (strLen < targetLength):
            sb.add(padStr)
            strLen = (strLen + padLen)
        if canOverflow:
            return sb.toString()
        _hx_str = sb.toString()
        return (_hx_str if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= targetLength)) else hx_strings_Strings.substring8(_hx_str,0,targetLength))

    @staticmethod
    def split8(_hx_str,separator,maxParts = None):
        if (maxParts is None):
            maxParts = 0
        if ((_hx_str is None) or ((separator is None))):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        def _hx_local_0(s):
            return (s is not None)
        separators = list(filter(_hx_local_0,separator))
        if (len(separators) == 0):
            return None
        if ((maxParts <= 0) and ((len(separators) == 1))):
            delimiter = (separators[0] if 0 < len(separators) else None)
            if (delimiter == ""):
                return list(_hx_str)
            else:
                return _hx_str.split(delimiter)
        if (python_internal_ArrayImpl.indexOf(separators,"",None) > -1):
            if (maxParts <= 0):
                _g = []
                _g1 = 0
                _g2 = strLen
                while (_g1 < _g2):
                    i = _g1
                    _g1 = (_g1 + 1)
                    x = HxString.substr(_hx_str,i,1)
                    _g.append(x)
                return _g
            if (maxParts > strLen):
                maxParts = strLen
            maxParts = (maxParts - 1)
            _g = []
            _g1 = 0
            _g2 = maxParts
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = HxString.substr(_hx_str,i,1)
                _g.append(x)
            result = _g
            x = HxString.substr(_hx_str,maxParts,(strLen - maxParts))
            result.append(x)
            return result
        _g = []
        _g1 = 0
        while (_g1 < len(separators)):
            sep = (separators[_g1] if _g1 >= 0 and _g1 < len(separators) else None)
            _g1 = (_g1 + 1)
            x = (0 if ((sep is None)) else len(sep))
            _g.append(x)
        separatorsLengths = _g
        lastFoundAt = 0
        result = []
        resultCount = 0
        while True:
            separatorLen = 0
            foundAt = -1
            _g = 0
            _g1 = len(separators)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                sepFoundAt = hx_strings_Strings.indexOf8(_hx_str,(separators[i] if i >= 0 and i < len(separators) else None),lastFoundAt)
                if (sepFoundAt != -1):
                    if ((foundAt == -1) or ((sepFoundAt < foundAt))):
                        foundAt = sepFoundAt
                        separatorLen = (separatorsLengths[i] if i >= 0 and i < len(separatorsLengths) else None)
            resultCount = (resultCount + 1)
            if ((foundAt == -1) or ((resultCount == maxParts))):
                x = HxString.substr(_hx_str,lastFoundAt,(strLen - lastFoundAt))
                result.append(x)
                break
            x1 = HxString.substr(_hx_str,lastFoundAt,(foundAt - lastFoundAt))
            result.append(x1)
            lastFoundAt = (foundAt + separatorLen)
        return result

    @staticmethod
    def splitAt(_hx_str,splitPos):
        if (_hx_str is None):
            return None
        if ((splitPos is None) or ((len(splitPos) == 0))):
            return [_hx_str]
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return [_hx_str]
        pos = list()
        _g = 0
        _g1 = splitPos
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p < 0):
                p = (strLen + p)
            if ((p < 0) or ((p >= strLen))):
                continue
            if (python_internal_ArrayImpl.indexOf(pos,p,None) > -1):
                continue
            pos.append(p)
        def _hx_local_1(a,b):
            if (a < b):
                return -1
            elif (a > b):
                return 1
            else:
                return 0
        pos.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        result = list()
        lastPos = 0
        _g = 0
        while (_g < len(pos)):
            p = (pos[_g] if _g >= 0 and _g < len(pos) else None)
            _g = (_g + 1)
            chunk = hx_strings_Strings.substring8(_hx_str,lastPos,p)
            if ((chunk is not None) and ((len(chunk) > 0))):
                result.append(chunk)
            lastPos = p
        chunk = hx_strings_Strings.substring8(_hx_str,lastPos)
        if ((chunk is not None) and ((len(chunk) > 0))):
            result.append(chunk)
        return result

    @staticmethod
    def splitEvery(_hx_str,count):
        if (_hx_str is None):
            return None
        if (count < 1):
            raise haxe_Exception.thrown("[count] must be greater than 0")
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if ((strLen == 0) or ((count >= strLen))):
            return [_hx_str]
        result = list()
        pos = 0
        while True:
            chunk = hx_strings_Strings.substr8(_hx_str,pos,count)
            pos = (pos + count)
            if ((chunk is None) or ((len(chunk) == 0))):
                break
            result.append(chunk)
        return result

    @staticmethod
    def splitLines(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return []
        else:
            return hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)

    @staticmethod
    def startsWith(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if (((searchFor is None) or ((len(searchFor) == 0))) or ((searchIn == searchFor))):
            return True
        return searchIn.startswith(searchFor)

    @staticmethod
    def startsWithAny(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.startsWith(searchIn,candidate)):
                return True
        return False

    @staticmethod
    def startsWithAnyIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        searchIn = hx_strings_Strings.toLowerCase8(searchIn)
        _g = 0
        while (_g < len(searchFor)):
            candidate = (searchFor[_g] if _g >= 0 and _g < len(searchFor) else None)
            _g = (_g + 1)
            if ((candidate is not None) and hx_strings_Strings.startsWith(searchIn,hx_strings_Strings.toLowerCase8(candidate))):
                return True
        return False

    @staticmethod
    def startsWithIgnoreCase(searchIn,searchFor):
        if ((searchIn is None) or ((searchFor is None))):
            return False
        if ((searchFor is None) or ((len(searchFor) == 0))):
            return True
        return hx_strings_Strings.startsWith(searchIn.lower(),searchFor.lower())

    @staticmethod
    def substr8(_hx_str,startAt,_hx_len = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (_hx_len is None):
            _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        if (_hx_len <= 0):
            return ""
        if (startAt < 0):
            startAt = (startAt + (0 if ((_hx_str is None)) else len(_hx_str)))
            if (startAt < 0):
                startAt = 0
        return HxString.substr(_hx_str,startAt,_hx_len)

    @staticmethod
    def substring8(_hx_str,startAt,endAt = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (endAt is None):
            endAt = (0 if ((_hx_str is None)) else len(_hx_str))
        return HxString.substring(_hx_str,startAt,endAt)

    @staticmethod
    def substringAfter(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return _hx_str
        if ((HxOverrides.eq(_hx_str,"") or ((searchFor is None))) or ((searchFor == ""))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = None
        foundAt = (_hx_str.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,searchFor,startIndex))
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = (_this.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_this,searchFor,startIndex))
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBetween(_hx_str,after,before = None,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if ((HxOverrides.eq(_hx_str,"") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = None
        foundAfterAt = (_hx_str.find(after) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,after,startIndex))
        if (foundAfterAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = (foundAfterAt + len(after))
        foundBeforeAt = (_hx_str.find(before) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,before,startIndex))
        if (foundBeforeAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAfterAt + len(after)),foundBeforeAt)

    @staticmethod
    def substringBetweenIgnoreCase(_hx_str,after,before = None,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (before is None):
            before = after
        if ((HxOverrides.eq(_hx_str,"") or (((after is None) or ((len(after) == 0))))) or (((before is None) or ((len(before) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        strLower = hx_strings_Strings.toLowerCase8(_hx_str)
        after1 = hx_strings_Strings.toLowerCase8(after)
        before1 = hx_strings_Strings.toLowerCase8(before)
        startIndex = None
        foundAfterAt = (strLower.find(after1) if ((startIndex is None)) else HxString.indexOfImpl(strLower,after1,startIndex))
        if (foundAfterAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = (foundAfterAt + len(after1))
        foundBeforeAt = (strLower.find(before1) if ((startIndex is None)) else HxString.indexOfImpl(strLower,before1,startIndex))
        if (foundBeforeAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAfterAt + len(after1)),foundBeforeAt)

    @staticmethod
    def substringAfterLast(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        elif (searchFor == ""):
            length = len(_hx_str)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _hx_str.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _hx_str.find(searchFor, startLeft, len(_hx_str))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringAfterLastIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _this.rfind(searchFor, 0, len(_this))
        elif (searchFor == ""):
            length = len(_this)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _this.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _this.find(searchFor, startLeft, len(_this))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,(foundAt + len(searchFor)),None)

    @staticmethod
    def substringBefore(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = None
        foundAt = (_hx_str.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_hx_str,searchFor,startIndex))
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = (_this.find(searchFor) if ((startIndex is None)) else HxString.indexOfImpl(_this,searchFor,startIndex))
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLast(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _hx_str.rfind(searchFor, 0, len(_hx_str))
        elif (searchFor == ""):
            length = len(_hx_str)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _hx_str.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _hx_str.find(searchFor, startLeft, len(_hx_str))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def substringBeforeLastIgnoreCase(_hx_str,searchFor,notFoundDefault = None):
        if (notFoundDefault is None):
            notFoundDefault = 2
        if (_hx_str is None):
            return None
        if (HxOverrides.eq(_hx_str,"") or (((searchFor is None) or ((len(searchFor) == 0))))):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        searchFor = searchFor.lower()
        _this = _hx_str.lower()
        startIndex = None
        foundAt = None
        if (startIndex is None):
            foundAt = _this.rfind(searchFor, 0, len(_this))
        elif (searchFor == ""):
            length = len(_this)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            foundAt = (length if ((startIndex > length)) else startIndex)
        else:
            i = _this.rfind(searchFor, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(searchFor))) if ((i == -1)) else (i + 1))
            check = _this.find(searchFor, startLeft, len(_this))
            foundAt = (check if (((check > i) and ((check <= startIndex)))) else i)
        if (foundAt == -1):
            tmp = None
            notFoundDefault1 = notFoundDefault
            if (notFoundDefault1 == 1):
                tmp = None
            elif (notFoundDefault1 == 2):
                tmp = ""
            elif (notFoundDefault1 == 3):
                tmp = _hx_str
            else:
                pass
            return tmp
        return HxString.substring(_hx_str,0,foundAt)

    @staticmethod
    def toBool(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return False
        _g = _hx_str.lower()
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 1):
            if (_g == "0"):
                return False
            else:
                return True
        elif (_hx_local_0 == 5):
            if (_g == "false"):
                return False
            else:
                return True
        elif (_hx_local_0 == 2):
            if (_g == "no"):
                return False
            else:
                return True
        else:
            return True

    @staticmethod
    def toBytes(_hx_str):
        if (_hx_str is None):
            return None
        return haxe_io_Bytes.ofString(_hx_str)

    @staticmethod
    def toChar(charCode):
        return charCode

    @staticmethod
    def toCharIterator(_hx_str):
        if (_hx_str is None):
            return hx_strings__CharIterator_NullCharIterator.INSTANCE
        else:
            return hx_strings__CharIterator_StringCharIterator(_hx_str,0)

    @staticmethod
    def toChars(_hx_str):
        if (_hx_str is None):
            return None
        strLen = (0 if ((_hx_str is None)) else len(_hx_str))
        if (strLen == 0):
            return []
        _g = []
        _g1 = 0
        _g2 = strLen
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = HxString.charCodeAt(_hx_str,i)
            _g.append(x)
        return _g

    @staticmethod
    def toPattern(_hx_str,options = None):
        if (_hx_str is None):
            return None
        return hx_strings_Pattern.compile(_hx_str,options)

    @staticmethod
    def toEReg(_hx_str,opt = None):
        if (opt is None):
            opt = ""
        if (_hx_str is None):
            raise haxe_Exception.thrown("[str] must not be null")
        return EReg(_hx_str,opt)

    @staticmethod
    def toFloat(_hx_str,ifUnparseable):
        if (_hx_str is None):
            return ifUnparseable
        result = Std.parseFloat(_hx_str)
        if python_lib_Math.isnan(result):
            return ifUnparseable
        else:
            return result

    @staticmethod
    def toFloatOrNull(_hx_str,ifUnparseable = None):
        if (_hx_str is None):
            return ifUnparseable
        result = Std.parseFloat(_hx_str)
        if python_lib_Math.isnan(result):
            return ifUnparseable
        else:
            return result

    @staticmethod
    def toHex(num,minDigits = None,upperCase = None):
        if (minDigits is None):
            minDigits = 0
        if (upperCase is None):
            upperCase = True
        hexed = StringTools.hex(num,0)
        if (not upperCase):
            return hexed.lower()
        if (len(hexed) >= minDigits):
            return hexed
        return hx_strings_Strings.lpad(hexed,minDigits,"0")

    @staticmethod
    def toInt(_hx_str,ifUnparseable):
        if (_hx_str is None):
            return ifUnparseable
        result = Std.parseInt(_hx_str)
        if (result is None):
            return ifUnparseable
        else:
            return result

    @staticmethod
    def toIntOrNull(_hx_str,ifUnparseable = None):
        if (_hx_str is None):
            return ifUnparseable
        result = Std.parseInt(_hx_str)
        if (result is None):
            return ifUnparseable
        else:
            return result

    @staticmethod
    def toLowerCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.lower()

    @staticmethod
    def toLowerCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        lowerChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapU2L.h.get(this1,None)
        firstChar = (this1 if ((lowerChar is None)) else lowerChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def toLowerCamel(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(word))
        else:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word)))
        return hx_strings_Strings.toLowerCaseFirstChar(sb.toString())

    @staticmethod
    def toLowerHyphen(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "-".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toLowerUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toLowerCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toTitle(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if keepUppercasedWords:
            def _hx_local_0(s):
                if (hx_strings_Strings.toUpperCase8(s) == s):
                    return s
                else:
                    return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s))
            _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
            return " ".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_1(s):
            return hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(s))
        _this = list(map(_hx_local_1,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toUpperCamel(_hx_str,keepUppercasedWords = None):
        if (keepUppercasedWords is None):
            keepUppercasedWords = True
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        if keepUppercasedWords:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(word))
        else:
            _g = 0
            _g1 = hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)
            while (_g < len(_g1)):
                word = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                sb.add(hx_strings_Strings.toUpperCaseFirstChar(hx_strings_Strings.toLowerCase8(word)))
        return sb.toString()

    @staticmethod
    def toUpperUnderscore(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(s):
            return hx_strings_Strings.toUpperCase8(s)
        _this = list(map(_hx_local_0,hx_strings_Strings._splitAsciiWordsUnsafe(_hx_str)))
        return "_".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def toString(_hx_str):
        if (_hx_str is None):
            return "null"
        else:
            return _hx_str

    @staticmethod
    def toUpperCase8(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return _hx_str.upper()

    @staticmethod
    def toUpperCaseFirstChar(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        this1 = HxString.charCodeAt(_hx_str,0)
        upperChar = hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER.mapL2U.h.get(this1,None)
        firstChar = (this1 if ((upperChar is None)) else upperChar)
        if (len(_hx_str) == 1):
            return "".join(map(chr,[firstChar]))
        other = hx_strings_Strings.substr8(_hx_str,1)
        return (HxOverrides.stringOrNull("".join(map(chr,[firstChar]))) + ("null" if other is None else other))

    @staticmethod
    def trim(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.trim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        return hx_strings_Strings.trimLeft(hx_strings_Strings.trimRight(_hx_str,hx_strings_internal__Either2__Either2.b(removableChars)),hx_strings_internal__Either2__Either2.b(removableChars))

    @staticmethod
    def trimRight(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.rtrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = (_hx_len - 1)
        while ((i > -1) and ((python_internal_ArrayImpl.indexOf(removableChars,hx_strings_Strings.charCodeAt8(hx_strings_Strings.charAt8(_hx_str,i),0),None) > -1))):
            i = (i - 1)
        if (i < ((_hx_len - 1))):
            return hx_strings_Strings.substring8(_hx_str,0,(i + 1))
        return _hx_str

    @staticmethod
    def trimLeft(_hx_str,charsToRemove = None):
        if (_hx_str is None):
            return _hx_str
        if (charsToRemove is None):
            return StringTools.ltrim(_hx_str)
        removableChars = None
        _g = charsToRemove
        removableChars1 = _g.index
        if (removableChars1 == 0):
            str1 = _g.params[0]
            removableChars = hx_strings_Strings.toChars(str1)
        elif (removableChars1 == 1):
            chars = _g.params[0]
            removableChars = chars
        else:
            pass
        if (len(removableChars) == 0):
            return _hx_str
        _hx_len = (0 if ((_hx_str is None)) else len(_hx_str))
        i = 0
        while ((i < _hx_len) and ((python_internal_ArrayImpl.indexOf(removableChars,hx_strings_Strings.charCodeAt8(hx_strings_Strings.charAt8(_hx_str,i),0),None) > -1))):
            i = (i + 1)
        if (i > 0):
            return hx_strings_Strings.substring8(_hx_str,i,_hx_len)
        return _hx_str

    @staticmethod
    def trimLines(_hx_str,charsToRemove = None):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        def _hx_local_0(line):
            return hx_strings_Strings.trim(line,charsToRemove)
        _this = list(map(_hx_local_0,hx_strings_Strings.REGEX_SPLIT_LINES.ereg.split(_hx_str)))
        return "\n".join([python_Boot.toString1(x1,'') for x1 in _this])

    @staticmethod
    def trimToNull(_hx_str):
        if (_hx_str is None):
            return None
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return None
        return trimmed

    @staticmethod
    def trimToEmpty(_hx_str):
        trimmed = hx_strings_Strings.trim(_hx_str)
        if ((trimmed is None) or ((len(trimmed) == 0))):
            return ""
        return trimmed

    @staticmethod
    def truncate(_hx_str,maxLength):
        if (((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLength):
            return _hx_str
        else:
            return hx_strings_Strings.substring8(_hx_str,0,maxLength)

    @staticmethod
    def urlDecode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.unquote(_hx_str)

    @staticmethod
    def urlEncode(_hx_str):
        if ((_hx_str is None) or ((len(_hx_str) == 0))):
            return _hx_str
        return python_lib_urllib_Parse.quote(_hx_str,"")

    @staticmethod
    def wrap(_hx_str,maxLineLength,splitLongWords = None,newLineSeparator = None):
        if (splitLongWords is None):
            splitLongWords = True
        if (newLineSeparator is None):
            newLineSeparator = "\n"
        if ((((0 if ((_hx_str is None)) else len(_hx_str))) <= maxLineLength) or ((maxLineLength < 1))):
            return _hx_str
        sb = hx_strings_StringBuilder()
        wordChars = []
        currLineLength = 0
        _g = 0
        _g1 = hx_strings_Strings.toChars(_hx_str)
        while (_g < len(_g1)):
            ch = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((ch > 8) and ((ch < 14))) or ((ch == 32))):
                if (len(wordChars) > 0):
                    _g2 = 0
                    while (_g2 < len(wordChars)):
                        wordCh = (wordChars[_g2] if _g2 >= 0 and _g2 < len(wordChars) else None)
                        _g2 = (_g2 + 1)
                        if ((currLineLength == maxLineLength) and splitLongWords):
                            sb.add(newLineSeparator)
                            currLineLength = 0
                        currLineLength = (currLineLength + 1)
                        sb.addChar(wordCh)
                    wordChars = []
                if (currLineLength >= maxLineLength):
                    sb.add(newLineSeparator)
                    currLineLength = 0
                sb.addChar(ch)
                currLineLength = (currLineLength + 1)
            else:
                wordChars.append(ch)
        if (len(wordChars) > 0):
            _g = 0
            while (_g < len(wordChars)):
                wordCh = (wordChars[_g] if _g >= 0 and _g < len(wordChars) else None)
                _g = (_g + 1)
                if ((currLineLength == maxLineLength) and splitLongWords):
                    sb.add(newLineSeparator)
                    currLineLength = 0
                currLineLength = (currLineLength + 1)
                sb.addChar(wordCh)
        return sb.toString()


class hx_strings_StringDiff:
    _hx_class_name = "hx.strings.StringDiff"
    __slots__ = ("at", "left", "right")
    _hx_fields = ["at", "left", "right"]
    _hx_methods = ["toString"]

    def __init__(self):
        self.right = None
        self.left = None
        self.at = -1

    def toString(self):
        return (((((("StringDiff[at=" + Std.string(self.at)) + ", left=") + HxOverrides.stringOrNull(self.left)) + ", right=") + HxOverrides.stringOrNull(self.right)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.at = None
        _hx_o.left = None
        _hx_o.right = None

class hx_strings_HashCodeAlgorithm(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.HashCodeAlgorithm"
    _hx_constructs = ["PLATFORM_SPECIFIC", "ADLER32", "CRC32B", "DJB2A", "JAVA", "SDBM"]
hx_strings_HashCodeAlgorithm.PLATFORM_SPECIFIC = hx_strings_HashCodeAlgorithm("PLATFORM_SPECIFIC", 0, ())
hx_strings_HashCodeAlgorithm.ADLER32 = hx_strings_HashCodeAlgorithm("ADLER32", 1, ())
hx_strings_HashCodeAlgorithm.CRC32B = hx_strings_HashCodeAlgorithm("CRC32B", 2, ())
hx_strings_HashCodeAlgorithm.DJB2A = hx_strings_HashCodeAlgorithm("DJB2A", 3, ())
hx_strings_HashCodeAlgorithm.JAVA = hx_strings_HashCodeAlgorithm("JAVA", 4, ())
hx_strings_HashCodeAlgorithm.SDBM = hx_strings_HashCodeAlgorithm("SDBM", 5, ())

class hx_strings_AnsiToHtmlRenderMethod(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.AnsiToHtmlRenderMethod"
    _hx_constructs = ["StyleAttributes", "CssClasses", "CssClassesCallback"]

    @staticmethod
    def CssClassesCallback(func):
        return hx_strings_AnsiToHtmlRenderMethod("CssClassesCallback", 2, (func,))
hx_strings_AnsiToHtmlRenderMethod.StyleAttributes = hx_strings_AnsiToHtmlRenderMethod("StyleAttributes", 0, ())
hx_strings_AnsiToHtmlRenderMethod.CssClasses = hx_strings_AnsiToHtmlRenderMethod("CssClasses", 1, ())


class hx_strings_AnsiState:
    _hx_class_name = "hx.strings.AnsiState"
    __slots__ = ("bgcolor", "blink", "bold", "fgcolor", "underline")
    _hx_fields = ["bgcolor", "blink", "bold", "fgcolor", "underline"]
    _hx_methods = ["isActive", "reset", "copyFrom", "setGraphicModeParameter", "toCSS"]
    _hx_statics = ["defaultCssClassesCallback"]

    def __init__(self,copyFrom = None):
        self.fgcolor = None
        self.bgcolor = None
        self.underline = False
        self.bold = False
        self.blink = False
        if (copyFrom is None):
            self.reset()
        else:
            self.copyFrom(copyFrom)

    def isActive(self):
        if (not (((((self.fgcolor is not None) or ((self.bgcolor is not None))) or self.bold) or self.underline))):
            return self.blink
        else:
            return True

    def reset(self):
        self.fgcolor = None
        self.bgcolor = None
        self.bold = False
        self.underline = False
        self.blink = False

    def copyFrom(self,other):
        self.fgcolor = other.fgcolor
        self.bgcolor = other.bgcolor
        self.bold = other.bold
        self.underline = other.underline
        self.blink = other.blink

    def setGraphicModeParameter(self,param):
        param1 = param
        if (param1 == 0):
            self.reset()
        elif (param1 == 1):
            self.bold = True
        elif (param1 == 4):
            self.underline = True
        elif (param1 == 5):
            self.blink = True
        elif (param1 == 30):
            self.fgcolor = "black"
        elif (param1 == 31):
            self.fgcolor = "red"
        elif (param1 == 32):
            self.fgcolor = "green"
        elif (param1 == 33):
            self.fgcolor = "yellow"
        elif (param1 == 34):
            self.fgcolor = "blue"
        elif (param1 == 35):
            self.fgcolor = "magenta"
        elif (param1 == 36):
            self.fgcolor = "cyan"
        elif (param1 == 37):
            self.fgcolor = "white"
        elif (param1 == 40):
            self.bgcolor = "black"
        elif (param1 == 41):
            self.bgcolor = "red"
        elif (param1 == 42):
            self.bgcolor = "green"
        elif (param1 == 43):
            self.bgcolor = "yellow"
        elif (param1 == 44):
            self.bgcolor = "blue"
        elif (param1 == 45):
            self.bgcolor = "magenta"
        elif (param1 == 46):
            self.bgcolor = "cyan"
        elif (param1 == 47):
            self.bgcolor = "white"
        else:
            pass

    def toCSS(self,renderMethod):
        if (((((self.fgcolor is not None) or ((self.bgcolor is not None))) or self.bold) or self.underline) or self.blink):
            sb = hx_strings_StringBuilder()
            if (renderMethod is None):
                renderMethod = hx_strings_AnsiToHtmlRenderMethod.StyleAttributes
            tmp = renderMethod.index
            if (tmp == 0):
                if (self.fgcolor is not None):
                    sb.add("color:").add(self.fgcolor).add(";")
                if (self.bgcolor is not None):
                    sb.add("background-color:").add(self.bgcolor).add(";")
                if self.bold:
                    sb.add("font-weight:bold;")
                if self.underline:
                    sb.add("text-decoration:underline;")
                if self.blink:
                    sb.add("text-decoration:blink;")
            elif (tmp == 1):
                sb.add(hx_strings_AnsiState.defaultCssClassesCallback(self))
            elif (tmp == 2):
                func = renderMethod.params[0]
                sb.add(func(self))
            else:
                pass
            return sb.toString()
        return ""

    @staticmethod
    def defaultCssClassesCallback(state):
        classes = []
        if (state.fgcolor is not None):
            x = ("ansi_fg_" + HxOverrides.stringOrNull(state.fgcolor))
            classes.append(x)
        if (state.bgcolor is not None):
            x = ("ansi_bg_" + HxOverrides.stringOrNull(state.bgcolor))
            classes.append(x)
        if state.bold:
            classes.append("ansi_bold")
        if state.underline:
            classes.append("ansi_underline")
        if state.blink:
            classes.append("ansi_blink")
        return " ".join([python_Boot.toString1(x1,'') for x1 in classes])

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bgcolor = None
        _hx_o.blink = None
        _hx_o.bold = None
        _hx_o.fgcolor = None
        _hx_o.underline = None


class hx_strings_ansi_Ansi:
    _hx_class_name = "hx.strings.ansi.Ansi"
    __slots__ = ()
    _hx_statics = ["ESC", "attr", "bg", "cursor", "clearScreen", "clearLine", "fg", "writer"]

    @staticmethod
    def attr(attr):
        return (("\x1B[" + Std.string(attr)) + "m")

    @staticmethod
    def bg(color):
        return ((("\x1B[" + "4") + Std.string(color)) + "m")

    @staticmethod
    def cursor(cmd):
        tmp = cmd.index
        if (tmp == 0):
            return ("\x1B[" + "H")
        elif (tmp == 1):
            line = cmd.params[0]
            column = cmd.params[1]
            return (((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H")
        elif (tmp == 2):
            lines = cmd.params[0]
            return (("\x1B[" + Std.string(lines)) + "A")
        elif (tmp == 3):
            lines = cmd.params[0]
            return (("\x1B[" + Std.string(lines)) + "B")
        elif (tmp == 4):
            columns = cmd.params[0]
            return (("\x1B[" + Std.string(columns)) + "C")
        elif (tmp == 5):
            columns = cmd.params[0]
            return (("\x1B[" + Std.string(columns)) + "D")
        elif (tmp == 6):
            return ("\x1B[" + "s")
        elif (tmp == 7):
            return ("\x1B[" + "u")
        else:
            pass

    @staticmethod
    def clearScreen():
        return ("\x1B[" + "2J")

    @staticmethod
    def clearLine():
        return ("\x1B[" + "K")

    @staticmethod
    def fg(color):
        return ((("\x1B[" + "3") + Std.string(color)) + "m")

    @staticmethod
    def writer(out):
        return hx_strings_ansi_AnsiWriter(out)

class hx_strings_ansi_AnsiCursor(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.ansi.AnsiCursor"
    _hx_constructs = ["GoToHome", "GoToPos", "MoveUp", "MoveDown", "MoveRight", "MoveLeft", "SavePos", "RestorePos"]

    @staticmethod
    def GoToPos(line,column):
        return hx_strings_ansi_AnsiCursor("GoToPos", 1, (line,column))

    @staticmethod
    def MoveUp(lines):
        return hx_strings_ansi_AnsiCursor("MoveUp", 2, (lines,))

    @staticmethod
    def MoveDown(lines):
        return hx_strings_ansi_AnsiCursor("MoveDown", 3, (lines,))

    @staticmethod
    def MoveRight(columns):
        return hx_strings_ansi_AnsiCursor("MoveRight", 4, (columns,))

    @staticmethod
    def MoveLeft(columns):
        return hx_strings_ansi_AnsiCursor("MoveLeft", 5, (columns,))
hx_strings_ansi_AnsiCursor.GoToHome = hx_strings_ansi_AnsiCursor("GoToHome", 0, ())
hx_strings_ansi_AnsiCursor.SavePos = hx_strings_ansi_AnsiCursor("SavePos", 6, ())
hx_strings_ansi_AnsiCursor.RestorePos = hx_strings_ansi_AnsiCursor("RestorePos", 7, ())


class hx_strings_ansi__AnsiWriter_StringBuf_StringBuilder_or_Output_Impl_:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBuf_StringBuilder_or_Output_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "fromStringBuilder", "fromStringBuf", "fromOutput"]

    @staticmethod
    def _new(writer):
        return writer

    @staticmethod
    def fromStringBuilder(out):
        return hx_strings_ansi__AnsiWriter_StringBuilderStringWriter(out)

    @staticmethod
    def fromStringBuf(out):
        return hx_strings_ansi__AnsiWriter_StringBufStringWriter(out)

    @staticmethod
    def fromOutput(out):
        return hx_strings_ansi__AnsiWriter_OutputStringWriter(out)


class hx_strings_ansi__AnsiWriter_StringBufStringWriter:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBufStringWriter"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["flush", "write"]
    _hx_interfaces = [hx_strings_ansi__AnsiWriter_StringWriter]

    def __init__(self,out):
        self.out = out

    def flush(self):
        pass

    def write(self,_hx_str):
        _this = self.out
        s = Std.string(_hx_str)
        _this.b.write(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None


class hx_strings_ansi__AnsiWriter_StringBuilderStringWriter:
    _hx_class_name = "hx.strings.ansi._AnsiWriter.StringBuilderStringWriter"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["flush", "write"]
    _hx_interfaces = [hx_strings_ansi__AnsiWriter_StringWriter]

    def __init__(self,out):
        self.out = out

    def flush(self):
        pass

    def write(self,_hx_str):
        self.out.add(_hx_str)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None


class hx_strings_internal_Bits:
    _hx_class_name = "hx.strings.internal.Bits"
    __slots__ = ()
    _hx_statics = ["clearBit", "setBit", "toggleBit", "getBit"]

    @staticmethod
    def clearBit(num,bitPos):
        return (num & ~((1 << ((bitPos - 1)))))

    @staticmethod
    def setBit(num,bitPos):
        return (num | ((1 << ((bitPos - 1)))))

    @staticmethod
    def toggleBit(num,bitPos):
        return (num ^ ((1 << ((bitPos - 1)))))

    @staticmethod
    def getBit(num,bitPos):
        return (1 == (((num >> ((bitPos - 1))) & 1)))


class hx_strings_internal__Either2_Either2_Impl_:
    _hx_class_name = "hx.strings.internal._Either2.Either2_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB"]
    value = None

    @staticmethod
    def _new(value):
        return value

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        return hx_strings_internal__Either2__Either2.a(value)

    @staticmethod
    def fromB(value):
        return hx_strings_internal__Either2__Either2.b(value)

class hx_strings_internal__Either2__Either2(Enum):
    __slots__ = ()
    _hx_class_name = "hx.strings.internal._Either2._Either2"
    _hx_constructs = ["a", "b"]

    @staticmethod
    def a(v):
        return hx_strings_internal__Either2__Either2("a", 0, (v,))

    @staticmethod
    def b(v):
        return hx_strings_internal__Either2__Either2("b", 1, (v,))


class hx_strings_internal__Either3_Either3_Impl_:
    _hx_class_name = "hx.strings.internal._Either3.Either3_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "fromA", "fromB", "fromC"]
    value = None

    @staticmethod
    def _new(value):
        return value

    @staticmethod
    def get_value(this1):
        return this1

    @staticmethod
    def fromA(value):
        return hx_strings_internal__Either3__Either3.a(value)

    @staticmethod
    def fromB(value):
        return hx_strings_internal__Either3__Either3.b(value)

    @staticmethod
    def fromC(value):
        return hx_strings_internal__Either3__Either3.c(value)


class hx_strings_internal__OneOrMany_OneOrMany_Impl_:
    _hx_class_name = "hx.strings.internal._OneOrMany.OneOrMany_Impl_"
    __slots__ = ()
    _hx_statics = ["fromSingle"]

    @staticmethod
    def fromSingle(value):
        return [value]


class hx_strings_internal__RingBuffer_RingBuffer_Impl_:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBuffer_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get"]

    @staticmethod
    def _new(size):
        return hx_strings_internal__RingBuffer_RingBufferImpl(size)

    @staticmethod
    def get(this1,index):
        return this1.get(index)


class hx_strings_internal__RingBuffer_RingBufferIterator:
    _hx_class_name = "hx.strings.internal._RingBuffer.RingBufferIterator"
    __slots__ = ("buff", "idx")
    _hx_fields = ["buff", "idx"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,buff):
        self.idx = -1
        self.buff = buff

    def hasNext(self):
        return ((self.idx + 1) < self.buff.length)

    def next(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.idx
        _hx_local_0.idx = (_hx_local_1 + 1)
        _hx_local_1
        return self.buff.get(self.idx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buff = None
        _hx_o.idx = None


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["read", "write", "append"]

    @staticmethod
    def read(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def write(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("wb" if binary else "w")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)

    @staticmethod
    def append(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("ab" if binary else "a")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

Main.text_line = 0
forGL_ForGL_ui.system_name = ""
forGL_ForGL_ui.error_count_ui = 0
forGL_ForGL_ui.error_msgs_ui = ""
forGL_ForGL_ui.warning_count_ui = 0
forGL_ForGL_ui.warning_msgs_ui = ""
forGL_ForGL_ui.out_buffers = list()
forGL_ForGL_ui.DEFAULT_TYPE_COLOR = 7
forGL_ForGL_ui.COMMENT_COLOR = 3
forGL_ForGL_ui.DATA_COLOR = 1
forGL_ForGL_ui.NOUN_COLOR = 6
forGL_ForGL_ui.OP_COLOR = 2
forGL_ForGL_ui.VERB_COLOR = 4
forGL_ForGL_ui.VERB_BI_COLOR = 5
forGL_ForGL_ui.DEFAULT_COLOR = 7
forGL_ForGL_ui.SEPARATOR_COLOR = 5
forGL_ForGL_ui.current_line = 0
forGL_ForGL_ui.current_column = 0
forGL_ForGL_ui.home_line = 0
forGL_ForGL_ui.home_column = 0
forGL_ForGL_ui.blanks78 = "                                                                              "
forGL_ForGL_ui.stdin = Sys.stdin()
forGL_ForGL_ui.stdout = Sys.stdout()
forGL_ForGL_ui.writer = hx_strings_ansi_AnsiWriter(hx_strings_ansi__AnsiWriter_OutputStringWriter(forGL_ForGL_ui.stdout))
forGL_ForGL_ui.msg_call_count = 0
forGL_ForGL_ui.status_msgs = ""
forGL_ForGL_ui.enterYourVerb_return = 0
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
hx_strings__Char_Char_Impl_.CHAR_CASE_MAPPER = hx_strings__Char_CharCaseMapper()
hx_strings__Char_Char_Impl_.BACKSPACE = 8
hx_strings__Char_Char_Impl_.TAB = 9
hx_strings__Char_Char_Impl_.LF = 10
hx_strings__Char_Char_Impl_.CR = 13
hx_strings__Char_Char_Impl_.ESC = 27
hx_strings__Char_Char_Impl_.SPACE = 32
hx_strings__Char_Char_Impl_.EXCLAMATION_MARK = 33
hx_strings__Char_Char_Impl_.DOUBLE_QUOTE = 34
hx_strings__Char_Char_Impl_.HASH = 35
hx_strings__Char_Char_Impl_.DOLLAR = 36
hx_strings__Char_Char_Impl_.AMPERSAND = 38
hx_strings__Char_Char_Impl_.SINGLE_QUOTE = 39
hx_strings__Char_Char_Impl_.BRACKET_ROUND_LEFT = 40
hx_strings__Char_Char_Impl_.BRACKET_ROUND_RIGHT = 41
hx_strings__Char_Char_Impl_.ASTERISK = 42
hx_strings__Char_Char_Impl_.PLUS = 43
hx_strings__Char_Char_Impl_.COMMA = 44
hx_strings__Char_Char_Impl_.MINUS = 45
hx_strings__Char_Char_Impl_.DOT = 46
hx_strings__Char_Char_Impl_.SLASH = 47
hx_strings__Char_Char_Impl_.ZERO = 48
hx_strings__Char_Char_Impl_.ONE = 49
hx_strings__Char_Char_Impl_.TWO = 50
hx_strings__Char_Char_Impl_.TRHEE = 51
hx_strings__Char_Char_Impl_.FOUR = 52
hx_strings__Char_Char_Impl_.FIVE = 53
hx_strings__Char_Char_Impl_.SIX = 54
hx_strings__Char_Char_Impl_.SEVEN = 55
hx_strings__Char_Char_Impl_.EIGHT = 56
hx_strings__Char_Char_Impl_.NINE = 57
hx_strings__Char_Char_Impl_.COLON = 58
hx_strings__Char_Char_Impl_.SEMICOLON = 59
hx_strings__Char_Char_Impl_.LOWER_THAN = 60
hx_strings__Char_Char_Impl_.EQUALS = 61
hx_strings__Char_Char_Impl_.GREATER_THAN = 62
hx_strings__Char_Char_Impl_.QUESTION_MARK = 63
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_LEFT = 91
hx_strings__Char_Char_Impl_.BACKSLASH = 92
hx_strings__Char_Char_Impl_.BRACKET_SQUARE_RIGHT = 93
hx_strings__Char_Char_Impl_.CARET = 94
hx_strings__Char_Char_Impl_.UNDERSCORE = 95
hx_strings__Char_Char_Impl_.BRACKET_CURLY_LEFT = 123
hx_strings__Char_Char_Impl_.PIPE = 124
hx_strings__Char_Char_Impl_.BRACKET_CURLY_RIGHT = 125
hx_strings__CharIterator_NullCharIterator.INSTANCE = hx_strings__CharIterator_NullCharIterator()
hx_strings_Pattern.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'immutable': None, 'threadSafe': None})})
hx_strings_Matcher.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'notThreadSafe': None})})
hx_strings_StringBuilder.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'notThreadSafe': None})})
def _hx_init_hx_strings_internal_OS_isWindows():
    def _hx_local_0():
        os = Sys.systemName()
        _this = EReg("win","i")
        _this.matchObj = python_lib_Re.search(_this.pattern,os)
        return (_this.matchObj is not None)
    return _hx_local_0()
hx_strings_internal_OS.isWindows = _hx_init_hx_strings_internal_OS_isWindows()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
hx_strings_Strings.REGEX_ANSI_ESC = hx_strings_Pattern.compile((HxOverrides.stringOrNull("".join(map(chr,[27]))) + "\\[[;\\d]*m"),hx_strings_internal__Either3__Either3.b("g"))
hx_strings_Strings.REGEX_HTML_UNESCAPE = hx_strings_Pattern.compile("&(#\\d+|amp|nbsp|apos|lt|gt|quot);",hx_strings_internal__Either3__Either3.b("g"))
hx_strings_Strings.REGEX_SPLIT_LINES = hx_strings_Pattern.compile("\\r?\\n",hx_strings_internal__Either3__Either3.b("g"))
hx_strings_Strings.REGEX_REMOVE_XML_TAGS = hx_strings_Pattern.compile("<[!a-zA-Z\\/][^>]*>",hx_strings_internal__Either3__Either3.b("g"))
hx_strings_Strings.POS_NOT_FOUND = -1
hx_strings_Strings.NEW_LINE_NIX = "\n"
hx_strings_Strings.NEW_LINE_WIN = "\r\n"
hx_strings_Strings.NEW_LINE = ("\r\n" if (hx_strings_internal_OS.isWindows) else "\n")
hx_strings_ansi_Ansi.ESC = "\x1B["
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")

Main.main()
